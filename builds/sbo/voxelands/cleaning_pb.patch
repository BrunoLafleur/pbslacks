diff -rU5 voxelands-v1709.00old/src/activeobject.h voxelands-v1709.00good/src/activeobject.h
--- voxelands-v1709.00old/src/activeobject.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/activeobject.h	2024-09-22 18:41:01.677655749 +0200
@@ -55,10 +55,12 @@
 	ActiveObject(u16 id):
 		m_id(id)
 	{
 	}
 
+	virtual ~ActiveObject() {};
+	
 	u16 getId()
 	{
 		return m_id;
 	}
 
diff -rU5 voxelands-v1709.00old/src/array.c voxelands-v1709.00good/src/array.c
--- voxelands-v1709.00old/src/array.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/array.c	2024-09-22 18:41:01.677655749 +0200
@@ -59,11 +59,11 @@
 array_t *array_copy(array_t *a)
 {
 	array_t *r = array_create(ARRAY_TYPE_STRING);
 
 	if (a) {
-		int i;
+		uint32_t i;
 		r->type = a->type;
 		switch (a->type) {
 		case ARRAY_TYPE_STRING:
 			for (i=0; i<a->length; i++) {
 				array_push_string(r,((char**)(a->data))[i]);
@@ -92,11 +92,11 @@
 }
 
 /* compare two arrays */
 int array_cmp(array_t *a1, array_t *a2)
 {
-	int i;
+	uint32_t i;
 	char** c1;
 	char** c2;
 	int *i1;
 	int *i2;
 	float *f1;
@@ -182,11 +182,11 @@
 }
 
 /* destroy an array */
 void array_free(array_t *a, int freestruct)
 {
-	int i;
+	uint32_t i;
 	if (!a)
 		return;
 	if (a->type == ARRAY_TYPE_STRING) {
 		char** p = a->data;
 		for (i=0; i<a->length; i++ ) {
@@ -366,10 +366,14 @@
 }
 
 * set the value of array index i to an int value */
 int array_set_int(array_t *a, uint32_t v, int i)
 {
+
+	if(i < 0)
+	    return 1;
+	
 	uint32_t *p = a->data;
 	if (a->type == ARRAY_TYPE_STRING) {
 		char sv[20];
 		sprintf(sv,"%u",v);
 		return array_set_string(a,sv,i);
@@ -377,11 +381,11 @@
 		return array_set_float(a,(float)v,i);
 	}else if (a->type != ARRAY_TYPE_INT) {
 		return 1;
 	}
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(uint32_t)*l);
 		if (!p)
@@ -391,21 +395,25 @@
 		}
 		a->data = p;
 		a->size = l;
 	}
 
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	p[i] = v;
 
 	return 0;
 }
 
 /* set the value of array index i to a float value */
 int array_set_float(array_t *a, float v, int i)
 {
+	
+	if(i < 0)
+	    return 1;
+	
 	float *p = a->data;
 	if (a->type == ARRAY_TYPE_STRING) {
 		char sv[20];
 		sprintf(sv,"%f",v);
 		return array_set_string(a,sv,i);
@@ -413,11 +421,11 @@
 		return array_set_float(a,(uint32_t)v,i);
 	}else if (a->type != ARRAY_TYPE_FLOAT) {
 		return 1;
 	}
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(float)*l);
 		if (!p)
@@ -426,26 +434,30 @@
 			p[k] = 0.0;
 		}
 		a->data = p;
 		a->size = l;
 	}
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	p[i] = v;
 
 	return 0;
 }
 
 /* set the value of array index i to a string value */
 int array_set_string(array_t *a, char* v, int i)
 {
+	
+	if(i < 0)
+	    return 1;
+	
 	char** p = a->data;
 	if (a->type != ARRAY_TYPE_STRING)
 		return 1;
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(char*)*l);
 		if (!p)
@@ -454,11 +466,11 @@
 			p[k] = NULL;
 		}
 		a->data = p;
 		a->size = l;
 	}
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	if (p[i])
 		free(p[i]);
 
@@ -472,15 +484,19 @@
 }
 
 /* set the value of array index i to a ponter value */
 int array_set_ptr(array_t *a, void* v, int i)
 {
+		
+	if(i < 0)
+	    return 1;
+
 	char** p = a->data;
 	if (a->type != ARRAY_TYPE_PTR)
 		return 1;
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(char*)*l);
 		if (!p)
@@ -489,22 +505,22 @@
 			p[k] = NULL;
 		}
 		a->data = p;
 		a->size = l;
 	}
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	p[i] = v;
 
 	return 0;
 }
 
 /* insert a pointer onto the first NULL index of an array */
 int array_insert_ptr(array_t *a, void *v)
 {
-	int i;
+	uint32_t i;
 	uint8_t** p;
 
 	if (a->type != ARRAY_TYPE_PTR)
 		return 1;
 
@@ -599,12 +615,16 @@
 }
 
 /* get an int value from an array */
 uint32_t array_get_int(array_t *a, int i)
 {
+
+	if(i < 0)
+	    return 0;
+	
 	if (a->type == ARRAY_TYPE_INT) {
-		if (a->length <= i)
+	    if ((int) a->length <= i)
 			return 0;
 		return ((uint32_t*)(a->data))[i];
 	}else if (a->type == ARRAY_TYPE_FLOAT) {
 		float v = array_get_float(a,i);
 		return (uint32_t)v;
@@ -619,12 +639,16 @@
 }
 
 /* get a float value from an array */
 float array_get_float(array_t *a, int i)
 {
+	
+	if(i < 0)
+	    return 0.0;
+	
 	if (a->type == ARRAY_TYPE_FLOAT) {
-		if (a->length <= i)
+	    if ((int) a->length <= i)
 			return 0.0;
 		return ((float*)(a->data))[i];
 	}else if (a->type == ARRAY_TYPE_INT) {
 		uint32_t v = array_get_int(a,i);
 		return (float)v;
@@ -639,10 +663,14 @@
 }
 
 /* get a string value from an array */
 char* array_get_string(array_t *a, int i)
 {
+
+	if(i < 0)
+	    return NULL;
+	
 	if (a->type == ARRAY_TYPE_FLOAT) {
 		float v = array_get_float(a,i);
 		char sv[20];
 		sprintf(sv,"%f",v);
 		return strdup(sv);
@@ -650,31 +678,35 @@
 		uint32_t v = array_get_int(a,i);
 		char sv[20];
 		sprintf(sv,"%u",v);
 		return strdup(sv);
 	}else if (a->type == ARRAY_TYPE_STRING) {
-		if (a->length <= i)
+	    if ((int) a->length <= i)
 			return NULL;
 		return ((char**)(a->data))[i];
 	}
 	return NULL;
 }
 
 /* get a pointer from an array */
 void *array_get_ptr(array_t *a, int i)
 {
-	if (a->type == ARRAY_TYPE_PTR && a->length > i) {
+
+	if(i < 0)
+	    return NULL;
+	
+	if (a->type == ARRAY_TYPE_PTR && (int) a->length > i) {
 		return ((char**)(a->data))[i];
 	}
 	return NULL;
 }
 
 /* find the index of an int value in an array */
 int array_find_int(array_t *a, uint32_t v)
 {
 	if (a->type == ARRAY_TYPE_INT) {
-		int i;
+		uint32_t i;
 		uint32_t *p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (p[i] == v)
 				return i;
 		}
@@ -684,11 +716,11 @@
 
 /* find the index of a float value in an array */
 int array_find_float(array_t *a, float v)
 {
 	if (a->type == ARRAY_TYPE_FLOAT) {
-		int i;
+		uint32_t i;
 		float *p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (p[i] == v)
 				return i;
 		}
@@ -698,11 +730,11 @@
 
 /* find the index of a string value in an array */
 int array_find_string(array_t *a, char* v)
 {
 	if (a->type == ARRAY_TYPE_STRING) {
-		int i;
+		uint32_t i;
 		char** p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (!strcmp(p[i],v))
 				return i;
 		}
@@ -712,11 +744,11 @@
 
 /* find the index of a pointer in an array */
 int array_find_ptr(array_t *a, void *v)
 {
 	if (a->type == ARRAY_TYPE_PTR) {
-		int i;
+		uint32_t i;
 		uint8_t* cv = v;
 		uint8_t** p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (p[i] == cv)
 				return i;
@@ -727,11 +759,11 @@
 
 /* remove a string value from an array */
 int array_remove_string(array_t *a, char* v)
 {
 	if (a->type == ARRAY_TYPE_STRING) {
-		int i;
+		uint32_t i;
 		char** p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (!strcmp(p[i],v)) {
 				free(p[i]);
 				break;
@@ -749,22 +781,19 @@
 /* split a string into an array, at a separator character */
 /* TODO: if strings is non-zero, then don't split within "" or '' */
 /* TODO: utf8 support */
 array_t *array_split(char* str, char* s, int strings)
 {
+	
+	if (!str || !s)
+	    return NULL;
+
 	char buff[1024];
 	int i;
 	int o = 0;
-	int l;
-	array_t *r;
-
-	if (!str)
-		return NULL;
-
-	r = array_create(ARRAY_TYPE_STRING);
-
-	l = strlen(s);
+	array_t* const r = array_create(ARRAY_TYPE_STRING);
+	const int l = strlen(s);
 
 	for (i=0; str[i]; i++) {
 		if (!strncmp(str+i,s,l)) {
 			buff[o] = 0;
 			array_push_string(r,buff);
@@ -781,27 +810,30 @@
 }
 
 /* join an array into a string, using a glue character */
 char* array_join(array_t *a, char* glue, int start)
 {
+	const uint32_t ustart = start < 0 ? 0 : start;	
 	char* str = NULL;
 	int l = 0;
+	
 	if (!glue)
 		glue = " ";
+	
 	if (a->type == ARRAY_TYPE_STRING) {
-		int i;
-		int gl = strlen(glue);
-		for (i=start; i<a->length; i++) {
-			l += strlen(((char**)(a->data))[i])+gl;
+		uint32_t i;
+		const int gl = strlen(glue);
+		for (i=ustart; i<a->length; i++) {
+		    l += strlen(((char**)(a->data))[i]) + gl;
 		}
 		if (l) {
-			str = malloc(l+1);
+			str = malloc(l + 1);
 			str[0] = 0;
-			for (i=start; i<a->length; i++) {
-				if (i > start)
-					strcat(str,glue);
-				strcat(str,((char**)(a->data))[i]);
+			for (i=ustart; i<a->length; i++) {
+			    if (i > ustart)
+				strcat(str,glue);
+			    strcat(str,((char**)(a->data))[i]);
 			}
 		}
 	}
 
 	return str;
diff -rU5 voxelands-v1709.00old/src/auth.c voxelands-v1709.00good/src/auth.c
--- voxelands-v1709.00old/src/auth.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/auth.c	2024-09-22 18:41:01.677655749 +0200
@@ -82,11 +82,11 @@
 
 	return r;
 }
 
 /* convert a string to privs */
-uint64_t auth_str2privs(char* str)
+uint64_t auth_str2privs(const char* str)
 {
 	uint64_t privs = 0;
 	char buff[256];
 	int i;
 	int j;
@@ -118,11 +118,11 @@
 
 	return privs;
 }
 
 /* init auth system for the given file */
-int auth_init(char* file)
+int auth_init(const char* file)
 {
 	char* path;
 	if (!auth.mutex) {
 		auth.mutex = mutex_create();
 		if (!auth.mutex)
diff -rU5 voxelands-v1709.00old/src/auth.h voxelands-v1709.00good/src/auth.h
--- voxelands-v1709.00old/src/auth.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/auth.h	2024-09-22 18:41:01.677655749 +0200
@@ -31,12 +31,12 @@
 } authdata_t;
 #endif
 
 /* defined in auth.c */
 int auth_privs2str(uint64_t privs, char* buff, int size);
-uint64_t auth_str2privs(char* str);
-int auth_init(char* file);
+uint64_t auth_str2privs(const char* str);
+int auth_init(const char* file);
 void auth_exit(void);
 void auth_load(void);
 void auth_save(void);
 int auth_exists(char* name);
 void auth_set(char* name, authdata_t data);
diff -rU5 voxelands-v1709.00old/src/ban.c voxelands-v1709.00good/src/ban.c
--- voxelands-v1709.00old/src/ban.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/ban.c	2024-09-22 18:41:01.677655749 +0200
@@ -41,11 +41,11 @@
 	NULL,
 	0
 };
 
 /* init ban system for the given file */
-int ban_init(char* file)
+int ban_init(const char* file)
 {
 	char* path;
 	if (!ban.mutex) {
 		ban.mutex = mutex_create();
 		if (!ban.mutex)
diff -rU5 voxelands-v1709.00old/src/ban.h voxelands-v1709.00good/src/ban.h
--- voxelands-v1709.00old/src/ban.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/ban.h	2024-09-22 18:41:01.678655751 +0200
@@ -4,11 +4,11 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* defined in ban.c */
-int ban_init(char* file);
+int ban_init(const char* file);
 void ban_exit(void);
 void ban_load(void);
 void ban_save(void);
 int ban_ipbanned(char* ip);
 int ban_description(char* ip_or_name, char* buff, int size);
diff -rU5 voxelands-v1709.00old/src/bridge_temp.cpp voxelands-v1709.00good/src/bridge_temp.cpp
--- voxelands-v1709.00old/src/bridge_temp.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/bridge_temp.cpp	2024-09-22 18:41:01.678655751 +0200
@@ -124,11 +124,11 @@
 		Address address = server->getPeerAddress(player->peer_id);
 		std::string ip_string = address.serializeString();
 		if (ip_string.size() >= (uint32_t)size)
 			return -1;
 		strcpy(buff,ip_string.c_str());
-	} catch(con::PeerNotFoundException) {
+	} catch(con::PeerNotFoundException&) {
 		std::string ip_string = ((ServerRemotePlayer*)player)->getAddress();
 		if (ip_string == "")
 			return -1;
 		if (ip_string.size() >= (uint32_t)size)
 			return -1;
@@ -248,13 +248,13 @@
 	SHA1 sha1;
 	sha1.addBytes(str, l);
 	return sha1.getDigest();
 }
 
-std::string bridge_config_get(char* name)
+std::string bridge_config_get(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (!v)
 		return "";
 
 	return std::string(v);
 }
diff -rU5 voxelands-v1709.00old/src/character_creator.cpp voxelands-v1709.00good/src/character_creator.cpp
--- voxelands-v1709.00old/src/character_creator.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/character_creator.cpp	2024-09-22 18:41:01.678655751 +0200
@@ -118,11 +118,11 @@
 	m_cameranode->setPosition(v3f(20,0,0));
 	// *100.0 helps in large map coordinates
 	m_cameranode->setTarget(v3f(0,0,0));
 
 	// get a unique mesh so that the player model has it's own lighting
-	scene::IAnimatedMesh* mesh = createModelMesh(smgr,"character.b3d",true);
+	scene::IAnimatedMesh* const mesh = createModelMesh(smgr,"character.b3d",true);
 	if (!mesh)
 		return;
 
 	m_model = smgr->addAnimatedMeshSceneNode(mesh,smgr->getRootSceneNode());
 
@@ -809,11 +809,11 @@
 //M:10:10:fair:blue:brown:medium:normal:green:blue:leather
 void GUICharDefMenu::fetchPlayerSkin()
 {
 	char buff[1024];
 	char buf[256];
-	char* v;
+	const char* v;
 	std::string chardef = std::string(PLAYER_DEFAULT_CHARDEF);
 	v = config_get("client.character");
 	if (v)
 		chardef = v;
 	Strfnd f(chardef);
diff -rU5 voxelands-v1709.00old/src/client.cpp voxelands-v1709.00good/src/client.cpp
--- voxelands-v1709.00old/src/client.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/client.cpp	2024-10-27 17:09:08.475283733 +0100
@@ -66,23 +66,23 @@
 
 /*
 	MeshUpdateQueue
 */
 
-MeshUpdateQueue::MeshUpdateQueue()
+MeshUpdateQueue::MeshUpdateQueue() : m_queue(NULL),m_mutex()
 {
-	m_queue = NULL;
 	m_mutex.Init();
 }
 
 MeshUpdateQueue::~MeshUpdateQueue()
 {
 	QueuedMeshUpdate *i;
 	JMutexAutoLock lock(m_mutex);
 
-	while (m_queue != NULL) {
-		i = (QueuedMeshUpdate*)list_pull(&m_queue);
+	while (m_queue != NULL)
+	{
+		i = (QueuedMeshUpdate*) list_pull(&m_queue);
 		delete i;
 	}
 }
 
 /*
@@ -99,16 +99,22 @@
 	/*
 		Find if block is already in queue.
 		If it is, update the data and quit.
 	*/
 	QueuedMeshUpdate* q = m_queue;
-	while (q) {
-		if (q->p == p) {
-			if (q->data && data->m_refresh_only) {
-				q->data->m_daynight_ratio = data->m_daynight_ratio;
+	while (q)
+	{
+		if (q->p == p)
+		{
+			if (q->data && data->m_refresh_only)
+			{
+				q->data->m_daynight_ratio =
+				    data->m_daynight_ratio;
 				delete data;
-			}else{
+			}
+			else
+			{
 				if (q->data)
 					delete q->data;
 				q->data = data;
 			}
 			if (ack_block_to_server)
@@ -143,72 +149,84 @@
 */
 
 void * MeshUpdateThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("MeshUpdateThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
-	while (getRun()) {
-		QueuedMeshUpdate *q = m_queue_in.pop();
-		if (q == NULL) {
-			sleep_ms(3);
-			continue;
-		}
-
-		ScopeProfiler sp(g_profiler, "Client: Mesh making");
-
-		if (q->data && q->data->m_refresh_only) {
-			MapBlock *block = m_env->getMap().getBlockNoCreateNoEx(q->p);
-			if (block && block->mesh) {
-				{
-					JMutexAutoLock lock(block->mesh_mutex);
-					block->mesh->refresh(q->data->m_daynight_ratio);
-				}
-			}
-		}else{
-			MapBlock *block = m_env->getMap().getBlockNoCreateNoEx(q->p);
-			if (block && block->mesh) {
-				block->mesh->generate(q->data, m_camera_offset, &block->mesh_mutex);
-				if (q->ack_block_to_server) {
-					MeshUpdateResult r;
-					r.p = q->p;
-					r.mesh = NULL;
-					r.ack_block_to_server = true;
-					m_queue_out.push_back(r);
-				}
-			}else if (block) {
-				MapBlockMesh *mesh_new = new MapBlockMesh(q->data, m_camera_offset);
-				MeshUpdateResult r;
-				r.p = q->p;
-				r.mesh = mesh_new;
-				r.ack_block_to_server = q->ack_block_to_server;
-
-				m_queue_out.push_back(r);
-			}
+	while (getRun())
+	{
+	    QueuedMeshUpdate* const q = m_queue_in.pop();
+	    if (q == NULL)
+	    {
+		sleep_ms(3);
+		continue;
+	    }
+
+	    ScopeProfiler sp(g_profiler, "Client: Mesh making");
+	    MapBlock* const block =
+		m_env->getMap().getBlockNoCreateNoEx(q->p);
+
+	    if (q->data && q->data->m_refresh_only)
+	    {
+		if (block)
+		{
+		    JMutexAutoLock lock(block->mesh_mutex);
+		    if(block->mesh)
+			block->mesh->refresh(q->data->m_daynight_ratio);
+		}
+	    }
+	    else if (block)
+	    {
+		if(block->mesh)
+		{
+		    block->mesh->generate(q->data, m_camera_offset,
+				    &block->mesh_mutex);
+		    if (q->ack_block_to_server)
+		    {
+			MeshUpdateResult r;
+			r.p = q->p;
+			r.mesh = NULL;
+			r.ack_block_to_server = true;
+			m_queue_out.push_back(r);
+		    }
 		}
-
-		delete q;
+		else
+		{
+		    MapBlockMesh* const mesh_new =
+			new MapBlockMesh(q->data, m_camera_offset);
+		    MeshUpdateResult r;
+		    r.p = q->p;
+		    r.mesh = mesh_new;
+		    r.ack_block_to_server = q->ack_block_to_server;
+		    m_queue_out.push_back(r);
+		}
+	    }
+
+	    if(block)
+		block->ResetCurrent();
+	    delete q;
 	}
 
 	END_DEBUG_EXCEPTION_HANDLER(errorstream)
 
 	return NULL;
 }
 
-Client::Client(
-		IrrlichtDevice *device,
-		std::string password,
-		MapDrawControl &control):
+Client::Client(IrrlichtDevice* const device,
+		const std::string password,
+		MapDrawControl& control) :
 	m_mesh_update_thread(),
 	m_env(
 		this,
-		new ClientMap(this, control,
+		new ClientMap(this,control,
 			device->getSceneManager()->getRootSceneNode(),
 			device->getSceneManager(), 666),
 		device->getSceneManager()
 	),
 	m_server_damage(false),
@@ -250,13 +268,13 @@
 		Add local player
 	*/
 	{
 		//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
 
-		Player *player = new LocalPlayer();
+		Player* const player = new LocalPlayer();
 
-		char* v = config_get("client.name");
+		const char* v = config_get("client.name");
 		if (v) {
 			player->updateName(v);
 		}else{
 			player->updateName(porting::getUser().c_str());
 		}
@@ -371,11 +389,11 @@
 		if (counter <= 0.0) {
 			counter = 2.0;
 
 			//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
 
-			Player *myplayer = m_env.getLocalPlayer();
+			Player* const myplayer = m_env.getLocalPlayer();
 			assert(myplayer != NULL);
 
 			// Send TOSERVER_INIT
 			// [0] u16 TOSERVER_INIT
 			// [2] u8 SER_FMT_VER_HIGHEST
@@ -473,38 +491,43 @@
 	{
 		// 0ms
 		//JMutexAutoLock lock(m_env_mutex); //bulk comment-out
 
 		// Control local player (0ms)
-		LocalPlayer *player = m_env.getLocalPlayer();
+		LocalPlayer* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		player->applyControl(dtime);
 
 		//TimeTaker envtimer("env step", m_device);
 		// Step environment
 		m_env.step(dtime);
 
 		/*
 			Get events
 		*/
-		for (;;) {
+		for (;;)
+		{
 			ClientEnvEvent event = m_env.getClientEvent();
-			if (event.type == CEE_NONE) {
+			if (event.type == CEE_NONE)
 				break;
-			}else if (event.type == CEE_PLAYER_DAMAGE && getServerDamage()) {
+			else if (event.type == CEE_PLAYER_DAMAGE && getServerDamage())
+			{
 				if (m_ignore_damage_timer <= 0) {
 					s8 damage = event.player_damage.amount;
 					sendDamage(damage,0,0);
 
 					// Add to ClientEvent queue
 					ClientEvent event;
 					event.type = CE_PLAYER_DAMAGE;
 					event.player_damage.amount = damage;
 					m_client_event_queue.push_back(event);
 				}
-			}else if (event.type == CEE_PLAYER_SUFFOCATE && getServerSuffocation()) {
-				if (m_ignore_damage_timer <= 0) {
+			}
+			else if (event.type == CEE_PLAYER_SUFFOCATE && getServerSuffocation())
+			{
+				if (m_ignore_damage_timer <= 0)
+				{
 					s8 damage = event.player_damage.amount;
 					sendDamage(0,damage,0);
 
 					// Add to ClientEvent queue
 					ClientEvent event;
@@ -516,12 +539,15 @@
 						player->addDamage(PLAYER_HEAD,DAMAGE_AIR,damage);
 					}
 					event.player_damage.amount = damage;
 					m_client_event_queue.push_back(event);
 				}
-			}else if (event.type == CEE_PLAYER_HUNGER && getServerHunger()) {
-				if (m_ignore_damage_timer <= 0) {
+			}
+			else if (event.type == CEE_PLAYER_HUNGER && getServerHunger())
+			{
+				if (m_ignore_damage_timer <= 0)
+				{
 					s8 damage = event.player_damage.amount;
 					sendDamage(0,0,damage);
 
 					// Add to ClientEvent queue
 					ClientEvent event;
@@ -533,23 +559,24 @@
 						player->addDamage(PLAYER_TORSO,DAMAGE_HUNGER,damage);
 					}
 					event.player_damage.amount = damage;
 					m_client_event_queue.push_back(event);
 				}
-			}else if (event.type == CEE_PLAYER_WEARCLOTHES && getServerDamage()) {
-				sendClothesWear(event.player_wear.amount);
 			}
+			else if (event.type == CEE_PLAYER_WEARCLOTHES && getServerDamage())
+				sendClothesWear(event.player_wear.amount);
 		}
 	}
 
 	/*
 		Print some info
 	*/
 	{
-		float &counter = m_avg_rtt_timer;
+		float& counter = m_avg_rtt_timer;
 		counter += dtime;
-		if (counter >= 10) {
+		if (counter >= 10)
+		{
 			counter = 0.0;
 			//JMutexAutoLock lock(m_con_mutex); //bulk comment-out
 			// connectedAndInitialized() is true, peer exists.
 			float avg_rtt = m_con.GetPeerAvgRTT(PEER_ID_SERVER);
 			infostream<<"Client: avg_rtt="<<avg_rtt<<std::endl;
@@ -558,13 +585,14 @@
 
 	/*
 		Send player position to server
 	*/
 	{
-		float &counter = m_playerpos_send_timer;
+		float& counter = m_playerpos_send_timer;
 		counter += dtime;
-		if (counter >= 0.2) {
+		if (counter >= 0.2)
+		{
 			counter = 0.0;
 			sendPlayerPos();
 		}
 	}
 
@@ -579,63 +607,71 @@
 
 		/*infostream<<"Mesh update result queue size is "
 				<<m_mesh_update_thread.m_queue_out.size()
 				<<std::endl;*/
 
-		while (m_mesh_update_thread.m_queue_out.size() > 0) {
-			MeshUpdateResult r = m_mesh_update_thread.m_queue_out.pop_front();
-			MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(r.p);
-			if (block) {
-				if (r.mesh != NULL) {
-					JMutexAutoLock lock(block->mesh_mutex);
-
-					MapBlockMesh *mesh_old = block->mesh;
-					block->mesh = r.mesh;
-					block->setMeshExpired(false);
-
-					if (mesh_old != NULL)
-						delete mesh_old;
-				}else{
-					block->setMeshExpired(false);
-				}
-			}
-			if (r.ack_block_to_server) {
-				/*infostream<<"Client: ACK block ("<<r.p.X<<","<<r.p.Y
-						<<","<<r.p.Z<<")"<<std::endl;*/
-				/*
-					Acknowledge block
-				*/
-				/*
-					[0] u16 command
-					[2] u8 count
-					[3] v3s16 pos_0
-					[3+6] v3s16 pos_1
-					...
-				*/
-				u32 replysize = 2+1+6;
-				SharedBuffer<u8> reply(replysize);
-				writeU16(&reply[0], TOSERVER_GOTBLOCKS);
-				reply[2] = 1;
-				writeV3S16(&reply[3], r.p);
-				// Send as reliable
-				m_con.Send(PEER_ID_SERVER, 1, reply, true);
-			}
+	    while (m_mesh_update_thread.m_queue_out.size() > 0)
+	    {
+		MeshUpdateResult r = m_mesh_update_thread.m_queue_out.pop_front();
+		MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(r.p);
+		if (block)
+		{
+		    if (r.mesh != NULL)
+		    {
+			JMutexAutoLock lock(block->mesh_mutex);
+			MapBlockMesh* const mesh_old = block->mesh;
+					
+			block->mesh = r.mesh;
+			block->setMeshExpired(false);
+
+			if (mesh_old != NULL)
+			    delete mesh_old;
+		    }
+		    else
+			block->setMeshExpired(false);
+		    
+		    block->ResetCurrent();
+		}
+		
+		if (r.ack_block_to_server)
+		{
+		/*infostream<<"Client: ACK block ("<<r.p.X<<","<<r.p.Y
+		  <<","<<r.p.Z<<")"<<std::endl;*/
+		/*
+		  Acknowledge block
+		*/
+		/*
+		  [0] u16 command
+		  [2] u8 count
+		  [3] v3s16 pos_0
+		  [3+6] v3s16 pos_1
+		  ...
+		*/
+		    const u32 replysize = 2+1+6;
+		    SharedBuffer<u8> reply(replysize);
+				
+		    writeU16(&reply[0], TOSERVER_GOTBLOCKS);
+		    reply[2] = 1;
+		    writeV3S16(&reply[3], r.p);
+		// Send as reliable
+		    m_con.Send(PEER_ID_SERVER, 1, reply, true);
 		}
+	    }
 	}
 }
 
 // Virtual methods from con::PeerHandler
 void Client::peerAdded(con::Peer *peer)
 {
-	infostream<<"Client::peerAdded(): peer->id="
-			<<peer->id<<std::endl;
+	infostream << "Client::peerAdded(): peer->id="
+			<< peer->id << std::endl;
 }
 void Client::deletingPeer(con::Peer *peer, bool timeout)
 {
-	infostream<<"Client::deletingPeer(): "
+	infostream << "Client::deletingPeer(): "
 			"Server Peer is getting deleted "
-			<<"(timeout="<<timeout<<")"<<std::endl;
+			<< "(timeout=" << timeout << ")" << std::endl;
 }
 
 void Client::ReceiveAll()
 {
 	DSTACK(__FUNCTION_NAME);
@@ -648,13 +684,13 @@
 		{
 			break;
 		}
 		catch(con::InvalidIncomingDataException &e)
 		{
-			infostream<<"Client::ReceiveAll(): "
+			infostream << "Client::ReceiveAll(): "
 					"InvalidIncomingDataException: what()="
-					<<e.what()<<std::endl;
+					<< e.what() << std::endl;
 		}
 	}
 }
 
 void Client::Receive()
@@ -732,11 +768,11 @@
 
 		{ //envlock
 			//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
 
 			// Set player position
-			Player *player = m_env.getLocalPlayer();
+			Player* const player = m_env.getLocalPlayer();
 			assert(player != NULL);
 			player->setPosition(playerpos_f);
 		}
 
 		if (datasize >= 2+1+6+8) {
@@ -752,11 +788,11 @@
 			infostream<<"Client: received map type: "<<m_map_type<<std::endl;
 		}
 
 		{
 			// Reply to server
-			char *v;
+			const char *v;
 			std::string chardef = std::string(PLAYER_DEFAULT_CHARDEF);
 			v = config_get("client.character");
 			if (v)
 				chardef = v;
 
@@ -852,38 +888,35 @@
 				<<p.X<<","<<p.Y<<","<<p.Z<<")"<<std::endl;*/
 
 		std::string datastring((char*)&data[8], datasize-8);
 		std::istringstream istr(datastring, std::ios_base::binary);
 
-		MapSector *sector;
-		MapBlock *block;
-
-		v2s16 p2d(p.X, p.Z);
-		sector = m_env.getMap().emergeSector(p2d);
+		const v2s16 p2d(p.X, p.Z);
+		MapSector* const sector = m_env.getMap().emergeSector(p2d);
 
 		if (sector->getPos() != p2d)
-			return;
+		    return;
 
 		//TimeTaker timer("MapBlock deSerialize");
 		// 0ms
 
-		block = sector->getBlockNoCreateNoEx(p.Y);
-		if (block) {
-			/*
-				Update an existing block
-			*/
-			//infostream<<"Updating"<<std::endl;
-			block->deSerialize(istr, ser_version);
-		}else{
-			/*
-				Create a new block
-			*/
-			//infostream<<"Creating new"<<std::endl;
-			block = new MapBlock(&m_env.getMap(), p);
-			block->deSerialize(istr, ser_version);
-			sector->insertBlock(block);
-
+		MapBlock* block = sector->getBlockNoCreateNoEx(p.Y);
+		if (block)
+		/*
+		  Update an existing block
+		*/
+		//infostream<<"Updating"<<std::endl;
+		    block->deSerialize(istr, ser_version);
+		else
+		{
+		/*
+		  Create a new block
+		*/
+		//infostream<<"Creating new"<<std::endl;
+		    block = new MapBlock(&m_env.getMap(), p);
+		    block->deSerialize(istr, ser_version);
+		    sector->insertBlock(block);
 		}
 
 		/*
 			Update Mesh of this block and blocks at x-, y- and z-.
 			Environment should not be locked as it interlocks with the
@@ -914,11 +947,12 @@
 	case TOCLIENT_PLAYERDATA:
 	{
 		u16 our_peer_id = m_con.GetPeerID();
 
 		// Cancel if we don't have a peer id
-		if (our_peer_id == PEER_ID_INEXISTENT) {
+		if (our_peer_id == PEER_ID_INEXISTENT)
+		{
 			infostream<<"TOCLIENT_PLAYERINFO cancelled: we have no peer id"<<std::endl;
 			return;
 		}
 
 		{
@@ -931,30 +965,31 @@
 			u16 field_count = readU16(is);
 
 			// peer_ids
 			array_t players_alive;
 			array_init(&players_alive,ARRAY_TYPE_INT);
-			for (u16 i=0; i<player_count; i++) {
+			for (u16 i=0; i<player_count; i++)
+			{
 				u16 peer_id = readU16(is);
 
 				array_push_int(&players_alive,peer_id);
 
 				is.read(pname,PLAYERNAME_SIZE);
 				pname[PLAYERNAME_SIZE-1] = '\0';
 				chardef = deSerializeString(is);
-				for (u16 j=1; j<field_count; j++) {
+				for (u16 j=1; j<field_count; j++)
 					std::string dump = deSerializeString(is);
-				}
 
 				// Don't update the info of the local player
 				if (peer_id == our_peer_id)
 					continue;
 
-				Player *player = m_env.getPlayer(peer_id);
+				Player* player = m_env.getPlayer(peer_id);
 
 				// Create a player if it doesn't exist
-				if (player == NULL) {
+				if (player == NULL)
+				{
 					player = new RemotePlayer(
 						m_device->getSceneManager()->getRootSceneNode(),
 						m_device,
 						-1
 					);
@@ -969,14 +1004,15 @@
 
 			/*
 				Remove those players from the environment that
 				weren't listed by the server.
 			*/
-			array_t *players = m_env.getPlayers();
+			array_t* const players = m_env.getPlayers();
 			Player *player;
 			uint32_t i;
-			for (i=0; i<players->length; i++) {
+			for (i=0; i<players->length; i++)
+			{
 				player = (Player*)array_get_ptr(players,i);
 				if (!player)
 					continue;
 				// Ignore local player
 				if (player->isLocal())
@@ -996,11 +1032,11 @@
 	break;
 	case TOCLIENT_PLAYERSTATE:
 	{
 		std::string datastring((char*)&data[2], datasize-2);
 		std::istringstream is(datastring, std::ios_base::binary);
-		LocalPlayer *player = m_env.getLocalPlayer();
+		LocalPlayer* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		u8 hp = readU8(is);
 		u8 air = readU8(is);
 		u8 hunger = readU8(is);
 		player->dirt = readU8(is);
@@ -1008,11 +1044,12 @@
 		player->blood = readU8(is);
 		u16 energy_effect = readU16(is);
 		if (energy_effect > player->energy_effectf)
 			player->energy_effectf = energy_effect;
 		player->cold_effectf += readU16(is);
-		if (m_server_damage) {
+		if (m_server_damage)
+		{
 			if (!player->health)
 				player->setEnergy(hp);
 			player->health = hp;
 		}
 		if (m_server_suffocation)
@@ -1027,11 +1064,11 @@
 			return;
 		{
 			std::string datastring((char*)&data[2], datasize-2);
 			std::istringstream is(datastring, std::ios_base::binary);
 
-			Player *player = m_env.getLocalPlayer();
+			Player* const player = m_env.getLocalPlayer();
 			assert(player != NULL);
 
 			player->inventory.deSerialize(is);
 
 			m_inventory_updated = true;
@@ -1044,21 +1081,23 @@
 			return;
 		{
 			std::string datastring((char*)&data[2], datasize-2);
 			std::istringstream is(datastring, std::ios_base::binary);
 
-			Player *player = m_env.getLocalPlayer();
+			Player* const player = m_env.getLocalPlayer();
 			assert(player != NULL);
 
 			u16 list_count = readU16(is);
-			for (int i=0; i<list_count; i++) {
+			for (int i=0; i<list_count; i++)
+			{
 				std::string name = deSerializeString(is);
 				u16 slots = readU16(is);
 				InventoryList *l = player->inventory.getList(name);
 				if (!l)
 					return;
-				for (int k=0; k<slots; k++) {
+				for (int k=0; k<slots; k++)
+				{
 					u16 index = readU16(is);
 					u16 type = readU16(is);
 					u16 count = readU16(is);
 					u16 data = readU16(is);
 					l->updateItem(index,type,count,data);
@@ -1079,20 +1118,21 @@
 			Read players
 		*/
 
 		u16 playercount = readU16(is);
 
-		for (u16 i=0; i<playercount; i++) {
+		for (u16 i=0; i<playercount; i++)
+		{
 			u16 peer_id = readU16(is);
 			v3f position = readV3F1000(is);
 			v3f speed = readV3F1000(is);
 			f32 pitch = readF1000(is);
 			f32 yaw = readF1000(is);
 			u8 anim_id = readU8(is);
 			content_t pointed = readU16(is);
 
-			Player *player = m_env.getPlayer(peer_id);
+			Player* const player = m_env.getPlayer(peer_id);
 
 			// Skip if player doesn't exist
 			if (player == NULL)
 				continue;
 
@@ -1122,11 +1162,12 @@
 		*/
 
 		is.read((char*)buf, 2);
 		u16 playercount = readU16(buf);
 
-		for (u16 i=0; i<playercount; i++) {
+		for (u16 i=0; i<playercount; i++)
+		{
 			is.read((char*)buf, 2);
 			u16 peer_id = readU16(buf);
 			is.read((char*)buf, 12);
 			v3s32 p_i = readV3S32(buf);
 			is.read((char*)buf, 12);
@@ -1134,11 +1175,11 @@
 			is.read((char*)buf, 4);
 			s32 pitch_i = readS32(buf);
 			is.read((char*)buf, 4);
 			s32 yaw_i = readS32(buf);
 
-			Player *player = m_env.getPlayer(peer_id);
+			Player* const player = m_env.getPlayer(peer_id);
 
 			// Skip if player doesn't exist
 			if (player == NULL)
 				continue;
 
@@ -1161,12 +1202,13 @@
 			Read block objects
 			NOTE: Deprecated stuff
 		*/
 
 		// Read active block count
-		u16 blockcount = readU16(is);
-		if (blockcount != 0) {
+		const u16 blockcount = readU16(is);
+		if (blockcount != 0)
+		{
 			infostream<<"TOCLIENT_OBJECTDATA: blockcount != 0 not supported"<<std::endl;
 			return;
 		}
 	}
 	break;
@@ -1177,26 +1219,30 @@
 
 		u32 time = 0;
 		u16 time_of_day = readU16(&data[2]);
 		time_of_day = time_of_day % 24000;
 		float time_speed = 0;
-		if (datasize >= 2 + 2 + 4 + 4) {
+		if (datasize >= 2 + 2 + 4 + 4)
+		{
 			time = readU32(&data[4]);
 			time_speed = readF1000(&data[8]);
-		}else{
+		}
+		else
+		{
 			// Old message; try to approximate speed of time by ourselves
 			float time_of_day_f = (float)time_of_day / 24000.0;
 			float tod_diff_f = 0;
-			if (time_of_day_f < 0.2 && m_last_time_of_day_f > 0.8) {
+			if (time_of_day_f < 0.2 && m_last_time_of_day_f > 0.8)
 				tod_diff_f = time_of_day_f - m_last_time_of_day_f + 1.0;
-			}else{
+			else
 				tod_diff_f = time_of_day_f - m_last_time_of_day_f;
-			}
+
 			m_last_time_of_day_f = time_of_day_f;
 			float time_diff = m_time_of_day_update_timer;
 			m_time_of_day_update_timer = 0;
-			if (m_time_of_day_set) {
+			if (m_time_of_day_set)
+			{
 				time_speed = 3600.0*24.0 * tod_diff_f / time_diff;
 				infostream<<"Client: Measured time_of_day speed (old format): "
 				<<time_speed<<" tod_diff_f="<<tod_diff_f
 				<<" time_diff="<<time_diff<<std::endl;
 			}
@@ -1227,11 +1273,12 @@
 		// Read stuff
 		is.read((char*)buf, 2);
 		u16 len = readU16(buf);
 
 		std::wstring message;
-		for (u16 i=0; i<len; i++) {
+		for (u16 i=0; i<len; i++)
+		{
 			is.read((char*)buf, 2);
 			message += (wchar_t)readU16(buf);
 		}
 
 		/* because I can't remember which random stream prints to stdout */
@@ -1266,21 +1313,23 @@
 		// Read stuff
 
 		// Read removed objects
 		is.read(buf, 2);
 		u16 removed_count = readU16((u8*)buf);
-		for (u16 i=0; i<removed_count; i++) {
+		for (u16 i=0; i<removed_count; i++)
+		{
 			is.read(buf, 2);
 			u16 id = readU16((u8*)buf);
 			// Remove it
 			m_env.removeActiveObject(id);
 		}
 
 		// Read added objects
 		is.read(buf, 2);
 		u16 added_count = readU16((u8*)buf);
-		for (u16 i=0; i<added_count; i++) {
+		for (u16 i=0; i<added_count; i++)
+		{
 			is.read(buf, 2);
 			u16 id = readU16((u8*)buf);
 			is.read(buf, 1);
 			u8 type = readU8((u8*)buf);
 			std::string data = deSerializeLongString(is);
@@ -1304,21 +1353,23 @@
 		// Get all data except the command number
 		std::string datastring((char*)&data[2], datasize-2);
 		// Throw them in an istringstream
 		std::istringstream is(datastring, std::ios_base::binary);
 
-		while (is.eof() == false) {
+		while (is.eof() == false)
+		{
 			// Read stuff
 			is.read(buf, 2);
 			u16 id = readU16((u8*)buf);
 			if (is.eof())
 				break;
 			is.read(buf, 2);
 			u16 message_size = readU16((u8*)buf);
 			std::string message;
 			message.reserve(message_size);
-			for (u16 i=0; i<message_size; i++) {
+			for (u16 i=0; i<message_size; i++)
+			{
 				is.read(buf, 1);
 				message.append(buf, 1);
 			}
 			// Pass on to the environment
 			m_env.processActiveObjectMessage(id, message);
@@ -1327,11 +1378,11 @@
 	break;
 	case TOCLIENT_MOVE_PLAYER:
 	{
 		std::string datastring((char*)&data[2], datasize-2);
 		std::istringstream is(datastring, std::ios_base::binary);
-		Player *player = m_env.getLocalPlayer();
+		Player* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		v3f pos = readV3F1000(is);
 		f32 pitch = readF1000(is);
 		f32 yaw = readF1000(is);
 		player->setPosition(pos);
@@ -1368,31 +1419,36 @@
 
 		u16 count = readU16(is);
 		u16 icount = readU16(is);
 		u16 itm;
 
-		for (u16 i = 0; i < count; ++i) {
+		for (u16 i = 0; i < count; ++i)
+		{
 			u16 peer_id = readU16(is);
-			Player *player = m_env.getPlayer(peer_id);
+			Player* const player = m_env.getPlayer(peer_id);
 
-			if (player == NULL) {
-				for (int j=0; j<icount; j++) {
+			if (player == NULL)
+			{
+				for (int j=0; j<icount; j++)
 					itm = readU16(is);
-				}
 				infostream<<"Client: ignoring player items "
 					<< " for non-existing peer id " << peer_id
 					<< std::endl;
 				continue;
-			}else if (player->isLocal()) {
-				for (int j=0; j<icount; j++) {
+			}
+			else if (player->isLocal())
+			{
+				for (int j=0; j<icount; j++)
 					itm = readU16(is);
-				}
 				infostream<<"Client: ignoring player items "
 					<< " for local player" << std::endl;
 				continue;
-			}else{
-				for (int j=0; j<icount; j++) {
+			}
+			else
+			{
+				for (int j=0; j<icount; j++)
+				{
 					itm = readU16(is);
 					InventoryList *inv = NULL;
 					switch (j) {
 					case 0:
 						inv = player->inventory.getList("main");
@@ -1422,43 +1478,47 @@
 					if (inv == NULL)
 						continue;
 					if (itm == CONTENT_IGNORE) {
 						inv->deleteItem(0);
 					}else{
-						InventoryItem *item = inv->changeItem(0, InventoryItem::create(itm,1));
+						InventoryItem* const item = inv->changeItem(0, InventoryItem::create(itm,1));
 						if (item)
 							delete item;
 					}
 				}
 				// for 1409 servers, this stops players appearing naked
-				if (icount == 5) {
+				if (icount == 5)
+				{
 					{
-						InventoryList *inv = player->inventory.getList("shirt");
-						if (!inv->getItem(0)) {
-							InventoryItem *item = inv->changeItem(
+						InventoryList* const inv = player->inventory.getList("shirt");
+						if (!inv->getItem(0))
+						{
+							InventoryItem* const item = inv->changeItem(
 								0,
 								InventoryItem::create(CONTENT_CLOTHESITEM_COTTON_TSHIRT_GREEN,1)
 							);
 							if (item)
 								delete item;
 						}
 					}
 					{
-						InventoryList *inv = player->inventory.getList("pants");
-						if (!inv->getItem(0)) {
-							InventoryItem *item = inv->changeItem(
+						InventoryList* const inv = player->inventory.getList("pants");
+						if (!inv->getItem(0))
+						{
+							InventoryItem* const item = inv->changeItem(
 								0,
 								InventoryItem::create(CONTENT_CLOTHESITEM_CANVAS_PANTS_BLUE,1)
 							);
 							if (item)
 								delete item;
 						}
 					}
 					{
-						InventoryList *inv = player->inventory.getList("boots");
-						if (!inv->getItem(0)) {
-							InventoryItem *item = inv->changeItem(
+						InventoryList* const inv = player->inventory.getList("boots");
+						if (!inv->getItem(0))
+						{
+							InventoryItem* const item = inv->changeItem(
 								0,
 								InventoryItem::create(CONTENT_CLOTHESITEM_LEATHER_SHOES,1)
 							);
 							if (item)
 								delete item;
@@ -1502,30 +1562,30 @@
 
 		u8 type = readU8(is);
 		v3f pos = readV3F1000(is);
 		std::string ev = deSerializeString(is);
 		switch (type) {
-		case ENV_EVENT_SOUND: // sound
+		  case ENV_EVENT_SOUND: // sound
 			playSoundAt(ev,pos,false);
 			break;
-		case ENV_EVENT_DIG_PARTICLES: // dig particles
+		  case ENV_EVENT_DIG_PARTICLES: // dig particles
 			break;
-		case ENV_EVENT_PUNCH_PARTICLES: // punch particles
+		  case ENV_EVENT_PUNCH_PARTICLES: // punch particles
 			break;
-		case ENV_EVENT_NODE_PARTICLES: // node particles
+		  case ENV_EVENT_NODE_PARTICLES: // node particles
 			break;
-		case ENV_EVENT_SLEEP: // go to sleep
+		  case ENV_EVENT_SLEEP: // go to sleep
 			m_sleeping = true;
 			m_waking = false;
 			m_sleep_state = 0.5;
 			break;
-		case ENV_EVENT_WAKE: // wake up
+		  case ENV_EVENT_WAKE: // wake up
 			m_sleeping = false;
 			m_waking = true;
 			m_sleep_state = 1.0;
 			break;
-		default:
+		  default:
 			infostream<<"Client: unknown env_event: "<<type<<": "<<ev<<std::endl;
 		}
 	}
 	break;
 	default:
@@ -1543,11 +1603,12 @@
 }
 
 void Client::groundAction(u8 action, v3s16 nodepos_undersurface,
 		v3s16 nodepos_oversurface, u16 item)
 {
-	if(connectedAndInitialized() == false){
+	if(connectedAndInitialized() == false)
+	{
 		infostream<<"Client::groundAction() "
 				"cancelled (not connected)"
 				<<std::endl;
 		return;
 	}
@@ -1571,22 +1632,24 @@
 	writeU8(&data[2], action);
 	writeV3S16(&data[3], nodepos_undersurface);
 	writeV3S16(&data[9], nodepos_oversurface);
 	writeU16(&data[15], item);
 	Send(0, data, true);
-	if (action == 3) {
-		content_t c = m_env.getMap().getNodeNoEx(nodepos_undersurface).getContent();
+	if (action == 3)
+	{
+		const content_t c = m_env.getMap().getNodeNoEx(
+				nodepos_undersurface).getContent();
 		playDigSound(c);
 	}
 }
 
 void Client::throwItem(v3f dir, u16 item)
 {
 	std::ostringstream os(std::ios_base::binary);
 	u8 buf[15];
 
-	LocalPlayer* player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 
 	// Write command
 	writeU16(buf, TOSERVER_THROWITEM);
 	os.write((char*)buf, 2);
 
@@ -1622,11 +1685,11 @@
 	// Send as reliable
 	Send(0, data, true);
 
 #if USE_AUDIO == 1
 	{
-		InventoryItem *item = (InventoryItem*)m_env.getLocalPlayer()->getWieldItem();
+		InventoryItem* const item = (InventoryItem*)m_env.getLocalPlayer()->getWieldItem();
 		if (!item)
 			return;
 		std::string snd("");
 		content_t w = item->getContent();
 		if ((w&CONTENT_CRAFTITEM_MASK) == CONTENT_CRAFTITEM_MASK)
@@ -1644,20 +1707,22 @@
 				"cancelled (not connected)"
 				<<std::endl;
 		return;
 	}
 
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (player == NULL)
 		return;
 
-	ClientActiveObject *obj = m_env.getActiveObject(id);
-	if (obj) {
-		if (button == 0) {
+	ClientActiveObject* const obj = m_env.getActiveObject(id);
+	if (obj)
+	{
+		if (button == 0)
+		{
 			content_t punch_item = CONTENT_IGNORE;
 
-			InventoryList *mlist = player->inventory.getList("main");
+			InventoryList* const mlist = player->inventory.getList("main");
 			if (mlist != NULL) {
 				InventoryItem *item = mlist->getItem(item_i);
 				if (item)
 					punch_item = item->getContent();
 			}
@@ -1763,11 +1828,11 @@
 }
 
 void Client::sendChangePassword(const std::wstring oldpassword,
 		const std::wstring newpassword)
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if(player == NULL)
 		return;
 
 	std::string playername = player->getName();
 	std::string oldpwd = translatePassword(playername, oldpassword);
@@ -1844,11 +1909,11 @@
 	Send(0, data, true);
 }
 
 void Client::sendPlayerPos()
 {
-	LocalPlayer *myplayer = m_env.getLocalPlayer();
+	LocalPlayer* const myplayer = m_env.getLocalPlayer();
 	if (myplayer == NULL)
 		return;
 
 	// Save bandwidth by only updating position when something changed
 	if (
@@ -1899,11 +1964,11 @@
 	Send(0, data, false);
 }
 
 void Client::sendPlayerItem(u16 item)
 {
-	Player *myplayer = m_env.getLocalPlayer();
+	Player* const myplayer = m_env.getLocalPlayer();
 	if(myplayer == NULL)
 		return;
 
 	u16 our_peer_id = m_con.GetPeerID();
 
@@ -2009,18 +2074,18 @@
 }
 
 void Client::setPlayerControl(PlayerControl &control)
 {
 	//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
-	LocalPlayer *player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 	assert(player != NULL);
 	player->control = control;
 }
 
 void Client::selectPlayerItem(u16 item)
 {
-	LocalPlayer *player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 	assert(player != NULL);
 
 	player->wieldItem(item);
 
 	sendPlayerItem(item);
@@ -2039,11 +2104,11 @@
 
 // Copies the inventory of the local player to parameter
 void Client::getLocalInventory(Inventory &dst)
 {
 	//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	assert(player != NULL);
 	dst = player->inventory;
 }
 
 InventoryContext *Client::getInventoryContext()
@@ -2086,26 +2151,26 @@
 	case InventoryLocation::UNDEFINED:
 	{}
 	break;
 	case InventoryLocation::CURRENT_PLAYER:
 	{
-		Player *player = m_env.getLocalPlayer();
+		Player* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		return &player->inventory;
 	}
 	break;
 	case InventoryLocation::PLAYER:
 	{
-		Player *player = m_env.getPlayer(loc->name.c_str());
+		Player* const player = m_env.getPlayer(loc->name.c_str());
 		if(!player)
 			return NULL;
 		return &player->inventory;
 	}
 	break;
 	case InventoryLocation::NODEMETA:
 	{
-		NodeMetadata *meta = m_env.getMap().getNodeMetadata(loc->p);
+		NodeMetadata* const meta = m_env.getMap().getNodeMetadata(loc->p);
 		if(!meta)
 			return NULL;
 		return meta->getInventory();
 	}
 	break;
@@ -2158,72 +2223,73 @@
 {
 }
 
 u16 Client::getHP()
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0;
 	return player->health;
 }
 
 u16 Client::getAir()
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0;
 	return player->air;
 }
 
 u16 Client::getHunger()
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0;
 	return player->hunger;
 }
 
 float Client::getEnergy()
 {
-	LocalPlayer *player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0.0;
 	return player->getEnergy();
 }
 
 void Client::addUpdateMeshTask(v3s16 p, bool ack_to_server, bool refresh_only)
 {
-	MapBlock *b = m_env.getMap().getBlockNoCreateNoEx(p);
+	MapBlock* const b = m_env.getMap().getBlockNoCreateNoEx(p);
 	if (b == NULL)
 		return;
 
 	/*
 		Create a task to update the mesh of the block
 	*/
 
-	MeshMakeData *data = new MeshMakeData();
+	MeshMakeData* data = new MeshMakeData();
 	data->m_env = &m_env;
 
-	if (refresh_only) {
-		data->m_daynight_ratio = m_env.getDayNightRatio();
-		data->m_refresh_only = true;
-	}else{
-		{
-			data->fill(m_env.getDayNightRatio(), b);
-		}
-
-		data->m_sounds = &b->m_sounds;
+	if (refresh_only)
+	{
+	    data->m_daynight_ratio = m_env.getDayNightRatio();
+	    data->m_refresh_only = true;
+	}
+	else
+	{
+	    data->fill(m_env.getDayNightRatio(), b);
+	    data->m_sounds = &b->m_sounds;
 	}
 
 	// Add task to queue
 	m_mesh_update_thread.m_queue_in.addBlock(p, data, ack_to_server);
 
 	/*
 		Mark mesh as non-expired at this point so that it can
 		be marked as expired again if the data changes
 	*/
 	b->setMeshExpired(false);
+	b->ResetCurrent();
 }
 
 void Client::addUpdateMeshTaskWithEdge(v3s16 blockpos, bool ack_to_server)
 {
 	try{
@@ -2285,11 +2351,13 @@
 }
 
 // foot: 0 = left, 1 = right
 void Client::playStepSound(int foot)
 {
+#if USE_AUDIO == 1
 	sound_play_step(&m_env.getMap(),m_env.getLocalPlayer()->getPosition(),foot,1.0);
+#endif
 }
 
 void Client::playDigSound(content_t c)
 {
 	if (c == CONTENT_IGNORE) {
@@ -2297,19 +2365,22 @@
 		if ((c&CONTENT_MOB_MASK) != 0)
 			return;
 	}
 	if (c == CONTENT_IGNORE)
 		c = CONTENT_AIR;
-
+	
+#if USE_AUDIO == 1
 	sound_play_dig(c,m_env.getLocalPlayer()->getPosition());
+#endif
 }
 
 void Client::playPlaceSound(content_t c)
 {
 	if (c == CONTENT_IGNORE)
 		c = getPointedContent();
 
+#if USE_AUDIO == 1
 	ContentFeatures *f = &content_features(c);
 	if (f->sound_place != "") {
 		sound_play_effect((char*)f->sound_place.c_str(),1.0,0,NULL);
 		return;
 	}
@@ -2318,17 +2389,22 @@
 		sound_play_effect("liquid-place",1.0,0,NULL);
 		break;
 	default:
 		sound_play_effect("place",1.0,0,NULL);
 	}
+#endif
 }
 
 void Client::playSound(std::string &name, bool loop)
 {
+#if USE_AUDIO == 1
 	sound_play_effect((char*)name.c_str(),1.0,loop,NULL);
+#endif
 }
 
 void Client::playSoundAt(std::string &name, v3f pos, bool loop)
 {
+#if USE_AUDIO == 1
 	v3_t p = {pos.X,pos.Y,pos.Z};
 	sound_play_effect((char*)name.c_str(),1.0,loop,&p);
+#endif
 }
diff -rU5 voxelands-v1709.00old/src/client.h voxelands-v1709.00good/src/client.h
--- voxelands-v1709.00old/src/client.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/client.h	2024-09-22 18:41:01.689655768 +0200
@@ -160,20 +160,18 @@
 	};
 };
 
 class Client : public con::PeerHandler, public InventoryManager
 {
-public:
+ public:
 	/*
 		NOTE: Nothing is thread-safe here.
 	*/
 
-	Client(
-		IrrlichtDevice *device,
-		std::string password,
-		MapDrawControl &control
-	);
+	Client(IrrlichtDevice* const device,
+		const std::string password,
+		MapDrawControl& control);
 
 	~Client();
 	/*
 		The name of the local player should already be set when
 		calling this, as it is sent in the initialization.
diff -rU5 voxelands-v1709.00old/src/collision.h voxelands-v1709.00good/src/collision.h
--- voxelands-v1709.00old/src/collision.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/collision.h	2024-09-22 18:41:01.689655768 +0200
@@ -44,11 +44,11 @@
 	v3s16 node_p; // COLLISION_NODE
 	v3f old_speed;
 	v3f new_speed;
 
 	CollisionInfo():
-		t(COLLISION_NODE),
+		t(COLLISION_NODE),speed(0),
 		node_p(-32768,-32768,-32768),
 		old_speed(0,0,0),
 		new_speed(0,0,0)
 	{}
 };
diff -rU5 voxelands-v1709.00old/src/common.h voxelands-v1709.00good/src/common.h
--- voxelands-v1709.00old/src/common.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/common.h	2024-09-22 18:41:01.689655768 +0200
@@ -98,54 +98,54 @@
 #define SEND_NO_PREFIX (1<<2)
 
 /* defined in string.c */
 char* trim(char* str);
 /*char* strdup(const char* str);*/
-int str_sanitise(char* dest, int size, char* str);
+int str_sanitise(char* dest, int size,const char* str);
 int strappend(char* dest, int size, char* str);
-int parse_bool(char* str);
-int str_tov3t(char* str, v3_t *v);
+int parse_bool(const char* str);
+int str_tov3t(const char* str, v3_t *v);
 int str_topwd(char* name, char* pass, char* buff, int size);
 
 /* defined in config.c */
-char* config_get(char* name);
-int config_get_int(char* name);
-int64_t config_get_int64(char* name);
-float config_get_float(char* name);
-int config_get_bool(char* name);
-int config_get_v3t(char* name, v3_t *value);
-void config_set(char* name, char* value);
+const char* config_get(const char* name);
+int config_get_int(const char* name);
+int64_t config_get_int64(const char* name);
+float config_get_float(const char* name);
+int config_get_bool(const char* name);
+int config_get_v3t(const char* name, v3_t *value);
+void config_set(const char* name,const char* value);
 int config_set_command(command_context_t *ctx, array_t *args);
-void config_set_int(char* name, int value);
-void config_set_int64(char* name, int64_t value);
-void config_set_float(char* name, float value);
-void config_set_default(char* name, char* value, int (*setter)(char* v));
-void config_set_default_int(char* name, int value, int (*setter)(char* v));
-void config_set_default_float(char* name, float value, int (*setter)(char* v));
-void config_load(char* type, char* file);
+void config_set_int(const char* name, int value);
+void config_set_int64(const char* name, int64_t value);
+void config_set_float(const char* name, float value);
+void config_set_default(const char* name,const char* value, int (*setter)(const char* v));
+void config_set_default_int(const char* name, int value, int (*setter)(const char* v));
+void config_set_default_float(const char* name, float value, int (*setter)(const char* v));
+void config_load(const char* type,const char* file);
 int config_load_command(command_context_t *ctx, array_t *args);
 int config_ignore_command(command_context_t *ctx, array_t *args);
 void config_init(int argc, char** argv);
-void config_save(char* section, char* type, char* file);
-void config_clear(char* section);
+void config_save(const char* section,const char* type,const char* file);
+void config_clear(const char* section);
 
 /* defined in config_default.c */
 void config_default_init(void);
 void config_default_creative(void);
 void config_default_survival(void);
-int config_default_gamemode(char* mode);
+int config_default_gamemode(const char* mode);
 
 /* defined in log.c */
-int log_minlevel_setter(char* v);
-int log_maxlevel_setter(char* v);
-int log_sminlevel_setter(char* v);
-int log_smaxlevel_setter(char* v);
-int log_cminlevel_setter(char* v);
-int log_cmaxlevel_setter(char* v);
-int log_file_setter(char* v);
-void vlprint(uint8_t type, char* str);
-void vlprintf(uint8_t type, char* fmt,...);
+int log_minlevel_setter(const char* v);
+int log_maxlevel_setter(const char* v);
+int log_sminlevel_setter(const char* v);
+int log_smaxlevel_setter(const char* v);
+int log_cminlevel_setter(const char* v);
+int log_cmaxlevel_setter(const char* v);
+int log_file_setter(const char* v);
+void vlprint(uint8_t type,const char* str);
+void vlprintf(uint8_t type,const char* fmt,...);
 
 /* defined in utf8.c */
 int utf8_seqlen(char* str);
 uint32_t utf8_nextchar(char* str, int *i);
 uint32_t utf8_toutf32(char* src, int size);
@@ -196,25 +196,25 @@
 int command_adduser(command_context_t *ctx, array_t *args);
 int command_clearobjects(command_context_t *ctx, array_t *args);
 int command_setpassword(command_context_t *ctx, array_t *args);
 
 /* defined in world.c */
-int world_create(char* name);
-int world_load(char* name);
+int world_create(const char* name);
+int world_load(const char* name);
 int world_import(char* path);
 void world_unload(void);
-int world_init(char* name);
+int world_init(const char* name);
 void world_exit(void);
 worldlist_t *world_list_get(void);
 void world_list_free(worldlist_t *l);
 
 #ifdef __cplusplus
 }
 #include <string>
 class Client;
 void bridge_register_client(Client *c);
-std::string bridge_config_get(char* name);
+std::string bridge_config_get(const char* name);
 #endif
 
 /* bridge stuff TODO: remove */
 #ifdef __cplusplus
 #define EXTERNC extern "C"
diff -rU5 voxelands-v1709.00old/src/config.c voxelands-v1709.00good/src/config.c
--- voxelands-v1709.00old/src/config.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/config.c	2024-09-22 18:41:01.689655768 +0200
@@ -38,15 +38,15 @@
 	0
 };
 
 typedef struct config_s {
 	char* default_value;
-	int (*setter)(char* v);
+	int (*setter)(const char* v);
 } config_t;
 
 /* get the value of a config setting */
-char* config_get(char* name)
+const char* config_get(const char* name)
 {
 	nvp_t *n = nvp_get(&config.items,name);
 	if (!n)
 		return NULL;
 
@@ -55,58 +55,58 @@
 
 	return n->value;
 }
 
 /* get a config setting as an int value */
-int config_get_int(char* name)
+int config_get_int(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (v)
 		return strtol(v,NULL,10);
 
 	return 0;
 }
 
 /* get a config setting as an int value */
-int64_t config_get_int64(char* name)
+int64_t config_get_int64(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (v)
 		return strtoll(v,NULL,10);
 
 	return 0;
 }
 
 /* get a config setting as a float value */
-float config_get_float(char* name)
+float config_get_float(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (v)
 		return strtof(v,NULL);
 
 	return 0.0;
 }
 
 /* get a config setting as a boolean value */
-int config_get_bool(char* name)
+int config_get_bool(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	return parse_bool(v);
 }
 
 /* get a config setting as a v3_t value */
-int config_get_v3t(char* name, v3_t *value)
+int config_get_v3t(const char* name, v3_t *value)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (!v)
 		return 1;
 
 	return str_tov3t(v,value);
 }
 
 /* set the value of a config setting */
-void config_set(char* name, char* value)
+void config_set(const char* name,const char* value)
 {
 	config_t *c;
 	nvp_t *n;
 
 	if (!name)
@@ -163,35 +163,35 @@
 
 	return 0;
 }
 
 /* set a config setting to an int value */
-void config_set_int(char* name, int value)
+void config_set_int(const char* name, int value)
 {
 	char str[20];
 	sprintf(str,"%d",value);
 	config_set(name,str);
 }
 
 /* set a config setting to a 64bit int value */
-void config_set_int64(char* name, int64_t value)
+void config_set_int64(const char* name, int64_t value)
 {
 	char str[50];
 	sprintf(str,"%ld",value);
 	config_set(name,str);
 }
 
 /* set a config setting to a float value */
-void config_set_float(char* name, float value)
+void config_set_float(const char* name, float value)
 {
 	char str[50];
 	sprintf(str,"%f",value);
 	config_set(name,str);
 }
 
 /* set the default value of a config setting */
-void config_set_default(char* name, char* value, int (*setter)(char* v))
+void config_set_default(const char* name,const char* value, int (*setter)(const char* v))
 {
 	config_t *c;
 	nvp_t *n = nvp_get(&config.items,name);
 
 	if (!n) {
@@ -223,27 +223,27 @@
 	if (value)
 		c->default_value = strdup(value);
 }
 
 /* set the default of a config setting to an int value */
-void config_set_default_int(char* name, int value, int (*setter)(char* v))
+void config_set_default_int(const char* name, int value, int (*setter)(const char* v))
 {
 	char str[20];
 	sprintf(str,"%d",value);
 	config_set_default(name,str,setter);
 }
 
 /* set the default of a config setting to a float value */
-void config_set_default_float(char* name, float value, int (*setter)(char* v))
+void config_set_default_float(const char* name, float value, int (*setter)(const char* v))
 {
 	char str[50];
 	sprintf(str,"%f",value);
 	config_set_default(name,str,setter);
 }
 
 /* load a config file */
-void config_load(char* type, char* file)
+void config_load(const char* type,const char* file)
 {
 	char buff[2048];
 	int s;
 	char* l;
 	file_t *f;
@@ -356,11 +356,11 @@
 
 	config.isinit = 1;
 }
 
 /* save the current config */
-void config_save(char* section, char* type, char* file)
+void config_save(const char* section,const char* type,const char* file)
 {
 	file_t *f;
 	nvp_t *n;
 
 	if (!type && !file) {
@@ -408,11 +408,11 @@
 	file_flush(f);
 	file_free(f);
 }
 
 /* clears all config values for section (i.e. "world.*") to defaults */
-void config_clear(char* section)
+void config_clear(const char* section)
 {
 	nvp_t *n;
 	int l;
 
 	/* don't clear everything, only sections */
diff -rU5 voxelands-v1709.00old/src/config_default.c voxelands-v1709.00good/src/config_default.c
--- voxelands-v1709.00old/src/config_default.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/config_default.c	2024-09-22 18:41:01.689655768 +0200
@@ -53,17 +53,27 @@
 	config_set_default("client.video.vsync","false",NULL);
 	config_set_default("client.video.size.width","1024",NULL);
 	config_set_default("client.video.size.height","600",NULL);
 	config_set_default("client.video.driver","opengl",NULL);
 	config_set_default("client.video.hpfpu","true",NULL);
-
+	
+#if USE_AUDIO == 1
 	config_set_default("client.sound.volume","50",sound_master_setter);
 	config_set_default("client.sound.volume.effects","50",sound_effects_setter);
 	config_set_default("client.sound.volume.music","50",sound_music_setter);
+#else
+	config_set_default("client.sound.volume","50",NULL);
+	config_set_default("client.sound.volume.effects","50",NULL);
+	config_set_default("client.sound.volume.music","50",NULL);
+#endif
 	config_set_default("client.sound.mumble","true",NULL);
 #if USE_MUMBLE == 0
+# if USE_AUDIO == 1
 	config_set_default("client.name",NULL,sound_mumble_set_ident);
+# else
+	config_set_default("client.name",NULL,NULL);
+# endif
 #endif
 
 	config_set_default("client.graphics.mesh.lod","3",NULL);
 	config_set_default("client.graphics.texture.animations","false",NULL);
 	config_set_default("client.graphics.texture.atlas","true",NULL);
@@ -228,11 +238,11 @@
 	config_set_default("world.player.hunger","true",NULL);
 
 	config_set_default("world.game.mob.spawn.level","destructive",NULL);
 }
 
-int config_default_gamemode(char* mode)
+int config_default_gamemode(const char* mode)
 {
 	if (mode && !strcmp(mode,"creative")) {
 		config_default_creative();
 	}else{
 		config_default_survival();
diff -rU5 voxelands-v1709.00old/src/connection.cpp voxelands-v1709.00good/src/connection.cpp
--- voxelands-v1709.00old/src/connection.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/connection.cpp	2024-09-22 18:41:01.705655793 +0200
@@ -168,11 +168,11 @@
 	core::list<BufferedPacket>::Iterator i;
 	i = m_list.begin();
 	for(; i != m_list.end(); i++)
 	{
 		u16 s = readU16(&(i->data[BASE_HEADER_SIZE+1]));
-		dout_con<<s<<" ";
+		dout_con << s << " ";
 	}
 }
 bool ReliablePacketBuffer::empty()
 {
 	return m_list.empty();
@@ -217,11 +217,11 @@
 }
 BufferedPacket ReliablePacketBuffer::popSeqnum(u16 seqnum)
 {
 	RPBSearchResult r = findPacket(seqnum);
 	if(r == notFound()){
-		dout_con<<"Not found"<<std::endl;
+		dout_con << "Not found" << std::endl;
 		throw NotFoundException("seqnum not found in buffer");
 	}
 	BufferedPacket p = *r;
 	m_list.erase(r);
 	return p;
@@ -349,17 +349,17 @@
 
 	IncomingSplitPacket *sp = m_buf[seqnum];
 
 	// TODO: These errors should be thrown or something? Dunno.
 	if(chunk_count != sp->chunk_count)
-		derr_con<<"Connection: WARNING: chunk_count="<<chunk_count
-				<<" != sp->chunk_count="<<sp->chunk_count
-				<<std::endl;
+		derr_con << "Connection: WARNING: chunk_count=" << chunk_count
+				 << " != sp->chunk_count=" << sp->chunk_count
+				 << std::endl;
 	if(reliable != sp->reliable)
-		derr_con<<"Connection: WARNING: reliable="<<reliable
-				<<" != sp->reliable="<<sp->reliable
-				<<std::endl;
+		derr_con << "Connection: WARNING: reliable=" << reliable
+				 << " != sp->reliable=" << sp->reliable
+				 << std::endl;
 
 	// If chunk already exists, cancel
 	if(sp->chunks.find(chunk_num) != NULL)
 		throw AlreadyExistsException("Chunk already in buffer");
 
@@ -420,12 +420,12 @@
 	}
 	core::list<u16>::Iterator j;
 	j = remove_queue.begin();
 	for(; j != remove_queue.end(); j++)
 	{
-		dout_con<<"NOTE: Removing timed out unreliable split packet"
-				<<std::endl;
+		dout_con << "NOTE: Removing timed out unreliable split packet"
+				 << std::endl;
 		delete m_buf[*j];
 		m_buf.remove(*j);
 	}
 }
 
@@ -518,11 +518,12 @@
 	m_bc_peerhandler(NULL),
 	m_bc_receive_timeout(0),
 	m_indentation(0)
 {
 	m_socket.setTimeoutMs(5);
-
+	m_peers_mutex.Init();
+	
 	Start();
 }
 
 Connection::Connection(u32 protocol_id, u32 max_packet_size, float timeout,
 		PeerHandler *peerhandler):
@@ -533,10 +534,11 @@
 	m_bc_peerhandler(peerhandler),
 	m_bc_receive_timeout(0),
 	m_indentation(0)
 {
 	m_socket.setTimeoutMs(5);
+	m_peers_mutex.Init();
 
 	Start();
 }
 
 
@@ -548,13 +550,15 @@
 /* Internal stuff */
 
 void * Connection::Thread()
 {
 	ThreadStarted();
+	log_mutex.Lock();
 	log_register_thread("Connection");
+	log_mutex.Unlock();
 
-	dout_con<<"Connection thread started"<<std::endl;
+	dout_con  <<  "Connection thread started"  <<  std::endl;
 
 	u32 curtime = porting::getTimeMs();
 	u32 lasttime = curtime;
 
 	while(getRun())
@@ -594,35 +598,39 @@
 
 void Connection::processCommand(ConnectionCommand &c)
 {
 	switch(c.type){
 	case CONNCMD_NONE:
-		dout_con<<getDesc()<<" processing CONNCMD_NONE"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_NONE" << std::endl;
 		return;
 	case CONNCMD_SERVE:
-		dout_con<<getDesc()<<" processing CONNCMD_SERVE port="
-				<<c.port<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_SERVE port="
+				<< c.port << std::endl;
 		serve(c.port);
 		return;
 	case CONNCMD_CONNECT:
-		dout_con<<getDesc()<<" processing CONNCMD_CONNECT"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_CONNECT"
+			 << std::endl;
 		connect(c.address);
 		return;
 	case CONNCMD_DISCONNECT:
-		dout_con<<getDesc()<<" processing CONNCMD_DISCONNECT"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_DISCONNECT"
+			 << std::endl;
 		disconnect();
 		return;
 	case CONNCMD_SEND:
-		dout_con<<getDesc()<<" processing CONNCMD_SEND"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_SEND" << std::endl;
 		send(c.peer_id, c.channelnum, c.data, c.reliable);
 		return;
 	case CONNCMD_SEND_TO_ALL:
-		dout_con<<getDesc()<<" processing CONNCMD_SEND_TO_ALL"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_SEND_TO_ALL"
+			 << std::endl;
 		sendToAll(c.channelnum, c.data, c.reliable);
 		return;
 	case CONNCMD_DELETE_PEER:
-		dout_con<<getDesc()<<" processing CONNCMD_DELETE_PEER"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_DELETE_PEER"
+			 << std::endl;
 		deletePeer(c.peer_id, false);
 		return;
 	}
 }
 
@@ -715,11 +723,11 @@
 
 		u16 peer_id = readPeerId(*packetdata);
 		u8 channelnum = readChannel(*packetdata);
 		if(channelnum > CHANNEL_COUNT-1){
 			PrintInfo(derr_con);
-			derr_con<<"Receive(): Invalid channel "<<channelnum<<std::endl;
+			derr_con << "Receive(): Invalid channel " << channelnum << std::endl;
 			throw InvalidIncomingDataException("Channel doesn't exist");
 		}
 
 		if(peer_id == PEER_ID_INEXISTENT)
 		{
@@ -754,12 +762,12 @@
 			else
 			{
 				Peer *peer = j.getNode()->getValue();
 				peer_id = peer->id;
 				PrintInfo(derr_con);
-				derr_con<<"WARNING: Assuming unknown peer to be "
-						<<"peer_id="<<peer_id<<std::endl;
+				derr_con << "WARNING: Assuming unknown peer to be "
+						 << "peer_id=" << peer_id << std::endl;
 			}
 		}
 
 		/*
 			The peer was not found in our lists. Add it.
@@ -785,17 +793,17 @@
 					break;
 				}
 				peer_id_new++;
 			}
 			if(out_of_ids){
-				errorstream<<getDesc()<<" ran out of peer ids"<<std::endl;
+				errorstream << getDesc() << " ran out of peer ids" << std::endl;
 				continue;
 			}
 
 			PrintInfo();
-			dout_con<<"Receive(): Got a packet with peer_id=PEER_ID_INEXISTENT,"
-					" giving peer_id="<<peer_id_new<<std::endl;
+			dout_con  <<  "Receive(): Got a packet with peer_id=PEER_ID_INEXISTENT,"
+					" giving peer_id=" << peer_id_new<<std::endl;
 
 			// Create a peer
 			Peer *peer = new Peer(peer_id_new, sender);
 			m_peers.insert(peer->id, peer);
 
@@ -823,22 +831,22 @@
 		{
 			// Peer not found
 			// This means that the peer id of the sender is not PEER_ID_INEXISTENT
 			// and it is invalid.
 			PrintInfo(derr_con);
-			derr_con<<"Receive(): Peer not found"<<std::endl;
+			derr_con << "Receive(): Peer not found" << std::endl;
 			throw InvalidIncomingDataException("Peer not found (possible timeout)");
 		}
 
 		Peer *peer = node->getValue();
 
 		// Validate peer address
 		if(peer->address != sender)
 		{
 			PrintInfo(derr_con);
-			derr_con<<"Peer "<<peer_id<<" sending from different address."
-					" Ignoring."<<std::endl;
+			derr_con  <<  "Peer " << peer_id << " sending from different address."
+					" Ignoring." << std::endl;
 			continue;
 		}
 
 		peer->timeout_counter = 0.0;
 
@@ -855,12 +863,12 @@
 			// Process it (the result is some data with no headers made by us)
 			SharedBuffer<u8> resultdata = processPacket
 					(channel, strippeddata, peer_id, channelnum, false);
 
 			PrintInfo();
-			dout_con<<"ProcessPacket returned data of size "
-					<<resultdata.getSize()<<std::endl;
+			dout_con << "ProcessPacket returned data of size "
+					<< resultdata.getSize() << std::endl;
 
 			if(datasize < resultdata.getSize())
 				throw InvalidIncomingDataException
 						("Buffer too small for received data");
 
@@ -891,14 +899,14 @@
 		*/
 		peer->timeout_counter += dtime;
 		if(peer->timeout_counter > m_timeout)
 		{
 			PrintInfo(derr_con);
-			derr_con<<"RunTimeouts(): Peer "<<peer->id
-					<<" has timed out."
-					<<" (source=peer->timeout_counter)"
-					<<std::endl;
+			derr_con << "RunTimeouts(): Peer " << peer->id
+					 << " has timed out."
+					 << " (source=peer->timeout_counter)"
+					 << std::endl;
 			// Add peer to the list
 			timeouted_peers.push_back(peer->id);
 			// Don't bother going through the buffers of this one
 			continue;
 		}
@@ -920,14 +928,14 @@
 			// Check reliable packet total times, remove peer if
 			// over timeout.
 			if(channel->outgoing_reliables.anyTotaltimeReached(m_timeout))
 			{
 				PrintInfo(derr_con);
-				derr_con<<"RunTimeouts(): Peer "<<peer->id
-						<<" has timed out."
-						<<" (source=reliable packet totaltime)"
-						<<std::endl;
+				derr_con << "RunTimeouts(): Peer " << peer->id
+						 << " has timed out."
+						 << " (source=reliable packet totaltime)"
+						 << std::endl;
 				// Add peer to the to-be-removed list
 				timeouted_peers.push_back(peer->id);
 				goto nextpeer;
 			}
 
@@ -944,17 +952,17 @@
 				u16 peer_id = readPeerId(*(j->data));
 				u8 channel = readChannel(*(j->data));
 				u16 seqnum = readU16(&(j->data[BASE_HEADER_SIZE+1]));
 
 				PrintInfo(derr_con);
-				derr_con<<"RE-SENDING timed-out RELIABLE to ";
+				derr_con << "RE-SENDING timed-out RELIABLE to ";
 				j->address.print(&derr_con);
-				derr_con<<"(t/o="<<resend_timeout<<"): "
-						<<"from_peer_id="<<peer_id
-						<<", channel="<<((int)channel&0xff)
-						<<", seqnum="<<seqnum
-						<<std::endl;
+				derr_con << "(t/o=" << resend_timeout << "): "
+						 << "from_peer_id=" << peer_id
+						 << ", channel=" << ((int)channel&0xff)
+						 << ", seqnum=" << seqnum
+						 << std::endl;
 
 				rawSend(*j);
 
 				// Enlarge avg_rtt and resend_timeout:
 				// The rtt will be at least the timeout.
@@ -986,18 +994,18 @@
 	// Remove timed out peers
 	core::list<u16>::Iterator i = timeouted_peers.begin();
 	for(; i != timeouted_peers.end(); i++)
 	{
 		PrintInfo(derr_con);
-		derr_con<<"RunTimeouts(): Removing peer "<<(*i)<<std::endl;
+		derr_con << "RunTimeouts(): Removing peer " << (*i) << std::endl;
 		deletePeer(*i, true);
 	}
 }
 
 void Connection::serve(u16 port)
 {
-	dout_con<<getDesc()<<" serving at port "<<port<<std::endl;
+	dout_con << getDesc() << " serving at port " << port << std::endl;
 #ifndef SERVER
 	try{
 #endif
 	m_socket.Bind(port);
 #ifndef SERVER
@@ -1009,12 +1017,12 @@
 	m_peer_id = PEER_ID_SERVER;
 }
 
 void Connection::connect(Address address)
 {
-	dout_con<<getDesc()<<" connecting to "<<address.serializeString()
-			<<":"<<address.getPort()<<std::endl;
+	dout_con << getDesc() << " connecting to " << address.serializeString()
+			<< ":" << address.getPort() << std::endl;
 
 	core::map<u16, Peer*>::Node *node = m_peers.find(PEER_ID_SERVER);
 	if(node != NULL){
 		throw ConnectionException("Already connected to a server");
 	}
@@ -1035,11 +1043,11 @@
 	Send(PEER_ID_SERVER, 0, data, true);
 }
 
 void Connection::disconnect()
 {
-	dout_con<<getDesc()<<" disconnecting"<<std::endl;
+	dout_con << getDesc() << " disconnecting" << std::endl;
 
 	// Create and send DISCO packet
 	SharedBuffer<u8> data(2);
 	writeU8(&data[0], TYPE_CONTROL);
 	writeU8(&data[1], CONTROLTYPE_DISCO);
@@ -1066,11 +1074,11 @@
 }
 
 void Connection::send(u16 peer_id, u8 channelnum,
 		SharedBuffer<u8> data, bool reliable)
 {
-	dout_con<<getDesc()<<" sending to peer_id="<<peer_id<<std::endl;
+	dout_con << getDesc() << " sending to peer_id=" << peer_id << std::endl;
 
 	assert(channelnum < CHANNEL_COUNT);
 
 	Peer *peer = getPeerNoEx(peer_id);
 	if(peer == NULL)
@@ -1126,13 +1134,13 @@
 			channel->outgoing_reliables.insert(p);
 		}
 		catch(AlreadyExistsException &e)
 		{
 			PrintInfo(derr_con);
-			derr_con<<"WARNING: Going to send a reliable packet "
-					"seqnum="<<seqnum<<" that is already "
-					"in outgoing buffer"<<std::endl;
+			derr_con << "WARNING: Going to send a reliable packet "
+					"seqnum=" << seqnum << " that is already "
+					"in outgoing buffer" << std::endl;
 			//assert(0);
 		}
 
 		// Send the packet
 		rawSend(p);
@@ -1151,12 +1159,12 @@
 void Connection::rawSend(const BufferedPacket &packet)
 {
 	try{
 		m_socket.Send(packet.address, *packet.data, packet.data.getSize());
 	} catch(SendFailedException &e){
-		derr_con<<"Connection::rawSend(): SendFailedException: "
-				<<packet.address.serializeString()<<std::endl;
+		derr_con << "Connection::rawSend(): SendFailedException: "
+				 << packet.address.serializeString() << std::endl;
 	}
 }
 
 Peer* Connection::getPeer(u16 peer_id)
 {
@@ -1232,11 +1240,11 @@
 			channel->incoming_reliables.popFirst();
 		else
 			break;
 	}
 	// This happens if all packets are old
-	}catch(con::NotFoundException)
+	}catch(con::NotFoundException const&)
 	{}
 
 	if(channel->incoming_reliables.empty() == false)
 	{
 		if(firstseqnum == channel->next_incoming_seqnum)
@@ -1246,15 +1254,15 @@
 			peer_id = readPeerId(*p.data);
 			u8 channelnum = readChannel(*p.data);
 			u16 seqnum = readU16(&p.data[BASE_HEADER_SIZE+1]);
 
 			PrintInfo();
-			dout_con<<"UNBUFFERING TYPE_RELIABLE"
-					<<" seqnum="<<seqnum
-					<<" peer_id="<<peer_id
-					<<" channel="<<((int)channelnum&0xff)
-					<<std::endl;
+			dout_con << "UNBUFFERING TYPE_RELIABLE"
+					<< " seqnum=" << seqnum
+					<< " peer_id=" << peer_id
+					<< " channel=" << ((int)channelnum&0xff)
+					<< std::endl;
 
 			channel->next_incoming_seqnum++;
 
 			u32 headers_size = BASE_HEADER_SIZE + RELIABLE_HEADER_SIZE;
 			// Get out the inside packet and re-process it
@@ -1292,13 +1300,14 @@
 				throw InvalidIncomingDataException
 						("packetdata.getSize() < 4 (ACK header size)");
 
 			u16 seqnum = readU16(&packetdata[2]);
 			PrintInfo();
-			dout_con<<"Got CONTROLTYPE_ACK: channelnum="
-					<<((int)channelnum&0xff)<<", peer_id="<<peer_id
-					<<", seqnum="<<seqnum<<std::endl;
+			dout_con << "Got CONTROLTYPE_ACK: channelnum="
+				 << ((int)channelnum&0xff)
+				 << ", peer_id=" << peer_id
+				 << ", seqnum=" << seqnum << std::endl;
 
 			try{
 				BufferedPacket p = channel->outgoing_reliables.popSeqnum(seqnum);
 				// Get round trip time
 				float rtt = p.totaltime;
@@ -1316,13 +1325,13 @@
 				channel->outgoing_reliables.print();
 				dout_con<<std::endl;*/
 			}
 			catch(NotFoundException &e){
 				PrintInfo(derr_con);
-				derr_con<<"WARNING: ACKed packet not "
+				derr_con << "WARNING: ACKed packet not "
 						"in outgoing queue"
-						<<std::endl;
+						<< std::endl;
 			}
 
 			throw ProcessedSilentlyException("Got an ACK");
 		}
 		else if(controltype == CONTROLTYPE_SET_PEER_ID)
@@ -1330,63 +1339,63 @@
 			if(packetdata.getSize() < 4)
 				throw InvalidIncomingDataException
 						("packetdata.getSize() < 4 (SET_PEER_ID header size)");
 			u16 peer_id_new = readU16(&packetdata[2]);
 			PrintInfo();
-			dout_con<<"Got new peer id: "<<peer_id_new<<"... "<<std::endl;
+			dout_con << "Got new peer id: " << peer_id_new << "... " << std::endl;
 
 			if(GetPeerID() != PEER_ID_INEXISTENT)
 			{
 				PrintInfo(derr_con);
-				derr_con<<"WARNING: Not changing"
-						" existing peer id."<<std::endl;
+				derr_con << "WARNING: Not changing"
+						" existing peer id." << std::endl;
 			}
 			else
 			{
-				dout_con<<"changing."<<std::endl;
+				dout_con << "changing." << std::endl;
 				SetPeerID(peer_id_new);
 			}
 			throw ProcessedSilentlyException("Got a SET_PEER_ID");
 		}
 		else if(controltype == CONTROLTYPE_PING)
 		{
 			// Just ignore it, the incoming data already reset
 			// the timeout counter
 			PrintInfo();
-			dout_con<<"PING"<<std::endl;
+			dout_con << "PING" << std::endl;
 			throw ProcessedSilentlyException("Got a PING");
 		}
 		else if(controltype == CONTROLTYPE_DISCO)
 		{
 			// Just ignore it, the incoming data already reset
 			// the timeout counter
 			PrintInfo();
-			dout_con<<"DISCO: Removing peer "<<(peer_id)<<std::endl;
+			dout_con << "DISCO: Removing peer " << (peer_id) << std::endl;
 
 			if(deletePeer(peer_id, false) == false)
 			{
 				PrintInfo(derr_con);
-				derr_con<<"DISCO: Peer not found"<<std::endl;
+				derr_con << "DISCO: Peer not found" << std::endl;
 			}
 
 			throw ProcessedSilentlyException("Got a DISCO");
 		}
 		else{
 			PrintInfo(derr_con);
-			derr_con<<"INVALID TYPE_CONTROL: invalid controltype="
-					<<((int)controltype&0xff)<<std::endl;
+			derr_con << "INVALID TYPE_CONTROL: invalid controltype="
+					 << ((int)controltype&0xff) << std::endl;
 			throw InvalidIncomingDataException("Invalid control type");
 		}
 	}
 	else if(type == TYPE_ORIGINAL)
 	{
 		if(packetdata.getSize() < ORIGINAL_HEADER_SIZE)
 			throw InvalidIncomingDataException
 					("packetdata.getSize() < ORIGINAL_HEADER_SIZE");
 		PrintInfo();
-		dout_con<<"RETURNING TYPE_ORIGINAL to user"
-				<<std::endl;
+		dout_con << "RETURNING TYPE_ORIGINAL to user"
+				<< std::endl;
 		// Get the inside packet out and return it
 		SharedBuffer<u8> payload(packetdata.getSize() - ORIGINAL_HEADER_SIZE);
 		memcpy(*payload, &packetdata[ORIGINAL_HEADER_SIZE], payload.getSize());
 		return payload;
 	}
@@ -1403,16 +1412,16 @@
 		// Buffer the packet
 		SharedBuffer<u8> data = channel->incoming_splits.insert(packet, reliable);
 		if(data.getSize() != 0)
 		{
 			PrintInfo();
-			dout_con<<"RETURNING TYPE_SPLIT: Constructed full data, "
-					<<"size="<<data.getSize()<<std::endl;
+			dout_con << "RETURNING TYPE_SPLIT: Constructed full data, "
+					<< "size=" << data.getSize() << std::endl;
 			return data;
 		}
 		PrintInfo();
-		dout_con<<"BUFFERED TYPE_SPLIT"<<std::endl;
+		dout_con << "BUFFERED TYPE_SPLIT" << std::endl;
 		throw ProcessedSilentlyException("Buffered a split packet chunk");
 	}
 	else if(type == TYPE_RELIABLE)
 	{
 		// Recursive reliable packets not allowed
@@ -1427,20 +1436,20 @@
 		bool is_future_packet = seqnum_higher(seqnum, channel->next_incoming_seqnum);
 		bool is_old_packet = seqnum_higher(channel->next_incoming_seqnum, seqnum);
 
 		PrintInfo();
 		if(is_future_packet)
-			dout_con<<"BUFFERING";
+			dout_con << "BUFFERING";
 		else if(is_old_packet)
-			dout_con<<"OLD";
+			dout_con << "OLD";
 		else
-			dout_con<<"RECUR";
-		dout_con<<" TYPE_RELIABLE seqnum="<<seqnum
-				<<" next="<<channel->next_incoming_seqnum;
-		dout_con<<" [sending CONTROLTYPE_ACK"
-				" to peer_id="<<peer_id<<"]";
-		dout_con<<std::endl;
+			dout_con << "RECUR";
+		dout_con << " TYPE_RELIABLE seqnum=" << seqnum
+				<< " next=" << channel->next_incoming_seqnum;
+		dout_con << " [sending CONTROLTYPE_ACK"
+				" to peer_id=" << peer_id << "]";
+		dout_con << std::endl;
 
 		//DEBUG
 		//assert(channel->incoming_reliables.size() < 100);
 
 		// Send a CONTROLTYPE_ACK
@@ -1496,11 +1505,11 @@
 		return processPacket(channel, payload, peer_id, channelnum, true);
 	}
 	else
 	{
 		PrintInfo(derr_con);
-		derr_con<<"Got invalid type="<<((int)type&0xff)<<std::endl;
+		derr_con << "Got invalid type=" << ((int)type&0xff) << std::endl;
 		throw InvalidIncomingDataException("Invalid packet type");
 	}
 
 	// We should never get here.
 	// If you get here, add an exception or a return to some of the
@@ -1595,12 +1604,12 @@
 u32 Connection::Receive(u16 &peer_id, SharedBuffer<u8> &data)
 {
 	for(;;){
 		ConnectionEvent e = waitEvent(m_bc_receive_timeout);
 		if(e.type != CONNEVENT_NONE)
-			dout_con<<getDesc()<<": Receive: got event: "
-					<<e.describe()<<std::endl;
+			dout_con << getDesc() << ": Receive: got event: "
+					<<e.describe() << std::endl;
 		switch(e.type){
 		case CONNEVENT_NONE:
 			throw NoIncomingDataException("No incoming data");
 		case CONNEVENT_DATA_RECEIVED:
 			peer_id = e.peer_id;
diff -rU5 voxelands-v1709.00old/src/constants.h voxelands-v1709.00good/src/constants.h
--- voxelands-v1709.00old/src/constants.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/constants.h	2024-09-22 18:41:01.705655793 +0200
@@ -57,10 +57,13 @@
 
 // Size of node in rendering units
 #define BS 10
 
 #define MAP_BLOCKSIZE 16
+#define MAP_BLOCKSIZE2 16 * 16
+#define MAP_BLOCKSIZE3 16 * 16 * 16
+
 /*
 	This makes mesh updates too slow, as many meshes are updated during
 	the main loop (related to day/night)
 */
 //#define MAP_BLOCKSIZE 32
diff -rU5 voxelands-v1709.00old/src/content_cao.cpp voxelands-v1709.00good/src/content_cao.cpp
--- voxelands-v1709.00old/src/content_cao.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_cao.cpp	2024-09-22 18:41:01.706655795 +0200
@@ -74,24 +74,25 @@
 {
 	if (m_node != NULL)
 		return;
 
 	video::IVideoDriver* driver = smgr->getVideoDriver();
-	MobFeatures m = content_mob_features(m_content);
+	MobFeatures& m = content_mob_features(m_content);
+	
 	if (m.texture_display == MDT_EXTRUDED) {
 		ExtrudedSpriteSceneNode *node = new ExtrudedSpriteSceneNode(smgr->getRootSceneNode(),smgr,-1,v3f(0,0,0),v3f(0,0,0),v3f(5,5,5));
 		node->setVisible(true);
 		node->setSprite(g_texturesource->getTextureRaw(m.texture));
 		m_node = (scene::IMeshSceneNode*)node;
 		m_draw_type = MDT_EXTRUDED;
 		updateNodePos();
 	}else if (m.model != "") {
-		scene::IAnimatedMesh* mesh = createModelMesh(smgr,m.model.c_str(),true);
+		scene::IAnimatedMesh* const mesh = createModelMesh(smgr,m.model.c_str(),true);
 		if (!mesh)
 			return;
 
-		scene::IAnimatedMeshSceneNode* node = smgr->addAnimatedMeshSceneNode(mesh);
+		scene::IAnimatedMeshSceneNode* const node = smgr->addAnimatedMeshSceneNode(mesh);
 
 		if (node) {
 			int s;
 			int e;
 			char buff[1024];
@@ -155,11 +156,12 @@
 		m_node = NULL;
 	}
 }
 void MobCAO::updateLight(u8 light_at_pos)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
+	
 	if (m.glow_light)
 		light_at_pos = m.glow_light;
 	if (m_shooting && m.attack_glow_light)
 		light_at_pos = m.attack_glow_light;
 
@@ -206,11 +208,11 @@
 void MobCAO::step(float dtime, ClientEnvironment *env)
 {
 	if (!m_node)
 		return;
 
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 
 	pos_translator.translate(dtime);
 
 	updateNodePos();
 
@@ -270,11 +272,13 @@
 	if (!m.moves_silently && m_walking && m_draw_type == MDT_MODEL) {
 		m_last_step += dtime;
 		/* roughly sort of when a step sound should probably be heard, maybe */
 		if (m_last_step > 0.5) {
 			m_last_step -= 0.5;
+#if USE_AUDIO == 1
 			sound_play_step(&env->getMap(),m_position,m_next_foot, 0.3);
+#endif
 			m_next_foot = !m_next_foot;
 		}
 	}
 }
 void MobCAO::processMessage(const std::string &data)
@@ -357,11 +361,11 @@
 
 	updateNodePos();
 }
 bool MobCAO::directReportPunch(content_t punch_item, v3f dir)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	if (m.punch_action == MPA_IGNORE)
 		return false;
 
 	ToolItemFeatures f = content_toolitem_features(punch_item);
 	if (m.special_dropped_item != CONTENT_IGNORE && (m.special_punch_item == TT_NONE || f.type == m.special_punch_item))
diff -rU5 voxelands-v1709.00old/src/content_mob.cpp voxelands-v1709.00good/src/content_mob.cpp
--- voxelands-v1709.00old/src/content_mob.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_mob.cpp	2024-09-22 18:41:01.706655795 +0200
@@ -31,17 +31,18 @@
 #include "profiler.h"
 #include "intl.h"
 
 MobFeatures g_content_mob_features[CONTENT_MOB_COUNT];
 
-MobFeatures & content_mob_features(content_t c)
+MobFeatures& content_mob_features(content_t c)
 {
 	static MobFeatures ignore = MobFeatures();
-	if ((c&CONTENT_MOB_MASK) != CONTENT_MOB_MASK)
+	
+	if ((c & CONTENT_MOB_MASK) != CONTENT_MOB_MASK)
 		return ignore;
 
-	u16 i = (c&~CONTENT_MOB_MASK);
+	u16 i = (c & ~CONTENT_MOB_MASK) - 1;
 
 	if (i >= CONTENT_MOB_COUNT)
 		return ignore;
 
 	if (g_content_mob_features[i].content != c)
@@ -60,10 +61,11 @@
 		tiles[i].alpha = alpha;
 		tiles[i].material_type = MATERIAL_ALPHA_VERTEX;
 	}
 }
 #endif
+
 void MobFeatures::getAnimationFrames(MobAnimation type, int *start, int *end)
 {
 	*start = 0;
 	*end = 0;
 	switch (type) {
@@ -131,30 +133,29 @@
 
 	if ((c1 != CONTENT_AIR && c1 != CONTENT_WATERSOURCE) && c1 != c2)
 		return false;
 
 	for (u16 i=0; i<CONTENT_MOB_COUNT; i++) {
-		MobFeatures m = g_content_mob_features[i];
+		const MobFeatures& m = g_content_mob_features[i];
 		if (m.spawn_min_height > pos.Y)
 			continue;
 		if (m.spawn_max_height < pos.Y)
 			continue;
-		if (m.spawn_chance > 1 && rand%m.spawn_chance != 0)
+		if (m.spawn_chance > 1 && rand % m.spawn_chance != 0)
 			continue;
 		can.push_back(i);
 	}
 
 	if (can.size() == 0)
 		return false;
 
-	MobFeatures m;
 	u32 index = 0;
 
 	if (can.size() > 1)
 		index = myrand_range(0,can.size()-1);
 
-	m = g_content_mob_features[can[index]];
+	const MobFeatures& m = g_content_mob_features[can[index]];
 
 	if (m.content == CONTENT_IGNORE)
 		return false;
 
 	v3f p = intToFloat(pos+v3s16(0,1,0), BS);
@@ -172,12 +173,11 @@
 	return true;
 }
 
 void mob_spawn(v3s16 pos, content_t mob, ServerEnvironment *env)
 {
-
-	MobFeatures &m = content_mob_features(mob);
+	const MobFeatures& m = content_mob_features(mob);
 
 	if (m.content == CONTENT_IGNORE)
 		return;
 	if (!config_get_bool("world.game.mob.spawn.natural"))
 		return;
@@ -198,11 +198,11 @@
 void mob_spawn_passive(v3s16 pos, bool water, ServerEnvironment *env)
 {
 	std::vector<content_t> can;
 	int rand = myrand();
 	for (u16 i=0; i<CONTENT_MOB_COUNT; i++) {
-		MobFeatures m = g_content_mob_features[i];
+		const MobFeatures& m = g_content_mob_features[i];
 		if (!m.spawn_naturally)
 			continue;
 		if (m.level > MOB_PASSIVE)
 			continue;
 		if (m.spawn_water != water)
@@ -213,17 +213,16 @@
 	}
 
 	if (can.size() == 0)
 		return;
 
-	MobFeatures m;
 	u32 index = 0;
 
 	if (can.size() > 1)
 		index = myrand_range(0,can.size()-1);
 
-	m = g_content_mob_features[can[index]];
+	const MobFeatures& m = g_content_mob_features[can[index]];
 
 	if (m.content == CONTENT_IGNORE)
 		return;
 
 	v3s16 spots[9] = {
@@ -277,11 +276,11 @@
 	std::vector<content_t> can;
 	u8 level = mobLevelI(config_get("world.game.mob.spawn.level"));
 	if (level < MOB_AGGRESSIVE)
 		return;
 	for (u16 i=0; i<CONTENT_MOB_COUNT; i++) {
-		MobFeatures m = g_content_mob_features[i];
+		const MobFeatures& m = g_content_mob_features[i];
 		if (!m.spawn_naturally)
 			continue;
 		if (m.level < MOB_AGGRESSIVE)
 			continue;
 		if (m.level > level)
@@ -292,17 +291,16 @@
 	}
 
 	if (can.size() == 0)
 		return;
 
-	MobFeatures m;
 	u32 index = 0;
 
 	if (can.size() > 1)
 		index = myrand_range(0,can.size()-1);
 
-	m = g_content_mob_features[can[index]];
+	const MobFeatures& m = g_content_mob_features[can[index]];
 
 	if (m.content == CONTENT_IGNORE)
 		return;
 
 	v3s16 spots[9] = {
@@ -356,11 +354,12 @@
 {
 	content_t i;
 	MobFeatures *f = NULL;
 
 	i = CONTENT_MOB_RAT;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Rat");
 	f->level = MOB_PASSIVE;
 	f->model = "rat.x";
 	f->setTexture("mob_rat.png");
@@ -375,11 +374,12 @@
 	f->spawn_naturally = true;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_FIREFLY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Firefly");
 	f->level = MOB_PASSIVE;
 	f->model_scale = v3f(0.5,0.5,0.5);
 	f->setTexture("mob_firefly.png");
@@ -394,11 +394,12 @@
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/4.,-BS/6.,-BS/4., BS/4.,BS/6.,BS/4.));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_OERKKI;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Oerkki");
 	f->level = MOB_AGGRESSIVE;
 	f->model = "oerkki.x";
 	f->model_scale = v3f(4,4,4);
@@ -415,11 +416,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS*2.,BS/3.));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_DUNGEON_MASTER;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Dungeon Master");
 	f->level = MOB_DESTRUCTIVE;
 	f->model = "dungeon_master.b3d";
 	f->model_rotation = v3f(0,-90,0);
@@ -436,11 +438,12 @@
 	f->attack_throw_offset = v3f(0,1.4,-1.0);
 	f->setCollisionBox(aabb3f(-0.75*BS, 0.*BS, -0.75*BS, 0.75*BS, 2.0*BS, 0.75*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_FIREBALL;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Fireball");
 	f->level = MOB_DESTRUCTIVE;
 	f->setTexture("mob_fireball.png");
 	f->punch_action = MPA_IGNORE;
@@ -453,11 +456,12 @@
 	f->contact_explosion_diameter = 3;
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 
 	i = CONTENT_MOB_DOE;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Doe");
 	f->level = MOB_PASSIVE;
 	f->hp = 30;
 	f->model = "doe.x";
@@ -480,11 +484,12 @@
 	f->spawn_group = 3;
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_STAG;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Stag");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 40;
 	f->model = "stag.x";
@@ -509,11 +514,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.7*BS, 0., -0.7*BS, 0.7*BS, 1.5*BS, 0.7*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_TAMESTAG;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Stag");
 	f->level = MOB_PASSIVE;
 	f->hp = 40;
 	f->model = "stag.b3d";
@@ -532,11 +538,12 @@
 	f->sound_random = "mob-deer-env";
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-0.7*BS, 0., -0.7*BS, 0.7*BS, 1.5*BS, 0.7*BS));
 
 	i = CONTENT_MOB_FISH;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Fish");
 	f->level = MOB_PASSIVE;
 	f->model = "fish.b3d";
 	f->model_rotation = v3f(0,-90,0);
@@ -558,11 +565,12 @@
 	f->hp = 5;
 	f->setCollisionBox(aabb3f(-0.25*BS, 0.25*BS, -0.25*BS, 0.25*BS, 0.75*BS, 0.25*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SHARK;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Shark");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 40;
 	f->model = "shark.b3d";
@@ -583,11 +591,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.75*BS, 0., -0.75*BS, 0.75*BS, 1.*BS, 0.75*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_WOLF;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Wolf");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 40;
 	f->model = "wolf.b3d";
@@ -611,11 +620,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.5*BS, 0., -0.5*BS, 0.5*BS, 1.*BS, 0.5*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_TAMEWOLF;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Tame Wolf");
 	f->level = MOB_PASSIVE;
 	f->hp = 40;
 	f->model = "wolf.b3d";
@@ -637,11 +647,12 @@
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-0.5*BS, 0., -0.5*BS, 0.5*BS, 1.*BS, 0.5*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SHEEP;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Sheep");
 	f->level = MOB_PASSIVE;
 	f->hp = 30;
 	f->model = "sheep.b3d";
@@ -669,11 +680,12 @@
 	f->spawn_group = 4;
 	f->setCollisionBox(aabb3f(-0.4*BS, 0., -0.4*BS, 0.4*BS, 1.*BS, 0.4*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SHEARED_SHEEP;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Sheared Sheep");
 	f->level = MOB_PASSIVE;
 	f->hp = 30;
 	f->model = "sheared_sheep.b3d";
@@ -694,11 +706,12 @@
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-0.4*BS, 0., -0.4*BS, 0.4*BS, 1.*BS, 0.4*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SNOWBALL;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Snowball");
 	f->level = MOB_AGGRESSIVE;
 	f->setTexture("snow_ball.png");
 	f->model_offset = v3f(0,0.2,0);
@@ -712,11 +725,12 @@
 	f->contact_drop_item = CONTENT_CRAFTITEM_SNOW_BALL;
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 
 	i = CONTENT_MOB_ARROW;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Arrow");
 	f->level = MOB_AGGRESSIVE;
 	f->setTexture("mob_arrow.png");
 	f->texture_display = MDT_EXTRUDED;
@@ -730,11 +744,12 @@
 	f->contact_drop_item = CONTENT_CRAFTITEM_ARROW;
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 
 	i = CONTENT_MOB_GREY_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Grey Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
@@ -757,11 +772,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_WHITE_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("White Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
@@ -784,11 +800,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SIAMESE_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Siamese Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
@@ -811,11 +828,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_GINGER_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Ginger Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
diff -rU5 voxelands-v1709.00old/src/content_mob.h voxelands-v1709.00good/src/content_mob.h
--- voxelands-v1709.00old/src/content_mob.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_mob.h	2024-09-22 18:41:01.706655795 +0200
@@ -86,13 +86,14 @@
 };
 
 
 #define CONTENT_MOB_MASK 0x2000
 
-struct MobFeatures {
+class MobFeatures {
+    public:
 	content_t content;
-	char* description;
+	const char* description;
 	u8 level;
 #ifndef SERVER
 	TileSpec tiles[6];
 #endif
 	std::string texture;
@@ -148,45 +149,54 @@
 	MobFeatures()
 	{
 		reset();
 	}
 
+	MobFeatures(const MobFeatures& m)
+	{
+		copie(m);
+	}
+	
+	MobFeatures& operator=(const MobFeatures& m)
+	{
+		copie(m);
+		return *this;
+	}
+	
 	void setCollisionBox(aabb3f cb)
 	{
 		cb.MinEdge.Y -= 0.5*BS;
 		cb.MaxEdge.Y -= 0.5*BS;
 		collisionbox = cb;
 	}
 
-	aabb3f getCollisionBox()
+	aabb3f getCollisionBox() const
 	{
 		if (collisionbox.MinEdge != collisionbox.MaxEdge)
 			return collisionbox;
 		return aabb3f(-0.5*BS,0.,-0.5*BS,0.5*BS,BS,0.5*BS);
 	}
 
-	v3f getSize()
+	v3f getSize() const
 	{
 		aabb3f c = getCollisionBox();
 		return v3f((c.MaxEdge.X-c.MinEdge.X)/BS,(c.MaxEdge.Y-c.MinEdge.Y)/BS,(c.MaxEdge.Z-c.MinEdge.Z)/BS);
 	}
 
-	v3s16 getSizeBlocks()
+	v3s16 getSizeBlocks() const
 	{
 		v3f s = getSize();
 		return v3s16(MYMAX(s.X+0.5,1.0),MYMAX(s.Y+0.5,1.0),MYMAX(s.Z+0.5,1.0));
 	}
 
 	void getAnimationFrames(MobAnimation type, int *start, int *end);
 	void setAnimationFrames(MobAnimation type, int start, int end);
 	void setTexture(std::string name) {texture = name;}
 
 #ifdef SERVER
-	void setBoxTexture(u16 i, std::string name, u8 alpha=255)
-	{}
-	void setAllBoxTextures(std::string name, u8 alpha=255)
-	{}
+	void setBoxTexture(u16 i, std::string name, u8 alpha=255) {}
+	void setAllBoxTextures(std::string name, u8 alpha=255) {}
 #else
 	void setBoxTexture(u16 i, std::string name, u8 alpha=255);
 
 	void setAllBoxTextures(std::string name, u8 alpha=255)
 	{
@@ -194,20 +204,20 @@
 			setBoxTexture(i, name, alpha);
 		}
 	}
 #endif
 
+    private:
+	
 	void reset()
 	{
-		content = CONTENT_IGNORE;
-		description = (char*)"";
-		texture = "";
-		texture_display = MDT_AUTO;
-		model = "";
-		model_scale = v3f(1.0,1.0,1.0);
-		model_offset = v3f(0,0,0);
+		content = CONTENT_IGNORE;description = "";level = MOB_NONE;
+		texture = "";texture_display = MDT_AUTO;
+		model = "";model_scale = v3f(1.0,1.0,1.0);model_offset = v3f(0,0,0);
 		model_rotation = v3f(0,0,0);
+		collisionbox = aabb3f(-0.5*BS,0.,-0.5*BS,0.5*BS,BS,0.5*BS);
+		
 		punch_action = MPA_DIE;
 		motion_type = MMT_WALK;
 		motion = MM_STATIC;
 		angry_motion = MM_STATIC;
 		static_thrown_speed = 20.0;
@@ -229,23 +239,68 @@
 		special_dropped_max = 0;
 		contact_explosion_diameter = 0;
 		contact_place_node = CONTENT_IGNORE;
 		contact_drop_item = CONTENT_IGNORE;
 		moves_silently = false;
+		
 		sound_spawn = "";
 		sound_death = "";
 		sound_attack = "";
 		sound_punch = "mob-dig";
 		sound_random = "";
 		sound_random_extra = "";
+		
 		spawn_min_height = -20000;
 		spawn_max_height = 100;
 		spawn_chance = 1;
 		spawn_group = 1;
 		spawn_water = false;
+		
 		spawn_naturally = true;
 	}
+
+	void copie(const MobFeatures& m)
+	{
+		content = m.content;description = m.description;level = m.level;
+		texture = m.texture;texture_display = m.texture_display;
+		model = m.model;model_scale = m.model_scale;
+		model_offset = m.model_offset;model_rotation = m.model_rotation;
+		collisionbox = m.collisionbox;
+		
+		punch_action = m.punch_action;motion_type = m.motion_type;motion = m.motion;
+		angry_motion = m.angry_motion;
+		static_thrown_speed = m.static_thrown_speed;
+		follow_item = m.follow_item;tamed_mob = m.tamed_mob;
+		attack_throw_object = m.attack_throw_object;
+		attack_throw_offset = m.attack_throw_offset;
+		attack_player_damage = m.attack_player_damage;
+		attack_player_range = m.attack_player_range;
+		attack_mob_damage = m.attack_mob_damage;
+		attack_mob_range = m.attack_mob_range;
+		glow_light = m.glow_light;attack_glow_light = m.attack_glow_light;
+		hp = m.hp;dropped_item = m.dropped_item;
+		special_punch_item = m.special_punch_item;
+		special_dropped_item = m.special_dropped_item;
+		special_dropped_count = m.special_dropped_count;
+		special_dropped_max = m.special_dropped_max;
+		contact_explosion_diameter = m.contact_explosion_diameter;
+		contact_place_node = m.contact_place_node;
+		contact_drop_item = m.contact_drop_item;
+		moves_silently = m.moves_silently;
+		
+		sound_spawn = m.sound_spawn;sound_death = m.sound_death;
+		sound_attack = m.sound_attack;sound_punch = m.sound_punch;
+		sound_random = m.sound_random;sound_random_extra = m.sound_random_extra;
+		
+		spawn_min_height = m.spawn_min_height;
+		spawn_max_height = m.spawn_max_height;
+		spawn_chance = m.spawn_chance;
+		spawn_group = m.spawn_group;
+		spawn_water = m.spawn_water;
+		
+		spawn_naturally = m.spawn_naturally;
+	}
 };
 
 inline u8 mobLevelI(std::string level)
 {
 	if (level == "destructive")
@@ -297,8 +352,8 @@
 #define CONTENT_MOB_SIAMESE_KITTY (CONTENT_MOB_MASK | 0x12)
 #define CONTENT_MOB_GINGER_KITTY (CONTENT_MOB_MASK | 0x13)
 #define CONTENT_MOB_SHEARED_SHEEP (CONTENT_MOB_MASK | 0x14)
 
 // increment me if you add a mob!
-#define CONTENT_MOB_COUNT 21
+#define CONTENT_MOB_COUNT 20
 
 #endif
diff -rU5 voxelands-v1709.00old/src/content_sao.cpp voxelands-v1709.00good/src/content_sao.cpp
--- voxelands-v1709.00old/src/content_sao.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_sao.cpp	2024-09-22 18:41:01.706655795 +0200
@@ -94,10 +94,11 @@
 	m_hp(10),
 	m_angry(false),
 	m_special_count(0),
 	m_tamed_chance(0),
 	m_disturb_timer(100000),
+	m_disturbing_player(),
 	m_random_disturb_timer(0),
 	m_walk_around(false),
 	m_walk_around_timer(0),
 	m_shoot_reload_timer(0),
 	m_shooting(false),
@@ -125,10 +126,11 @@
 	m_hp(10),
 	m_angry(false),
 	m_special_count(0),
 	m_tamed_chance(0),
 	m_disturb_timer(100000),
+	m_disturbing_player(),
 	m_random_disturb_timer(0),
 	m_walk_around(false),
 	m_walk_around_timer(0),
 	m_shoot_reload_timer(0),
 	m_shooting(false),
@@ -205,11 +207,11 @@
 	writeU8(os,(u8)m_shooting);
 	return os.str();
 }
 void MobSAO::step(float dtime, bool send_recommended)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	Player *disturbing_player = NULL;
 	v3f disturbing_player_off = v3f(0,1,0);
 	v3f disturbing_player_norm = v3f(0,1,0);
 	float disturbing_player_distance = 1000000;
 	float disturbing_player_dir = 0;
@@ -540,11 +542,11 @@
 	if (m_base_position.getDistanceFrom(m_last_sent_position) > 0.5*BS)
 		sendPosition();
 }
 void MobSAO::stepMotionWander(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 	v3s16 pos_size_off(0,0,0);
 
 	if (m.motion_type == MMT_WALK) {
 		if (!m_next_pos_exists) {
@@ -704,11 +706,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionSeeker(float dtime, float offset)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 	Player *disturbing_player = m_env->getPlayer(m_disturbing_player.c_str());
 	if (!disturbing_player) {
 		m_next_pos_exists = false;
 		return;
@@ -900,11 +902,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionFlee(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 	Player *disturbing_player = m_env->getPlayer(m_disturbing_player.c_str());
 	if (!disturbing_player) {
 		m_next_pos_exists = false;
 		return;
@@ -1073,11 +1075,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionSentry(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 
 	if (m.motion_type == MMT_WALK) {
 		if (!m_next_pos_exists) {
 			/* Check whether to drop down */
@@ -1212,11 +1214,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionThrown(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	m_base_position += m_speed * dtime;
 	m_speed.Y -= 10.0*BS*dtime;
 
 	m_yaw = wrapDegrees_180(180./PI*atan2(m_speed.Z, m_speed.X));
 
@@ -1239,11 +1241,12 @@
 		return;
 	}
 }
 void MobSAO::stepMotionConstant(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
+	
 	m_base_position += m_speed * dtime;
 
 	m_yaw = wrapDegrees_180(180./PI*atan2(m_speed.Z, m_speed.X));
 
 	v3s16 pos_i = floatToInt(m_base_position, BS);
@@ -1341,12 +1344,13 @@
 	}
 	map->dispatchEvent(&event);
 }
 InventoryItem* MobSAO::createPickedUpItem(content_t punch_item)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	ToolItemFeatures f = content_toolitem_features(punch_item);
+	
 	if (m.punch_action != MPA_PICKUP) {
 		if (!m_removed) {
 			if (m.special_dropped_item != CONTENT_IGNORE && (m.special_punch_item == TT_NONE || f.type == m.special_punch_item)) {
 				if (m.special_dropped_max > 0) {
 					if (m_special_count < m.special_dropped_count)
@@ -1372,11 +1376,12 @@
 		m_removed = true;
 	return item;
 }
 u16 MobSAO::punch(content_t punch_item, v3f dir, const std::string &playername)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
+	
 	if (m.sound_punch != "")
 		m_env->addEnvEvent(ENV_EVENT_SOUND,m_base_position,m.sound_punch);
 	if (m.punch_action == MPA_IGNORE)
 		return 0;
 	ToolItemFeatures f = content_toolitem_features(punch_item);
@@ -1437,11 +1442,11 @@
 {
 	// so get the player
 	if (!player)
 		return false;
 	// see if mob is tamable
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	if (m.tamed_mob == CONTENT_IGNORE)
 		return false;
 	// get the wielded item
 	u16 item_i = player->getSelectedItem();
 	InventoryList *ilist = player->inventory.getList("main");
diff -rU5 voxelands-v1709.00old/src/crypto_base64.c voxelands-v1709.00good/src/crypto_base64.c
--- voxelands-v1709.00old/src/crypto_base64.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/crypto_base64.c	2024-09-22 18:41:01.706655795 +0200
@@ -184,11 +184,11 @@
 
 		/* convert the characters */
 		tmplen = s_base64_decode_triple((unsigned char*)quadruple, (unsigned char*)tmpresult);
 
 		/* check if the fit in the result buffer */
-		if (targetlen < tmplen) {
+		if (targetlen < (size_t) tmplen) {
 			free(src);
 			return -1;
 		}
 
 		/* put the partial result in the result buffer */
diff -rU5 voxelands-v1709.00old/src/environment.cpp voxelands-v1709.00good/src/environment.cpp
--- voxelands-v1709.00old/src/environment.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/environment.cpp	2024-10-27 17:40:31.935982467 +0100
@@ -397,11 +397,13 @@
 			player->serialize(os);
 			nvp_set(&saved_players, (char*)player->getName(), (char*)player->getName(), player);
 		}
 		list_file = list_file->next;
 	}
-
+	
+	path_dirlist_free(list);
+	
 	for (i=0; i<m_players->length; i++) {
 		player = (Player*)array_get_ptr(m_players,i);
 		if (!player)
 			continue;
 		if (nvp_get(&saved_players, (char*)player->getName()) != NULL)
@@ -425,11 +427,10 @@
 			nvp_set(&saved_players, (char*)player->getName(), (char*)player->getName(), player);
 		}
 	}
 
 	nvp_free(&saved_players,0);
-
 }
 
 void ServerEnvironment::deSerializePlayers()
 {
 
@@ -598,19 +599,23 @@
 	std::vector<u16> objects_to_remove;
 	for (std::map<u16, ServerActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++) {
 		ServerActiveObject* obj = i->second;
 		u16 id = i->first;
 		// Delete static object if block is loaded
-		if (obj->m_static_exists) {
-			MapBlock *block = m_map->getBlockNoCreateNoEx(obj->m_static_block);
-			if (block) {
+		if (obj->m_static_exists)
+		{
+			MapBlock* const block = m_map->getBlockNoCreateNoEx(obj->m_static_block);
+			if (block)
+			{
 				block->m_active_objects.remove(id);
 				obj->m_static_exists = false;
+				block->ResetCurrent();
 			}
 		}
 		// If known by some client, don't delete immediately
-		if (obj->m_known_by_count > 0) {
+		if (obj->m_known_by_count > 0)
+		{
 			obj->m_pending_deactivation = true;
 			obj->m_removed = true;
 			continue;
 		}
 		// Delete active object
@@ -635,11 +640,11 @@
 	u32 num_blocks_checked = 0;
 	u32 num_blocks_cleared = 0;
 	u32 num_objs_cleared = 0;
 	for (core::list<v3s16>::Iterator i = loadable_blocks.begin(); i != loadable_blocks.end(); i++) {
 		v3s16 p = *i;
-		MapBlock *block = m_map->emergeBlock(p, false);
+		MapBlock* const block = m_map->emergeBlock(p, false);
 		if (!block)
 			continue;
 
 		u32 num_stored = block->m_static_objects.m_objects.size();
 		u32 num_active = block->m_active_objects.size();
@@ -650,72 +655,87 @@
 			num_objs_cleared += num_stored + num_active;
 			num_blocks_cleared++;
 		}
 		num_blocks_checked++;
 
-		if (num_blocks_checked % report_interval == 0) {
+		if (num_blocks_checked % report_interval == 0)
+		{
 			float percent = 100.0 * (float)num_blocks_checked/loadable_blocks.size();
 			infostream<<"ServerEnvironment::clearAllObjects(): "
 					<<"Cleared "<<num_objs_cleared<<" objects"
 					<<" in "<<num_blocks_cleared<<" blocks ("
 					<<percent<<"%)"<<std::endl;
 		}
+		block->ResetCurrent();
 	}
 	infostream<<"ServerEnvironment::clearAllObjects(): "
 			<<"Finished: Cleared "<<num_objs_cleared<<" objects"
 			<<" in "<<num_blocks_cleared<<" blocks"<<std::endl;
 }
 
 bool ServerEnvironment::searchNear(v3s16 pos, v3s16 radius_min, v3s16 radius_max, std::vector<content_t> c, v3s16 *found)
 {
 	v3s16 blockpos = getNodeBlockPos(pos);
-	MapBlock *block = m_map->getBlockNoCreateNoEx(blockpos);
-	if (block == NULL)
+	MapBlock* const block = m_map->getBlockNoCreateNoEx(blockpos);
+	if (!block)
 		return false;
 	v3s16 relpos = blockpos*MAP_BLOCKSIZE;
 	v3s16 p;
 	v3s16 bp;
 
-	for(s16 x=radius_min.X; x<=radius_max.X; x++) {
-		for(s16 y=radius_min.Y; y<=radius_max.Y; y++) {
-			for(s16 z=radius_min.Z; z<=radius_max.Z; z++) {
+	for(s16 x=radius_min.X; x<=radius_max.X; x++)
+	{
+		for(s16 y=radius_min.Y; y<=radius_max.Y; y++)
+		{
+			for(s16 z=radius_min.Z; z<=radius_max.Z; z++)
+			{
 				if (!x && !y && !z)
 					continue;
 				p = pos+v3s16(x,y,z);
 				MapNode n_test;
 				bp = getNodeBlockPos(p);
-				if (bp == blockpos) {
+				if (bp == blockpos)
+				{
 					bool pos_ok;
 					n_test = block->getNodeNoCheck(p-relpos,&pos_ok);
-				}else{
-					n_test = m_map->getNodeNoEx(p);
 				}
-				for (std::vector<content_t>::iterator i=c.begin(); i != c.end(); i++) {
-					if (n_test.getContent() == *i) {
+				else
+					n_test = m_map->getNodeNoEx(p);
+				for (std::vector<content_t>::iterator i=c.begin(); i != c.end(); i++)
+				{
+					if (n_test.getContent() == *i)
+					{
 						if (found != NULL)
 							*found = p;
 						return true;
 					}
 				}
 			}
 		}
 	}
+
+	block->ResetCurrent();
 	return false;
 }
 
 bool ServerEnvironment::searchNearInv(v3s16 pos, v3s16 radius_min, v3s16 radius_max, std::vector<content_t> c, v3s16 *found)
 {
 	v3s16 blockpos = getNodeBlockPos(pos);
-	MapBlock *block = m_map->getBlockNoCreateNoEx(blockpos);
-	if (block == NULL)
+	MapBlock* const block = m_map->getBlockNoCreateNoEx(blockpos);
+	if (!block)
 		return false;
+	
 	v3s16 relpos = blockpos*MAP_BLOCKSIZE;
 	v3s16 p;
 	v3s16 bp;
-	for(s16 x=radius_min.X; x<=radius_max.X; x++) {
-		for(s16 y=radius_min.Y; y<=radius_max.Y; y++) {
-			for(s16 z=radius_min.Z; z<=radius_max.Z; z++) {
+	
+	for(s16 x=radius_min.X; x<=radius_max.X; x++)
+	{
+		for(s16 y=radius_min.Y; y<=radius_max.Y; y++)
+		{
+			for(s16 z=radius_min.Z; z<=radius_max.Z; z++)
+			{
 				if (!x && !y && !z)
 					continue;
 				p = pos+v3s16(x,y,z);
 				MapNode n_test;
 				bp = getNodeBlockPos(p);
@@ -738,10 +758,12 @@
 					return true;
 				}
 			}
 		}
 	}
+	
+	block->ResetCurrent();
 	return false;
 }
 
 /* search from pos in direction dir, until a collidable node is hit
  * if pos is a collidable node, then search till not collidable
@@ -881,28 +903,34 @@
 					item = list->addItem(item);
 			}
 		}
 	}
 
-	if (!item) {
+	if (!item)
+	{
 		v3s16 bp = getNodeBlockPos(ppos);
-		MapBlock *block = m_map->getBlockNoCreateNoEx(bp);
-		if (block) {
+		MapBlock* const block = m_map->getBlockNoCreateNoEx(bp);
+		if (block)
+		{
 			MapEditEvent event;
 			event.type = MEET_BLOCK_NODE_METADATA_CHANGED;
 			event.p = bp;
 			m_map->dispatchEvent(&event);
 
 			block->setChangedFlag();
+			block->ResetCurrent();
 		}
 		return true;
 	}
 
 	// if underground, go up to first air_equivalent and buildable_to
-	if (!content_features(m_map->getNodeNoEx(pos).getContent()).air_equivalent) {
-		if (!getCollidedPosition(pos,v3s16(0,1,0),&ppos)) {
-			if (!searchNear(pos,v3s16(2,0,2),CONTENT_AIR,&ppos)) {
+	if (!content_features(m_map->getNodeNoEx(pos).getContent()).air_equivalent)
+	{
+		if (!getCollidedPosition(pos,v3s16(0,1,0),&ppos))
+		{
+			if (!searchNear(pos,v3s16(2,0,2),CONTENT_AIR,&ppos))
+			{
 				delete item;
 				return false;
 			}
 		}
 		pos = ppos;
@@ -916,43 +944,52 @@
 		}
 		pos = ppos;
 	}
 
 	// look for a parcel near pos
-	if (searchNear(pos,v3s16(3,3,3),CONTENT_PARCEL,&ppos)) {
+	if (searchNear(pos,v3s16(3,3,3),CONTENT_PARCEL,&ppos))
+	{
 		// add items if found
 		meta = m_map->getNodeMetadata(ppos);
-		if (meta) {
+		if (meta)
+		{
 			inv = meta->getInventory();
-			if (inv) {
+			if (inv)
+			{
 				list = inv->getList("0");
 				if (list)
 					item = list->addItem(item);
 			}
 		}
 	}
 
 	if (!item) {
 		v3s16 bp = getNodeBlockPos(ppos);
-		MapBlock *block = m_map->getBlockNoCreateNoEx(bp);
-		if (block) {
+		MapBlock* const block = m_map->getBlockNoCreateNoEx(bp);
+		if (block)
+		{
 			MapEditEvent event;
 			event.type = MEET_BLOCK_NODE_METADATA_CHANGED;
 			event.p = bp;
 			m_map->dispatchEvent(&event);
 
 			block->setChangedFlag();
+			block->ResetCurrent();
 		}
 		return true;
 	}
 
 	// if liquid, do a slightly wider search for a parcel on shore
-	if (content_features(m_map->getNodeNoEx(pos).getContent()).liquid_type != LIQUID_NONE) {
-		if (content_features(m_map->getNodeNoEx(pos).getContent()).damage_per_second > 0) {
+	if (content_features(m_map->getNodeNoEx(pos).getContent()).liquid_type != LIQUID_NONE)
+	{
+		if (content_features(m_map->getNodeNoEx(pos).getContent()).damage_per_second > 0)
+		{
 			delete item;
 			return false;
-		}else if (searchNear(pos,v3s16(5,5,5),CONTENT_PARCEL,&ppos)) {
+		}
+		else if (searchNear(pos,v3s16(5,5,5),CONTENT_PARCEL,&ppos))
+		{
 			// add items if found
 			meta = m_map->getNodeMetadata(ppos);
 			if (meta) {
 				inv = meta->getInventory();
 				if (inv) {
@@ -964,18 +1001,20 @@
 		}
 	}
 
 	if (!item) {
 		v3s16 bp = getNodeBlockPos(ppos);
-		MapBlock *block = m_map->getBlockNoCreateNoEx(bp);
-		if (block) {
+		MapBlock* const block = m_map->getBlockNoCreateNoEx(bp);
+		if (block)
+		{
 			MapEditEvent event;
 			event.type = MEET_BLOCK_NODE_METADATA_CHANGED;
 			event.p = bp;
 			m_map->dispatchEvent(&event);
 
 			block->setChangedFlag();
+			block->ResetCurrent();
 		}
 		return true;
 	}
 
 	// check that pos is air_equivalent and buildable_to
@@ -998,18 +1037,20 @@
 		}
 	}
 
 	if (!item) {
 		v3s16 bp = getNodeBlockPos(pos);
-		MapBlock *block = m_map->getBlockNoCreateNoEx(bp);
-		if (block) {
+		MapBlock* const block = m_map->getBlockNoCreateNoEx(bp);
+		if (block)
+		{
 			MapEditEvent event;
 			event.type = MEET_BLOCK_NODE_METADATA_CHANGED;
 			event.p = bp;
 			m_map->dispatchEvent(&event);
 
 			block->setChangedFlag();
+			block->ResetCurrent();
 		}
 		return true;
 	}
 
 	delete item;
@@ -1178,64 +1219,74 @@
 		*/
 
 		// Convert active objects that are no more in active blocks to static
 		deactivateFarObjects(false);
 
-		for (std::set<v3s16>::iterator i = blocks_removed.begin(); i != blocks_removed.end(); i++) {
+		for (std::set<v3s16>::iterator i = blocks_removed.begin(); i != blocks_removed.end(); i++)
+		{
 			v3s16 p = *i;
 
 			/*infostream<<"Server: Block ("<<p.X<<","<<p.Y<<","<<p.Z
 					<<") became inactive"<<std::endl;*/
 
-			MapBlock *block = m_map->getBlockNoCreateNoEx(p);
-			if (block == NULL)
+			MapBlock* const block = m_map->getBlockNoCreateNoEx(p);
+			if (!block)
 				continue;
 
 			// Set current time as timestamp (and let it set ChangedFlag)
 			block->setTimestamp(m_game_time);
+			block->ResetCurrent();
 		}
 
 		/*
 			Handle added blocks
 		*/
 
-		for (std::set<v3s16>::iterator i = blocks_added.begin(); i != blocks_added.end(); i++) {
+		for (std::set<v3s16>::iterator i = blocks_added.begin(); i != blocks_added.end(); i++)
+		{
 			v3s16 p = *i;
 
 			/*infostream<<"Server: Block ("<<p.X<<","<<p.Y<<","<<p.Z
 					<<") became active"<<std::endl;*/
 
-			MapBlock *block = m_map->emergeBlock(p,false);
-			if (block == NULL)
+			MapBlock* const block = m_map->emergeBlock(p,false);
+			if (!block)
 				continue;
 
 			activateBlock(block);
+			block->ResetCurrent();
 		}
 	}
 
 	/*
 		Mess around in active blocks
 	*/
 	bool circuitstep = m_active_blocks_circuit_interval.step(dtime, 0.5);
 	bool metastep = m_active_blocks_nodemetadata_interval.step(dtime, 1.0);
 	bool nodestep = m_active_blocks_test_interval.step(dtime, 10.0);
 
-	if (circuitstep || metastep || nodestep) {
+	if (circuitstep || metastep || nodestep)
+	{
 		float circuit_dtime = 0.5;
 		float meta_dtime = 1.0;
 		u16 season = getSeason();
 		uint16_t time = getTimeOfDay();
 		bool unsafe_fire = config_get_bool("world.game.environment.fire.spread");
-		for (std::set<v3s16>::iterator i = m_active_blocks.m_list.begin(); i != m_active_blocks.m_list.end(); i++) {
+		
+		for (std::set<v3s16>::iterator i = m_active_blocks.m_list.begin();
+		     i != m_active_blocks.m_list.end(); i++)
+		{
 			v3s16 bp = *i;
 
-			MapBlock *block = m_map->getBlockNoCreateNoEx(bp);
-			if (block == NULL)
+			MapBlock* const block = m_map->getBlockNoCreateNoEx(bp);
+			if (!block)
 				continue;
 
 			std::list<u16> new_list;
-			for (std::list<u16>::iterator oi = block->m_active_objects.begin(); oi != block->m_active_objects.end(); oi++) {
+			for (std::list<u16>::iterator oi = block->m_active_objects.begin();
+			     oi != block->m_active_objects.end(); oi++)
+			{
 				ServerActiveObject *obj = getActiveObject(*oi);
 				if (obj && obj->m_static_exists && obj->m_static_block == block->getPos())
 					new_list.push_back(*oi);
 			}
 			block->m_active_objects.swap(new_list);
@@ -1249,35 +1300,40 @@
 
 			bool blockchanged = false;
 
 			m_poststep_nodeswaps.clear();
 
-			if (circuitstep) {
+			if (circuitstep)
+			{
 				// Run node metadata
 				bool changed = block->m_node_metadata.stepCircuit(circuit_dtime, block->getPosRelative(), this);
 				if (changed)
 					blockchanged = true;
 			}
 
-			if (metastep) {
+			if (metastep)
+			{
 				// Run node metadata
 				bool changed = block->m_node_metadata.step(meta_dtime, block->getPosRelative(), this);
 				if (changed)
 					blockchanged = true;
 			}
 
-			if (blockchanged) {
+			if (blockchanged)
+			{
 				MapEditEvent event;
 				event.type = MEET_BLOCK_NODE_METADATA_CHANGED;
 				event.p = bp;
 				m_map->dispatchEvent(&event);
 
 				block->setChangedFlag();
 			}
 
-			if (m_poststep_nodeswaps.size() > 0) {
-				for (std::map<v3s16,MapNode>::iterator i = m_poststep_nodeswaps.begin(); i != m_poststep_nodeswaps.end(); i++) {
+			if (m_poststep_nodeswaps.size() > 0)
+			{
+				for (std::map<v3s16,MapNode>::iterator i = m_poststep_nodeswaps.begin();
+				     i != m_poststep_nodeswaps.end(); i++) {
 					v3s16 sp = i->first;
 					MapNode n = i->second;
 					NodeMetadata *meta = NULL;
 					std::string n_owner = "";
 					std::string i_owner = "";
@@ -1318,37 +1374,38 @@
 
 				Everything should bind to inside this single content
 				searching loop to keep things fast.
 			*/
 
-			if (block->last_spawn < m_time_of_day-6000) {
+			if (block->last_spawn < m_time_of_day-6000)
+			{
 				MapNode n1 = block->getNodeNoEx(block->spawn_area+v3s16(0,1,0));
 				MapNode n2 = block->getNodeNoEx(block->spawn_area+v3s16(0,2,0));
 				u8 light = n1.getLightBlend(getDayNightRatio());
-				if (
-					!content_features(n1.getContent()).air_equivalent
-					|| !content_features(n2.getContent()).air_equivalent
-				)
+				if (!content_features(n1.getContent()).air_equivalent
+						|| !content_features(n2.getContent()).air_equivalent)
 					block->has_spawn_area = false;
 
-				if (block->has_spawn_area && m_time_of_day > 19000 && m_time_of_day < 20000) {
-					if (light <= LIGHT_SPAWN_DARK) {
-						if (
-							block->getPos().Y > 0
-							|| myrand_range(0,5) == 0
-						) {
+				if (block->has_spawn_area && m_time_of_day > 19000 && m_time_of_day < 20000)
+				{
+					if (light <= LIGHT_SPAWN_DARK)
+					{
+						if (block->getPos().Y > 0 || myrand_range(0,5) == 0)
+						{
 							mob_spawn_hostile(block->spawn_area+block->getPosRelative(),false,this);
 						}
 					}
 					block->last_spawn = m_time_of_day;
 				}
 			}
 
 			v3s16 p0;
 			uint8_t biome = block->getBiome();
 			bool coldzone = false;
-			switch (biome) {
+			
+			switch (biome)
+			{
 			case BIOME_JUNGLE:
 				if (season == ENV_SEASON_WINTER && time > 4000 && time < 8000)
 					coldzone = true;
 				break;
 			case BIOME_OCEAN:
@@ -1391,37 +1448,35 @@
 				if (season == ENV_SEASON_WINTER)
 					coldzone = true;
 			default:
 				break;
 			}
+			
 			for (p0.X=0; p0.X<MAP_BLOCKSIZE; p0.X++)
 			for (p0.Y=0; p0.Y<MAP_BLOCKSIZE; p0.Y++)
 			for (p0.Z=0; p0.Z<MAP_BLOCKSIZE; p0.Z++) {
 				v3s16 p = p0 + block->getPosRelative();
 				block->incNodeTicks(p0);
 				MapNode n = block->getNodeNoEx(p0);
-				if (
-					!block->has_spawn_area
-					&& (
-						content_features(n.getContent()).draw_type == CDT_DIRTLIKE
+				if (!block->has_spawn_area
+					&& (content_features(n.getContent()).draw_type == CDT_DIRTLIKE
 						|| n.getContent() == CONTENT_SAND
-						|| n.getContent() == CONTENT_STONE
-					)
-				) {
+						|| n.getContent() == CONTENT_STONE))
+				{
 					MapNode n1 = block->getNodeNoEx(p0+v3s16(0,1,0));
 					MapNode n2 = block->getNodeNoEx(p0+v3s16(0,2,0));
-					if (
-						content_features(n1.getContent()).air_equivalent
+					if (content_features(n1.getContent()).air_equivalent
 						&& content_features(n2.getContent()).air_equivalent
-						&& myrand_range(0,5) == 0
-					) {
+						&& myrand_range(0,5) == 0)
+					{
 						block->spawn_area = p0;
 						block->has_spawn_area = true;
 					}
 				}
 
-				switch(n.getContent()) {
+				switch(n.getContent())
+				{
 	/*
 	 * param1:
 	 * 	top nibble:
 	 * 		0 - no effect
 	 * 		1 - footsteps
@@ -3053,35 +3108,27 @@
 					}
 					break;
 				}
 				}
 
-				if (
-					coldzone
-					&& biome != BIOME_BEACH
-					&& (
-						content_features(n).draw_type == CDT_CUBELIKE
+				if (coldzone && biome != BIOME_BEACH
+					&& (content_features(n).draw_type == CDT_CUBELIKE
 						|| content_features(n).draw_type == CDT_GLASSLIKE
-						|| (
-							content_features(n).draw_type == CDT_DIRTLIKE
+						|| (content_features(n).draw_type == CDT_DIRTLIKE
 							&& (n.param1&0x20) != 0x20
-							&& (
-								(n.param1&0x0F) == 0x00
-								|| (n.param1&0x0F) == 0x04
-							)
-						)
-					)
-				) {
-					if (myrand()%20 == 0) {
+							&& ((n.param1&0x0F) == 0x00
+								|| (n.param1&0x0F) == 0x04))))
+				{
+					if (myrand()%20 == 0)
+					{
 						std::vector<content_t> search;
 						search.push_back(CONTENT_AIR);
 						// check that it's on top, and somewhere snow could fall
 						// not 100% because torches
-						if (
-							!searchNearInv(p,v3s16(0,1,0),v3s16(0,16,0),search,NULL)
-							&& !searchNear(p,v3s16(3,3,3),CONTENT_FIRE,NULL)
-						) {
+						if (!searchNearInv(p,v3s16(0,1,0),v3s16(0,16,0),search,NULL)
+							&& !searchNear(p,v3s16(3,3,3),CONTENT_FIRE,NULL))
+						{
 							MapNode nn(CONTENT_SNOW);
 							m_map->addNodeWithEvent(p+v3s16(0,1,0),nn);
 							//n.param1 &= ~0x0F;
 							//n.param1 |= 0x04;
 							//n.envticks = 0;
@@ -3089,14 +3136,19 @@
 						}
 					}
 				}
 			}
 
-			for (std::map<v3s16,MapNode>::iterator it = m_delayed_node_changes.begin(); it != m_delayed_node_changes.end(); it++) {
+			for (std::map<v3s16,MapNode>::iterator it = m_delayed_node_changes.begin();
+			     it != m_delayed_node_changes.end(); it++)
+			{
 				m_map->addNodeWithEvent(it->first, it->second);
 			}
 			m_delayed_node_changes.clear();
+
+			if(block)
+			    block->ResetCurrent();		
 		}
 	}
 
 	/*
 		Step active objects
@@ -3116,10 +3168,14 @@
 			send_recommended = true;
 		}
 
 		for (std::map<u16, ServerActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++) {
 			ServerActiveObject* obj = i->second;
+
+			if(!obj)
+			    continue;
+			
 			// Remove non-peaceful mobs on peaceful mode
 			if (obj->level() > mob_level)
 				obj->m_removed = true;
 			// Don't step if is to be removed or stored statically
 			if (obj->m_removed)
@@ -3163,14 +3219,17 @@
 void ServerEnvironment::getActiveObjects(v3f origin, f32 max_d, core::array<DistanceSortedActiveObject> &dest)
 {
 	for (std::map<u16, ServerActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++) {
 		ServerActiveObject* obj = i->second;
 
+		if(!obj)
+		    continue;
+		
 		f32 d = (obj->getBasePosition() - origin).getLength();
 
 		if (d > max_d)
-			continue;
+		    continue;
 
 		DistanceSortedActiveObject dso(obj, d);
 
 		dest.push_back(dso);
 	}
@@ -3626,19 +3685,23 @@
 			<<m_active_objects.size()<<" active objects."
 			<<std::endl;
 
 	// Add to the block where the object is located in
 	v3s16 blockpos = getNodeBlockPos(floatToInt(object->getBasePosition(), BS));
-	MapBlock *block = m_map->getBlockNoCreateNoEx(blockpos);
-	if (block) {
+	MapBlock* const block = m_map->getBlockNoCreateNoEx(blockpos);
+	if (block)
+	{
 		block->m_active_objects.push_back(object->getId());
 		object->m_static_exists = true;
 		object->m_static_block = blockpos;
 
 		if (set_changed)
 			block->raiseModified(MOD_STATE_WRITE_NEEDED);
-	}else{
+		block->ResetCurrent();
+	}
+	else
+	{
 		errorstream<<"ServerEnvironment::addActiveObjectRaw(): "
 				<<"could not find block for storing id="<<object->getId()
 				<<" statically"<<std::endl;
 	}
 
@@ -3665,31 +3728,40 @@
 
 		/*
 			We will delete objects that are marked as removed
 			and are not known by clients
 		*/
-		if (obj->m_removed == false) {
+		if (obj->m_removed == false)
+		{
 			// enforce static data
-			if (obj->m_static_exists) {
-				MapBlock *block = m_map->emergeBlock(obj->m_static_block, false);
-				if (block) {
+			if (obj->m_static_exists)
+			{
+				MapBlock* const block = m_map->emergeBlock(obj->m_static_block, false);
+				if (block)
+				{
 					bool keep = false;
-					for (std::list<u16>::iterator oi = block->m_active_objects.begin(); oi != block->m_active_objects.end(); oi++) {
-						if (*oi == id) {
+					for (std::list<u16>::iterator oi = block->m_active_objects.begin();
+					     oi != block->m_active_objects.end(); oi++) {
+						if (*oi == id)
+						{
 							keep = true;
 							break;
 						}
 					}
 					obj->m_static_exists = keep;
+					block->ResetCurrent();
 				}
 			}
-			if (!obj->m_static_exists) {
+			if (!obj->m_static_exists)
+			{
 				obj->m_static_block = getNodeBlockPos(floatToInt(obj->getBasePosition(), BS));
-				MapBlock *block = m_map->emergeBlock(obj->m_static_block, false);
-				if (block) {
+				MapBlock* const block = m_map->emergeBlock(obj->m_static_block, false);
+				if (block)
+				{
 					block->m_active_objects.push_back(id);
 					obj->m_static_exists = true;
+					block->ResetCurrent();
 				}
 			}
 			continue;
 		}
 		if (obj->m_known_by_count > 0) {
@@ -3698,15 +3770,18 @@
 		}
 
 		/*
 			Delete static data from block if is marked as removed
 		*/
-		if (obj->m_static_exists) {
-			MapBlock *block = m_map->emergeBlock(obj->m_static_block, false);
-			if (block) {
+		if (obj->m_static_exists)
+		{
+			MapBlock* const block = m_map->emergeBlock(obj->m_static_block, false);
+			if (block)
+			{
 				obj->m_static_exists = false;
 				block->m_active_objects.remove(id);
+				block->ResetCurrent();
 			}
 		}
 
 		// Delete
 		delete obj;
@@ -3853,53 +3928,63 @@
 		v3f objectpos = obj->getBasePosition();
 
 		// The block in which the object resides in
 		v3s16 blockpos_o = getNodeBlockPos(floatToInt(objectpos, BS));
 
-		if (force_delete) {
+		if (force_delete)
+		{
 			// if it isn't m_removed, then ensure it's stored
-			if (!obj->m_removed) {
+			if (!obj->m_removed)
+			{
 				if (!obj->m_static_exists)
 					obj->m_static_block = blockpos_o;
 
-				MapBlock *block = m_map->emergeBlock(obj->m_static_block, false);
-				if (block) {
+				MapBlock* const block = m_map->emergeBlock(obj->m_static_block, false);
+				if (block)
+				{
 					// create new static object
 					std::string staticdata_new = obj->getStaticData();
 					StaticObject s_obj(obj->getType(), objectpos, staticdata_new);
 					block->m_static_objects.m_objects.push_back(s_obj);
 					block->raiseModified(MOD_STATE_WRITE_NEEDED);
+					block->ResetCurrent();
 				}
 			}
 			// delete active object
 			delete obj;
 			// id to be removed from m_active_objects
 			objects_to_remove.push_back(id);
 			continue;
 		}
 
 		// if object is stored in a different block to where it's located, remove it
-		if (obj->m_static_exists && obj->m_static_block != blockpos_o) {
-			MapBlock *block = m_map->emergeBlock(obj->m_static_block, false);
-			if (block) {
+		if (obj->m_static_exists && obj->m_static_block != blockpos_o)
+		{
+			MapBlock* const block = m_map->emergeBlock(obj->m_static_block, false);
+			if (block)
+			{
 				obj->m_static_exists = false;
 				block->m_active_objects.remove(id);
+				block->ResetCurrent();
 			}
 		}
 
-		if (!obj->m_static_exists) {
+		if (!obj->m_static_exists)
+		{
 			obj->m_static_block = blockpos_o;
 
 			// Save to block where object is located
-			MapBlock *block = m_map->emergeBlock(blockpos_o, false);
-			if (!block) {
+			MapBlock* const block = m_map->emergeBlock(blockpos_o, false);
+			if (!block)
+			{
 				obj->m_removed = true;
 				continue;
 			}
 
 			block->m_active_objects.push_back(id);
 			obj->m_static_exists = true;
+			block->ResetCurrent();
 		}
 
 		// If block is active, don't remove
 		if (!force_delete && m_active_blocks.contains(blockpos_o))
 			continue;
@@ -3920,33 +4005,43 @@
 		// Add to the block where the object is located in
 		v3s16 blockpos = getNodeBlockPos(floatToInt(objectpos, BS));
 		// Get or generate the block
 		MapBlock *block = NULL;
 		bool was_generated = false;
-		try{
+		try
+		{
 			block = m_map->emergeBlock(blockpos,true,&was_generated);
-		} catch(InvalidPositionException &e) {
+		}
+		catch(InvalidPositionException &e)
+		{
 			// Handled via NULL pointer
 			// NOTE: emergeBlock's failure is usually determined by it
 			//       actually returning NULL
 		}
 
-		if (block) {
-			if (block->m_static_objects.m_objects.size() >= 50) {
+		if (block)
+		{
+			if (block->m_static_objects.m_objects.size() >= 50)
+			{
 				errorstream<<"ServerEnv: Trying to store id="<<obj->getId()
 						<<" statically but block "<<PP(blockpos)
 						<<" already contains "
 						<<block->m_static_objects.m_objects.size()
 						<<" objects."
 						<<" Forcing delete."<<std::endl;
 				force_delete = true;
-			}else{
+			}
+			else
+			{
 				// Store static data
 				block->m_static_objects.m_objects.push_back(s_obj);
 				block->raiseModified(MOD_STATE_WRITE_NEEDED);
 			}
-		}else{
+			block->ResetCurrent();
+		}
+		else
+		{
 			if (!force_delete) {
 				v3s16 p = floatToInt(objectpos, BS);
 				errorstream<<"ServerEnv: Could not find or generate "
 						<<"a block for storing id="<<obj->getId()
 						<<" statically (pos="<<PP(p)<<")"<<std::endl;
@@ -4145,23 +4240,28 @@
 				m_client_event_queue.push_back(event);
 			}
 		}
 	}
 
-	if (lplayer->health > 0) {
+	if (lplayer->health > 0)
+	{
 		/* player damage */
-		if (m_damage_interval.step(dtime, 1.0)) {
+		if (m_damage_interval.step(dtime, 1.0))
+		{
 			v3f pf = lplayer->getPosition();
 			v3s16 pp = floatToInt(pf, BS);
 
 			uint32_t time = getTimeOfDay();
 			uint16_t season = getSeason();
 			uint8_t biome = BIOME_UNKNOWN;
-			MapBlock *block = m_map->getBlockNoCreateNoEx(getNodeBlockPos(pp));
+			MapBlock* const block = m_map->getBlockNoCreateNoEx(getNodeBlockPos(pp));
 			if (block)
+			{
 				biome = block->getBiome();
-
+				block->ResetCurrent();
+			}
+			
 			v3f ps[7] = {
 				v3f(0, BS*-0.1, 0),
 				v3f(0, BS*0.1, 0),
 				v3f(0, BS*0.1, 0),
 				v3f(0, BS*0.8, 0),
@@ -4657,95 +4757,117 @@
 }
 
 bool ClientEnvironment::searchNear(v3s16 pos, v3s16 radius_min, v3s16 radius_max, std::vector<content_t> c, v3s16 *found)
 {
 	v3s16 blockpos = getNodeBlockPos(pos);
-	MapBlock *block = m_map->getBlockNoCreateNoEx(blockpos);
-	if (block == NULL)
+	MapBlock* const block = m_map->getBlockNoCreateNoEx(blockpos);
+	if (!block)
 		return false;
 	v3s16 relpos = blockpos*MAP_BLOCKSIZE;
 	v3s16 p;
 	v3s16 bp;
 
-	for(s16 x=radius_min.X; x<=radius_max.X; x++) {
-		for(s16 y=radius_min.Y; y<=radius_max.Y; y++) {
-			for(s16 z=radius_min.Z; z<=radius_max.Z; z++) {
+	for(s16 x=radius_min.X; x<=radius_max.X; x++)
+	{
+		for(s16 y=radius_min.Y; y<=radius_max.Y; y++)
+		{
+			for(s16 z=radius_min.Z; z<=radius_max.Z; z++)
+			{
 				if (!x && !y && !z)
 					continue;
 				p = pos+v3s16(x,y,z);
 				MapNode n_test;
 				bp = getNodeBlockPos(p);
-				if (bp == blockpos) {
+				if (bp == blockpos)
+				{
 					bool pos_ok;
 					n_test = block->getNodeNoCheck(p-relpos,&pos_ok);
-				}else{
-					n_test = m_map->getNodeNoEx(p);
 				}
-				for (std::vector<content_t>::iterator i=c.begin(); i != c.end(); i++) {
-					if (n_test.getContent() == *i) {
+				else
+					n_test = m_map->getNodeNoEx(p);
+
+				for (std::vector<content_t>::iterator i=c.begin(); i != c.end(); i++)
+				{
+					if (n_test.getContent() == *i)
+					{
 						if (found != NULL)
 							*found = p;
 						return true;
 					}
 				}
 			}
 		}
 	}
+	
+	block->ResetCurrent();
 	return false;
 }
 
 bool ClientEnvironment::searchNearInv(v3s16 pos, v3s16 radius_min, v3s16 radius_max, std::vector<content_t> c, v3s16 *found)
 {
 	v3s16 blockpos = getNodeBlockPos(pos);
-	MapBlock *block = m_map->getBlockNoCreateNoEx(blockpos);
-	if (block == NULL)
+	MapBlock* const block = m_map->getBlockNoCreateNoEx(blockpos);
+	if (!block)
 		return false;
 	v3s16 relpos = blockpos*MAP_BLOCKSIZE;
 	v3s16 p;
 	v3s16 bp;
-	for(s16 x=radius_min.X; x<=radius_max.X; x++) {
-		for(s16 y=radius_min.Y; y<=radius_max.Y; y++) {
-			for(s16 z=radius_min.Z; z<=radius_max.Z; z++) {
+	
+	for(s16 x=radius_min.X; x<=radius_max.X; x++)
+	{
+		for(s16 y=radius_min.Y; y<=radius_max.Y; y++)
+		{
+			for(s16 z=radius_min.Z; z<=radius_max.Z; z++)
+			{
 				if (!x && !y && !z)
 					continue;
 				p = pos+v3s16(x,y,z);
 				MapNode n_test;
 				bp = getNodeBlockPos(p);
-				if (bp == blockpos) {
+				if (bp == blockpos)
+				{
 					bool pos_ok;
 					n_test = block->getNodeNoCheck(p-relpos,&pos_ok);
-				}else{
-					n_test = m_map->getNodeNoEx(p);
 				}
+				else
+					n_test = m_map->getNodeNoEx(p);
+
 				bool s = false;
-				for (std::vector<content_t>::iterator i=c.begin(); i != c.end(); i++) {
-					if (n_test.getContent() == *i) {
+				for (std::vector<content_t>::iterator i=c.begin(); i != c.end(); i++)
+				{
+					if (n_test.getContent() == *i)
+					{
 						s = true;
 						break;
 					}
 				}
-				if (!s) {
+				if (!s)
+				{
 					if (found != NULL)
 						*found = p;
 					return true;
 				}
 			}
 		}
 	}
+
+	block->ResetCurrent();
 	return false;
 }
 
 void ClientEnvironment::updateObjectsCameraOffset(v3s16 camera_offset)
 {
-	for (std::map<u16, ClientActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++) {
+	for (std::map<u16, ClientActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++)
+	{
 		ClientActiveObject* obj = i->second;
 		obj->updateCameraOffset(camera_offset);
 	}
 
 	Player *player;
 	uint32_t i;
-	for (i=0; i<m_players->length; i++) {
+	for (i=0; i<m_players->length; i++)
+	{
 		player = (Player*)array_get_ptr(m_players,i);
 		if (!player)
 			continue;
 		if (!player->isLocal())
 			((RemotePlayer*)player)->updateCameraOffset(camera_offset);
diff -rU5 voxelands-v1709.00old/src/environment.h voxelands-v1709.00good/src/environment.h
--- voxelands-v1709.00old/src/environment.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/environment.h	2024-10-27 17:26:32.073895083 +0100
@@ -123,11 +123,11 @@
 	}
 };
 
 class Environment
 {
-public:
+    public:
 	// Environment will delete the map passed to the constructor
 	Environment();
 	virtual ~Environment();
 
 	/*
@@ -147,11 +147,12 @@
 	Player * getRandomConnectedPlayer();
 	Player * getNearestConnectedPlayer(v3f pos);
 	array_t *getPlayers();
 	array_t *getPlayers(bool ignore_disconnected);
 	void printPlayers(std::ostream &o);
-	virtual bool propogateEnergy(u8 level, v3s16 powersrc, v3s16 signalsrc, v3s16 pos, core::map<v3s16,MapBlock*> &modified_blocks) {return false;};
+	virtual bool propogateEnergy(u8 level, v3s16 powersrc, v3s16 signalsrc, v3s16 pos,
+			core::map<v3s16,MapBlock*> &modified_blocks) {return false;};
 
 	u32 getDayNightRatio();
 
 	// 0-23999
 	virtual void setTimeOfDay(u32 time)
@@ -198,11 +199,11 @@
 		m_time = t;
 	}
 
 	u32 getSeason()
 	{
-		char* s = config_get("world.game.environment.season");
+		const char* s = config_get("world.game.environment.season");
 		if (s) {
 			if (!strcmp(s,"summer"))
 				return ENV_SEASON_SUMMER;
 			if (!strcmp(s,"autumn") || !strcmp(s,"fall"))
 				return ENV_SEASON_AUTUMN;
@@ -227,11 +228,11 @@
 	u32 getYearDay()
 	{
 		return m_time%240;
 	}
 
-protected:
+    protected:
 	// peer_ids in here should be unique, except that there may be many 0s
 	array_t *m_players;
 	u32 m_time;
 	// Time of day in milli-hours (0-23999); determines day and night
 	u32 m_time_of_day;
diff -rU5 voxelands-v1709.00old/src/file.c voxelands-v1709.00good/src/file.c
--- voxelands-v1709.00old/src/file.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/file.c	2024-09-22 18:41:01.707655797 +0200
@@ -48,15 +48,15 @@
 
 	return inc;
 }
 
 /* load a file into memory */
-file_t *file_load(char* type, char* name)
+file_t *file_load(const char* type,const char* name)
 {
 	file_t *ft;
 	FILE *f;
-	char* fn;
+	const char* fn;
 	char* path;
 
 	if (type) {
 		fn = name;
 		path = path_get(type,name,1,NULL,0);
@@ -99,11 +99,11 @@
 		fclose(f);
 		free(ft);
 		return NULL;
 	}
 
-	if (ft->len != fread(ft->data, 1, ft->len, f)) {
+	if ((size_t) ft->len != fread(ft->data, 1, ft->len, f)) {
 		free(path);
 		fclose(f);
 		free(ft->data);
 		free(ft);
 		return NULL;
@@ -119,14 +119,14 @@
 
 	return ft;
 }
 
 /* load a file into memory */
-file_t *file_create(char* type, char *name)
+file_t *file_create(const char* type,const char *name)
 {
 	file_t *ft;
-	char* fn;
+	const char* fn;
 	char* path;
 
 	if (name) {
 		if (type) {
 			fn = name;
@@ -193,11 +193,11 @@
 	f = fopen(file->path, "wb");
 	if (!f)
 		return;
 
 	if (file->len) {
-		if (fwrite(file->data,1,file->len,f) != file->len) {
+	    if (fwrite(file->data,1,file->len,f) != (size_t) file->len) {
 			fclose(f);
 			return;
 		}
 	}
 
@@ -380,11 +380,11 @@
 {
 	return file->data+file->pos;
 }
 
 /* write data to a file buffer */
-int file_write(file_t *file, void *buff, int size)
+int file_write(file_t *file,const void *buff, int size)
 {
 	if (!file || !buff || size)
 		return -1;
 
 	if (file->size <= (file->pos+size+1)) {
@@ -407,11 +407,11 @@
 
 	return size;
 }
 
 /* write a formatted string to a file buffer (printf style) */
-int file_writef(file_t *file, char* fmt, ...)
+int file_writef(file_t *file,const char* fmt, ...)
 {
 	va_list ap;
 	int l;
 	int s;
 	if (!file)
diff -rU5 voxelands-v1709.00old/src/file.h voxelands-v1709.00good/src/file.h
--- voxelands-v1709.00old/src/file.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/file.h	2024-09-22 18:41:01.707655797 +0200
@@ -22,12 +22,12 @@
 	int modified;
 } file_t;
 #endif
 
 /* defined in file.c */
-file_t *file_load(char* type, char *name);
-file_t *file_create(char* type, char *name);
+file_t *file_load(const char* type,const char *name);
+file_t *file_create(const char* type,const char *name);
 void file_free(file_t *file);
 void file_flush(file_t *file);
 int file_find(file_t *file, int offset, unsigned char value);
 int file_strfind(file_t *file, int offset, char* value);
 int file_read(file_t *file, void* dst, int size);
@@ -38,12 +38,12 @@
 uint32_t file_read_uint(file_t *file);
 float file_read_float(file_t *file);
 int file_seek(file_t *file, int offset, int origin);
 int file_tell(file_t *file);
 void *file_get(file_t *file);
-int file_write(file_t *file, void *buff, int size);
-int file_writef(file_t *file, char* fmt, ...);
+int file_write(file_t *file,const  void *buff, int size);
+int file_writef(file_t *file,const char* fmt, ...);
 
 #ifdef __cplusplus
 }
 #endif
 
diff -rU5 voxelands-v1709.00old/src/game.cpp voxelands-v1709.00good/src/game.cpp
--- voxelands-v1709.00old/src/game.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/game.cpp	2024-10-27 17:10:07.606152569 +0100
@@ -749,11 +749,11 @@
 		Create server.
 		SharedPtr will delete it when it goes out of scope.
 	*/
 	SharedPtr<Server> server;
 	{
-		char* v = config_get("world.server.address");
+		const char* v = config_get("world.server.address");
 		if (!v || !v[0]) {
 			//draw_load_screen(L"Creating server...", driver, font);
 			drawLoadingScreen(device,narrow_to_wide(gettext("Creating server...")));
 			infostream<<"Creating server"<<std::endl;
 			server = new Server();
@@ -776,11 +776,11 @@
 	port = config_get_int("world.server.port");
 	if (!port)
 		port = 30000;
 	Address connect_address(0,0,0,0, port);
 	try{
-		char* v = config_get("world.server.address");
+		const char* v = config_get("world.server.address");
 		if (!v || !v[0]) {
 			connect_address.setAddress(127,0,0,1);
 		}else{
 			connect_address.Resolve(v);
 		}
@@ -925,11 +925,11 @@
 	show_debug = config_get_bool("debug.show");
 	fps_max = config_get_float("client.graphics.fps.max");
 	profiler_print_interval = config_get_float("debug.profiler.interval");
 	mouse_sensitivity = config_get_float("client.ui.mouse.sensitivity");
 	{
-		char* v = config_get("client.graphics.selection");
+		const char* v = config_get("client.graphics.selection");
 		if (v && !strcmp(v,"outline"))
 			highlight_selected_node = false;
 	}
 	enable_particles = config_get_bool("client.graphics.particles");
 	enable_fog = config_get_bool("client.graphics.light.fog");
@@ -1139,11 +1139,11 @@
 			Launch menus according to keys
 		*/
 		if (input->wasKeyDown(getKeySetting(VLKC_INVENTORY))) {
 			infostream<<"the_game: Launching inventory"<<std::endl;
 
-			GUIFormSpecMenu *menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+			GUIFormSpecMenu* const menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
 
 			InventoryLocation inventoryloc;
 			inventoryloc.setCurrentPlayer();
 
 			PlayerInventoryFormIO *fio = new PlayerInventoryFormIO(&client);
@@ -1475,11 +1475,11 @@
 					if (event.player_damage.amount >= 2) {
 						damage_flash_timer += 0.05 * event.player_damage.amount;
 					}
 #if USE_AUDIO == 1
 					{
-						char* v;
+						const char* v;
 						std::string ch = std::string(PLAYER_DEFAULT_CHARDEF);
 						v = config_get("client.character");
 						if (v)
 							ch = v;
 						Strfnd f(ch);
@@ -1494,14 +1494,14 @@
 					camera_pitch = event.player_force_move.pitch;
 				}else if (event.type == CE_DEATHSCREEN) {
 					if (respawn_menu_active)
 						continue;
 
-					MainRespawnInitiator *respawner =
+					MainRespawnInitiator* const respawner =
 							new MainRespawnInitiator(
 									&respawn_menu_active, &client);
-					GUIDeathScreen *menu =
+					GUIDeathScreen* const menu =
 							new GUIDeathScreen(guienv, guiroot, -1,
 								&g_menumgr, respawner);
 					menu->drop();
 
 					/* Handle visualization */
@@ -1517,11 +1517,10 @@
 		camera.step(dtime);
 
 		v3f player_position = player->getPosition();
 		v3f camera_position = camera.getPosition();
 		v3f camera_direction = camera.getDirection();
-		v3f camera_up = camera.getCameraNode()->getUpVector();
 		f32 camera_fov = camera.getFovMax();
 		v3s16 camera_offset = camera.getOffset();
 
 #if USE_AUDIO == 1
 		{
@@ -1756,11 +1755,12 @@
 							InventoryLocation inventoryloc;
 							inventoryloc.setNodeMeta(nodepos);
 
 							/* Create menu */
 
-							GUIFormSpecMenu *menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+							GUIFormSpecMenu* const menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+							
 							menu->setFormSpec(meta->getDrawSpecString(client.getLocalPlayer()), inventoryloc);
 							menu->setFormIO(new NodeMetadataFormIO(nodepos, &client));
 							menu->drop();
 							{
 								std::string sound = content_features(client.getEnv().getMap().getNodeNoEx(nodepos).getContent()).sound_access;
@@ -1781,11 +1781,13 @@
 									InventoryLocation inventoryloc;
 									inventoryloc.setNodeMeta(nodepos);
 
 									/* Create menu */
 
-									GUIFormSpecMenu *menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+									GUIFormSpecMenu* const menu =
+									    new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+									
 									menu->setFormSpec(ameta->getDrawSpecString(client.getLocalPlayer()), inventoryloc);
 									menu->setFormIO(new NodeMetadataFormIO(npos, &client));
 									menu->drop();
 									{
 										std::string sound = content_features(nn.getContent()).sound_access;
@@ -1850,13 +1852,16 @@
 		bool sunlight_seen = false;
 		uint8_t biome = BIOME_UNKNOWN;
 		{
 			v3f pp = client.getLocalPlayer()->getPosition();
 			v3s16 ppos = floatToInt(pp,BS);
-			MapBlock *block = client.getEnv().getMap().getBlockNoCreateNoEx(getNodeBlockPos(ppos));
-			if (block != NULL)
+			MapBlock* const block = client.getEnv().getMap().getBlockNoCreateNoEx(getNodeBlockPos(ppos));
+			if (block)
+			{
 				biome = block->getBiome();
+				block->ResetCurrent();
+			}
 		}
 		if (biome == BIOME_SPACE || free_move) {
 			direct_brightness = time_brightness;
 			sunlight_seen = true;
 		}else{
@@ -2264,14 +2269,18 @@
 						spos = selected_node_pos;
 					}else{
 						v3f pp = client.getLocalPlayer()->getPosition();
 						spos = floatToInt(pp,BS);
 					}
-					MapBlock *block = client.getEnv().getMap().getBlockNoCreateNoEx(getNodeBlockPos(spos));
+					MapBlock* const block =
+					    client.getEnv().getMap().getBlockNoCreateNoEx(getNodeBlockPos(spos));
 					snode = client.getEnv().getMap().getNodeNoEx(spos,NULL);
-					if (block != NULL)
+					if (block)
+					{
 						biome = block->getBiome();
+						block->ResetCurrent();
+					}
 				}
 
 				LocalPlayer *p = client.getLocalPlayer();
 
 				hud_draw(
diff -rU5 voxelands-v1709.00old/src/game.h voxelands-v1709.00good/src/game.h
--- voxelands-v1709.00old/src/game.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/game.h	2024-09-22 18:41:01.708655798 +0200
@@ -37,11 +37,11 @@
 class KeyList : protected core::list<KeyPress>
 {
 	typedef core::list<KeyPress> super;
 	typedef super::Iterator Iterator;
 	typedef super::ConstIterator ConstIterator;
-
+	
 	virtual ConstIterator find(const KeyPress &key) const
 	{
 		ConstIterator f(begin());
 		ConstIterator e(end());
 		while (f!=e) {
@@ -63,10 +63,12 @@
 		}
 		return e;
 	}
 
 public:
+	virtual ~KeyList() {};
+
 	void clear() { super::clear(); }
 
 	void set(const KeyPress &key)
 	{
 		if (find(key) == end())
diff -rU5 voxelands-v1709.00old/src/guiMainMenu.cpp voxelands-v1709.00good/src/guiMainMenu.cpp
--- voxelands-v1709.00old/src/guiMainMenu.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/guiMainMenu.cpp	2024-09-22 18:41:01.708655798 +0200
@@ -157,11 +157,11 @@
 	*/
 
 	/*
 		Client section
 	*/
-	char* selected_tab = config_get("client.ui.mainmenu.tab");
+	const char* selected_tab = config_get("client.ui.mainmenu.tab");
 	if (!selected_tab) {
 		m_data->selected_tab = TAB_SINGLEPLAYER;
 	}else if (!strcmp(selected_tab,"multiplayer")) {
 		m_data->selected_tab = TAB_MULTIPLAYER;
 	}else if (!strcmp(selected_tab,"settings")) {
@@ -171,14 +171,14 @@
 	}else{
 		m_data->selected_tab = TAB_SINGLEPLAYER;
 	}
 
 	if (m_data->selected_tab == TAB_MULTIPLAYER) {
-		GUIMultiplayerMenu *mmenu = new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
+		GUIMultiplayerMenu* const mmenu = new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
 		mmenu->drop();
 	}else if (m_data->selected_tab == TAB_SINGLEPLAYER) {
-		GUISingleplayerMenu *mmenu = new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
+		GUISingleplayerMenu* const mmenu = new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
 		mmenu->drop();
 	}else if (m_data->selected_tab == TAB_CREDITS) {
 		// CREDITS
 		{
 			core::rect<s32> rect(0, 0, 550, 550);
@@ -312,29 +312,32 @@
 			}
 			case GUI_ID_TAB_SINGLEPLAYER:
 			{
 				if (m_data->selected_tab == TAB_SETTINGS)
 					acceptInput();
-				GUISingleplayerMenu *mmenu = new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
+				GUISingleplayerMenu* const mmenu =
+				    new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
 				mmenu->drop();
 				m_data->selected_tab = TAB_SINGLEPLAYER;
 				config_set("client.ui.mainmenu.tab","singleplayer");
 				return true;
 			}
 			case GUI_ID_TAB_MULTIPLAYER:
 			{
 				if (m_data->selected_tab == TAB_SETTINGS)
 					acceptInput();
-				GUIMultiplayerMenu *mmenu = new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
+				GUIMultiplayerMenu* const mmenu =
+				    new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
 				mmenu->drop();
 				m_data->selected_tab = TAB_MULTIPLAYER;
 				config_set("client.ui.mainmenu.tab","multiplayer");
 				return true;
 			}
 			case GUI_ID_TAB_SETTINGS:
 			{
-				GUISettingsMenu *smenu = new GUISettingsMenu(env, parent, -1,menumgr, false);
+				GUISettingsMenu* const smenu =
+				    new GUISettingsMenu(env, parent, -1,menumgr, false);
 				smenu->drop();
 				return true;
 			}
 			case GUI_ID_TAB_CREDITS:
 				if (m_data->selected_tab == TAB_SETTINGS)
diff -rU5 voxelands-v1709.00old/src/guiPauseMenu.h voxelands-v1709.00good/src/guiPauseMenu.h
--- voxelands-v1709.00old/src/guiPauseMenu.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/guiPauseMenu.h	2024-09-22 18:41:01.708655798 +0200
@@ -30,10 +30,11 @@
 #include "modalMenu.h"
 
 class IGameCallback
 {
 public:
+	virtual ~IGameCallback() {};
 	virtual void exitToOS() = 0;
 	virtual void disconnect() = 0;
 	virtual void changePassword() = 0;
 	virtual void startGame() = 0;
 };
diff -rU5 voxelands-v1709.00old/src/guiSingleplayerMenu.cpp voxelands-v1709.00good/src/guiSingleplayerMenu.cpp
--- voxelands-v1709.00old/src/guiSingleplayerMenu.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/guiSingleplayerMenu.cpp	2024-09-22 18:41:01.708655798 +0200
@@ -531,11 +531,11 @@
 
 	world_unload();
 }
 void GUISingleplayerMenu::loadWorld(bool create)
 {
-	char* v;
+	const char* v;
 	config_clear("world");
 
 	survival_mode = true;
 	random_seed = true;
 	flat_map = false;
diff -rU5 voxelands-v1709.00old/src/http.cpp voxelands-v1709.00good/src/http.cpp
--- voxelands-v1709.00old/src/http.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/http.cpp	2024-09-22 18:41:01.708655798 +0200
@@ -68,12 +68,13 @@
 
 /* server thread main loop */
 void * HTTPServerThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("HTTPServerThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
@@ -291,11 +292,11 @@
 }
 
 /* handle /api/xxx url's */
 int HTTPRemoteClient::handleAPI()
 {
-	char* v;
+	const char* v;
 
 	std::string u1 = m_recv_headers.getUrl(1);
 
 	if (u1 == "summary" || u1 == "") {
 		std::string txt(VERSION_STRING);
@@ -343,11 +344,11 @@
 			v = "";
 		txt += v;
 		txt += "\n";
 
 		txt += "summary,motd,mode,name,players,public,version,privs,features";
-		send((char*)txt.c_str());
+		send(txt.c_str());
 		return 1;
 	}else if (u1 == "motd") {
 		v = config_get("world.game.motd");
 		if (!v)
 			v = "";
@@ -391,11 +392,11 @@
 			if (c++)
 				txt += ", ";
 			txt += player->getName();
 		}
 		array_free(players,1);
-		send((char*)txt.c_str());
+		send(txt.c_str());
 		return 1;
 	}else if (u1 == "public") {
 		v = config_get("world.server.client.default.password");
 		if (v || config_get_bool("world.server.client.private")) {
 			send("private");
@@ -411,11 +412,11 @@
 }
 
 /* handle / url's */
 int HTTPRemoteClient::handleIndex()
 {
-	char* v;
+	const char* v;
 	int c = 0;
 
 	std::string html("<div class=\"panel\"><h2>");
 	v = config_get("world.game.motd");
 	if (v)
@@ -453,11 +454,11 @@
 	sendHTML(html);
 	return 1;
 }
 
 /* send text data to a remote http client */
-void HTTPRemoteClient::send(char* data)
+void HTTPRemoteClient::send(const char* data)
 {
 	int l = strlen(data);
 	m_send_headers.setHeader("Content-Type","text/plain");
 	m_send_headers.setLength(l);
 	sendHeaders();
@@ -571,11 +572,11 @@
 
 /*
  * HTTP request
  */
 
-std::string http_request(char* host, char* url, char* post, int port)
+std::string http_request(const char* host, char* url, char* post, int port)
 {
 	Address addr;
 	TCPSocket *sock;
 	HTTPResponseHeaders headers;
 	int s;
diff -rU5 voxelands-v1709.00old/src/http.h voxelands-v1709.00good/src/http.h
--- voxelands-v1709.00old/src/http.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/http.h	2024-09-22 18:41:01.708655798 +0200
@@ -53,11 +53,11 @@
 public:
 	HTTPHeaders()
 	{
 		clear();
 	}
-	~HTTPHeaders() {};
+	virtual ~HTTPHeaders() {};
 	void clear()
 	{
 		m_contentLength = 0;
 		m_url = std::string("");
 		m_url_split.clear();
@@ -84,17 +84,19 @@
 };
 
 class HTTPRequestHeaders : public HTTPHeaders
 {
 public:
+	virtual ~HTTPRequestHeaders() {};
 	virtual int read(TCPSocket *sock);
 private:
 };
 
 class HTTPResponseHeaders : public HTTPHeaders
 {
 public:
+	virtual ~HTTPResponseHeaders() {};
 	virtual int read(TCPSocket *sock);
 	void setResponse(int r) {m_response = r;}
 	int getResponse() {return m_response;}
 private:
 	int m_response;
@@ -122,12 +124,12 @@
 	int handleIndex();
 	int handleAPI();
 	int handleSpecial(const char* response, std::string content);
 	int handleSpecial(const char* response) {return handleSpecial(response,"");}
 
-	void send(char* data);
-	void send(std::string &data) {send((char*)data.c_str());}
+	void send(const char* data);
+	void send(std::string &data) {send(data.c_str());}
 	void sendHTML(char* data);
 	void sendHTML(std::string &data) {sendHTML((char*)data.c_str());}
 	void sendFile(std::string &file);
 	void setResponse(const char* response) {std::string r(response); m_response = r;}
 
@@ -158,9 +160,9 @@
 	std::vector<HTTPRemoteClient*> m_peers;
 	HTTPServerThread m_thread;
 	Server *m_server;
 };
 
-std::string http_request(char* host, char* url, char* post=NULL, int port=80);
+std::string http_request(const char* host, char* url, char* post=NULL, int port=80);
 std::string http_url_encode(std::string &str);
 
 #endif
diff -rU5 voxelands-v1709.00old/src/intl.c voxelands-v1709.00good/src/intl.c
--- voxelands-v1709.00old/src/intl.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/intl.c	2024-09-22 18:41:01.708655798 +0200
@@ -565,11 +565,11 @@
 }
 
 /* initialise an intl_t by loading in an mo file */
 int intl_load(intl_t *intl, char* file)
 {
-	char fbuff[2048];
+	char fbuff[2049];
 	char lbuff[128];
 	file_t *f;
 	uint32_t magic;
 	char* head;
 	char* p;
@@ -647,11 +647,11 @@
 	head = p;
 	e = strchr(head,'\n');
 	if (e)
 		*e = 0;
 
-	strncpy(fbuff,head+13,2048);
+	strncpy(fbuff,head+13,2048);fbuff[2048] = '\0';
 	if (e)
 		*e = '\n';
 	head = fbuff;
 
 	p = strstr(head,"nplurals=");
diff -rU5 voxelands-v1709.00old/src/inventory.cpp voxelands-v1709.00good/src/inventory.cpp
--- voxelands-v1709.00old/src/inventory.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/inventory.cpp	2024-09-22 18:41:01.709655800 +0200
@@ -803,14 +803,14 @@
 
 /*
 	Inventory
 */
 
-InventoryList::InventoryList(std::string name, u32 size)
+InventoryList::InventoryList(std::string name, u32 size) :
+		m_items(),m_size(size),m_name(name),m_allowed(),
+		m_denied(),m_stackable(false),m_diff()
 {
-	m_name = name;
-	m_size = size;
 	clearItems();
 	clearAllowed();
 	clearDenied();
 	setStackable();
 }
@@ -991,11 +991,14 @@
 			throw SerializationError("Unknown inventory identifier (3)");
 		}
 	}
 }
 
-InventoryList::InventoryList(const InventoryList &other)
+InventoryList::InventoryList(const InventoryList &other) :
+		m_items(),m_size(other.m_size),m_name(other.m_name),
+		m_allowed(other.m_allowed),m_denied(other.m_denied),
+		m_stackable(other.m_stackable),m_diff()
 {
 	/*
 		Do this so that the items get cloned. Otherwise the pointers
 		in the array will just get copied.
 	*/
@@ -1005,19 +1008,17 @@
 InventoryList & InventoryList::operator = (const InventoryList &other)
 {
 	m_name = other.m_name;
 	m_size = other.m_size;
 	clearItems();
+
 	for (u32 i=0; i<other.m_items.size(); i++) {
 		InventoryItem *item = other.m_items[i];
 		if (item != NULL)
 			m_items[i] = item->clone();
 	}
-	m_stackable = other.m_stackable;
-	m_allowed = other.m_allowed;
-	m_denied = other.m_denied;
-
+	
 	return *this;
 }
 
 const std::string &InventoryList::getName() const
 {
@@ -1445,11 +1446,11 @@
 	if (i == -1)
 		return NULL;
 	return m_lists[i];
 }
 
-const s32 Inventory::getListIndex(const std::string &name) const
+s32 Inventory::getListIndex(const std::string &name) const
 {
 	for (u32 i=0; i<m_lists.size(); i++) {
 		if (m_lists[i]->getName() == name)
 			return i;
 	}
diff -rU5 voxelands-v1709.00old/src/inventory.h voxelands-v1709.00good/src/inventory.h
--- voxelands-v1709.00old/src/inventory.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/inventory.h	2024-09-22 18:41:01.709655800 +0200
@@ -330,13 +330,12 @@
 
 class ToolItem : public InventoryItem
 {
 public:
 	ToolItem(content_t content, u16 wear, u16 data):
-		InventoryItem(1,data)
+			InventoryItem(1,data),m_wear(wear)
 	{
-		m_wear = wear;
 		m_content = content_toolitem_features(content).content;
 	}
 	/*
 		Implementation interface
 	*/
@@ -698,11 +697,11 @@
 		return m_diff;
 	}
 
 private:
 	// -1 if not found
-	const s32 getListIndex(const std::string &name) const;
+	s32 getListIndex(const std::string &name) const;
 
 	core::array<InventoryList*> m_lists;
 	InventoryDiff m_diff;
 };
 
diff -rU5 voxelands-v1709.00old/src/jthread/jthread.h voxelands-v1709.00good/src/jthread/jthread.h
--- voxelands-v1709.00old/src/jthread/jthread.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/jthread/jthread.h	2024-09-22 18:41:01.709655800 +0200
@@ -43,28 +43,32 @@
 
 class JTHREAD_IMPORTEXPORT JThread
 {
 public:
 	JThread();
+	JThread(const JThread& jt);
 	virtual ~JThread();
+	
+	JThread& operator=(const JThread& jt);
+
 	int Start();
 	int Kill();
 	virtual void *Thread() = 0;
 	bool IsRunning();
 	void *GetReturnValue();
 protected:
 	void ThreadStarted();
 private:
 
 #ifdef JTHREAD_CONFIG_WIN32THREADS
-#ifdef _WIN32_WCE
+# ifdef _WIN32_WCE
 	DWORD threadid;
 	static DWORD WINAPI TheThread(void *param);
-#else
+# else
 	static UINT __stdcall TheThread(void *param);
 	UINT threadid;
-#endif // _WIN32_WCE
+# endif // _WIN32_WCE
 	HANDLE threadhandle;
 #else // pthread type threads
 	static void *TheThread(void *param);
 	
 	pthread_t threadid;
diff -rU5 voxelands-v1709.00old/src/jthread/pthread/jmutex.cpp voxelands-v1709.00good/src/jthread/pthread/jmutex.cpp
--- voxelands-v1709.00old/src/jthread/pthread/jmutex.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/jthread/pthread/jmutex.cpp	2024-09-22 18:41:01.709655800 +0200
@@ -28,46 +28,45 @@
 #include "jmutex.h"
 
 namespace jthread
 {
 
-JMutex::JMutex()
-{
-	initialized = false;
-}
-
-JMutex::~JMutex()
-{
-	if (initialized)
+    JMutex::JMutex() : mutex(),initialized(false)
+    {
+    }
+
+    JMutex::~JMutex()
+    {
+	    if (initialized)
 		pthread_mutex_destroy(&mutex);
-}
+    }
 
-int JMutex::Init()
-{
-	if (initialized)
+    int JMutex::Init()
+    {
+	    if (initialized)
 		return ERR_JMUTEX_ALREADYINIT;
-	
-	pthread_mutex_init(&mutex,NULL);
-	initialized = true;
-	return 0;	
-}
-
-int JMutex::Lock()
-{
-	if (!initialized)
+	    
+	    pthread_mutex_init(&mutex,NULL);
+	    initialized = true;
+	    return 0;	
+    }
+
+    int JMutex::Lock()
+    {
+	    if (!initialized)
 		return ERR_JMUTEX_NOTINIT;
 		
-	pthread_mutex_lock(&mutex);
-	return 0;
-}
-
-int JMutex::Unlock()
-{
-	if (!initialized)
+	    pthread_mutex_lock(&mutex);
+	    return 0;
+    }
+
+    int JMutex::Unlock()
+    {
+	    if (!initialized)
 		return ERR_JMUTEX_NOTINIT;
 	
-	pthread_mutex_unlock(&mutex);
-	return 0;
-}
+	    pthread_mutex_unlock(&mutex);
+	    return 0;
+    }
 
 } // end namespace
 
diff -rU5 voxelands-v1709.00old/src/jthread/pthread/jthread.cpp voxelands-v1709.00good/src/jthread/pthread/jthread.cpp
--- voxelands-v1709.00old/src/jthread/pthread/jthread.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/jthread/pthread/jthread.cpp	2024-09-22 18:41:01.709655800 +0200
@@ -31,155 +31,173 @@
 #include <stdlib.h>
 
 namespace jthread
 {
 
-JThread::JThread()
-{
-	retval = NULL;
-	mutexinit = false;
-	running = false;
-}
-
-JThread::~JThread()
-{
-	Kill();
-}
+    JThread::JThread() : threadid(),retval(NULL),running(false),runningmutex(),
+			 continuemutex(),continuemutex2(),mutexinit(false)
+    {
+    }
+
+    JThread::JThread(const JThread& jt) : threadid(jt.threadid),
+					  retval(jt.retval),running(jt.running),
+					  runningmutex(jt.runningmutex),
+					  continuemutex(jt.continuemutex),
+					  continuemutex2(jt.continuemutex2),
+					  mutexinit(jt.mutexinit)
+    {
+    }
+
+    JThread::~JThread()
+    {
+	    Kill();
+    }
+
+    JThread& JThread::operator=(const JThread& jt)
+    {
+	    threadid = jt.threadid;retval = jt.retval;
+	    running = jt.running;
+	    runningmutex = jt.runningmutex;
+	    continuemutex = jt.continuemutex;
+	    continuemutex2 = jt.continuemutex2;
+	    mutexinit = jt.mutexinit;
+	    return *this;
+    }
+    
+    int JThread::Start()
+    {
+	    int status;
 
-int JThread::Start()
-{
-	int status;
-
-	if (!mutexinit)
-	{
+	    if (!mutexinit)
+	    {
 		if (!runningmutex.IsInitialized())
 		{
-			if (runningmutex.Init() < 0)
-				return ERR_JTHREAD_CANTINITMUTEX;
+		    if (runningmutex.Init() < 0)
+			return ERR_JTHREAD_CANTINITMUTEX;
 		}
 		if (!continuemutex.IsInitialized())
 		{
-			if (continuemutex.Init() < 0)
-				return ERR_JTHREAD_CANTINITMUTEX;
+		    if (continuemutex.Init() < 0)
+			return ERR_JTHREAD_CANTINITMUTEX;
 		}
 		if (!continuemutex2.IsInitialized())
 		{
-			if (continuemutex2.Init() < 0)
-				return ERR_JTHREAD_CANTINITMUTEX;
+		    if (continuemutex2.Init() < 0)
+			return ERR_JTHREAD_CANTINITMUTEX;
 		}
 		mutexinit = true;
-	}
+	    }
 	
-	runningmutex.Lock();
-	if (running)
-	{
+	    runningmutex.Lock();
+	    if (running)
+	    {
 		runningmutex.Unlock();
 		return ERR_JTHREAD_ALREADYRUNNING;
-	}
-	runningmutex.Unlock();
+	    }
+	    runningmutex.Unlock();
 	
-	pthread_attr_t attr;
-	pthread_attr_init(&attr);
-	pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
-	
-	continuemutex.Lock();
-	status = pthread_create(&threadid,&attr,TheThread,this);	
-	pthread_attr_destroy(&attr);
-	if (status != 0)
-	{
+	    pthread_attr_t attr;
+	    pthread_attr_init(&attr);
+	    pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
+	
+	    continuemutex.Lock();
+	    status = pthread_create(&threadid,&attr,TheThread,this);	
+	    pthread_attr_destroy(&attr);
+	    if (status != 0)
+	    {
 		continuemutex.Unlock();
 		return ERR_JTHREAD_CANTSTARTTHREAD;
-	}
+	    }
 	
 	/* Wait until 'running' is set */
 	
-	runningmutex.Lock();			
-	while (!running)
-	{
+	    runningmutex.Lock();			
+	    while (!running)
+	    {
 		runningmutex.Unlock();
 		
 		struct timespec req,rem;
 
 		req.tv_sec = 0;
 		req.tv_nsec = 1000000;
 		nanosleep(&req,&rem);
 
 		runningmutex.Lock();
-	}
-	runningmutex.Unlock();
+	    }
+	    runningmutex.Unlock();
 	
-	continuemutex.Unlock();
+	    continuemutex.Unlock();
 	
-	continuemutex2.Lock();
-	continuemutex2.Unlock();
-	return 0;
-}
-
-int JThread::Kill()
-{
-	runningmutex.Lock();			
-	if (!running)
-	{
+	    continuemutex2.Lock();
+	    continuemutex2.Unlock();
+	    return 0;
+    }
+
+    int JThread::Kill()
+    {
+	    runningmutex.Lock();			
+	    if (!running)
+	    {
 		runningmutex.Unlock();
 		return ERR_JTHREAD_NOTRUNNING;
-	}
-	pthread_cancel(threadid);
-	running = false;
-	runningmutex.Unlock();
-	return 0;
-}
-
-bool JThread::IsRunning()
-{
-	bool r;
-	
-	runningmutex.Lock();			
-	r = running;
-	runningmutex.Unlock();
-	return r;
-}
-
-void *JThread::GetReturnValue()
-{
-	void *val;
+	    }
+	    pthread_cancel(threadid);
+	    running = false;
+	    runningmutex.Unlock();
+	    return 0;
+    }
+
+    bool JThread::IsRunning()
+    {
+	    bool r;
+	
+	    runningmutex.Lock();			
+	    r = running;
+	    runningmutex.Unlock();
+	    return r;
+    }
+
+    void *JThread::GetReturnValue()
+    {
+	    void *val;
 	
-	runningmutex.Lock();
-	if (running)
+	    runningmutex.Lock();
+	    if (running)
 		val = NULL;
-	else
+	    else
 		val = retval;
-	runningmutex.Unlock();
-	return val;
-}
-
-void *JThread::TheThread(void *param)
-{
-	JThread *jthread;
-	void *ret;
-	
-	jthread = (JThread *)param;
-	
-	jthread->continuemutex2.Lock();
-	jthread->runningmutex.Lock();
-	jthread->running = true;
-	jthread->runningmutex.Unlock();
-	
-	jthread->continuemutex.Lock();
-	jthread->continuemutex.Unlock();
-	
-	ret = jthread->Thread();
-
-	jthread->runningmutex.Lock();
-	jthread->running = false;
-	jthread->retval = ret;
-	jthread->runningmutex.Unlock();
-
-	return NULL;
-}
-
-void JThread::ThreadStarted()
-{
-	continuemutex2.Unlock();
-}
+	    runningmutex.Unlock();
+	    return val;
+    }
+
+    void *JThread::TheThread(void *param)
+    {
+	    JThread *jthread;
+	    void *ret;
+	
+	    jthread = (JThread *)param;
+	
+	    jthread->continuemutex2.Lock();
+	    jthread->runningmutex.Lock();
+	    jthread->running = true;
+	    jthread->runningmutex.Unlock();
+	
+	    jthread->continuemutex.Lock();
+	    jthread->continuemutex.Unlock();
+	
+	    ret = jthread->Thread();
+
+	    jthread->runningmutex.Lock();
+	    jthread->running = false;
+	    jthread->retval = ret;
+	    jthread->runningmutex.Unlock();
+
+	    return NULL;
+    }
+
+    void JThread::ThreadStarted()
+    {
+	    continuemutex2.Unlock();
+    }
 
 } // end namespace
 
diff -rU5 voxelands-v1709.00old/src/keycode.cpp voxelands-v1709.00good/src/keycode.cpp
--- voxelands-v1709.00old/src/keycode.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/keycode.cpp	2024-09-22 18:41:01.709655800 +0200
@@ -500,11 +500,11 @@
 KeyPress *g_key_setting_cache[256];
 static bool key_setting_cache_init = false;
 
 KeyPress getKeySetting(KeyCode code)
 {
-	char* v;
+	const char* v;
 	if (!key_setting_cache_init)
 		clearKeyCache();
 	if (g_key_setting_cache[code])
 		return *g_key_setting_cache[code];
 
diff -rU5 voxelands-v1709.00old/src/log.c voxelands-v1709.00good/src/log.c
--- voxelands-v1709.00old/src/log.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/log.c	2024-09-22 18:41:01.709655800 +0200
@@ -43,11 +43,11 @@
 	5,
 	NULL,
 	{"none","error","warn","action","chat","info","debug"}
 };
 
-static void level_setter(char* v, int *l, int d)
+static void level_setter(const char* v, int *l, int d)
 {
 	int i;
 	if (v) {
 		for (i=0; i<7; i++) {
 			if (!strcmp(logdata.levels[i],v)) {
@@ -59,41 +59,41 @@
 
 	*l = d;
 }
 
 /* config setters */
-int log_minlevel_setter(char* v)
+int log_minlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.min_level,1);
 	return 0;
 }
-int log_maxlevel_setter(char* v)
+int log_maxlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.max_level,5);
 	return 0;
 }
-int log_sminlevel_setter(char* v)
+int log_sminlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.system_min_level,4);
 	return 0;
 }
-int log_smaxlevel_setter(char* v)
+int log_smaxlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.system_max_level,5);
 	return 0;
 }
-int log_cminlevel_setter(char* v)
+int log_cminlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.console_min_level,4);
 	return 0;
 }
-int log_cmaxlevel_setter(char* v)
+int log_cmaxlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.console_max_level,5);
 	return 0;
 }
-int log_file_setter(char* v)
+int log_file_setter(const char* v)
 {
 	if (logdata.logfile)
 		free(logdata.logfile);
 	logdata.logfile = NULL;
 
@@ -104,11 +104,11 @@
 
 	return 0;
 }
 
 /* print text to game and system consoles */
-void vlprint(uint8_t type, char* str)
+void vlprint(uint8_t type,const char* str)
 {
 	char buff[1024];
 	char* b = buff;
 	int s = 1024;
 
@@ -179,11 +179,11 @@
 		fclose(f);
 	}
 }
 
 /* print formatted text to game and system consoles */
-void vlprintf(uint8_t type, char* fmt,...)
+void vlprintf(uint8_t type,const char* fmt,...)
 {
 	char buff[1024];
 	va_list ap;
 
 	if (!fmt)
diff -rU5 voxelands-v1709.00old/src/log.cpp voxelands-v1709.00good/src/log.cpp
--- voxelands-v1709.00old/src/log.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/log.cpp	2024-09-22 18:41:01.709655800 +0200
@@ -29,10 +29,12 @@
 #include <list>
 #include <sstream>
 #include "threads.h"
 #include "debug.h"
 #include "gettime.h"
+#include "jmutex.h"
+#include "jmutexautolock.h"
 
 std::list<ILogOutput*> log_outputs[LMT_NUM_VALUES];
 std::map<threadid_t, std::string> log_threadnames;
 
 void log_add_output(ILogOutput *out, enum LogMessageLevel lev)
@@ -73,17 +75,21 @@
 		break;
 	}
 	return "(unknown level)";
 }
 
-void log_printline(enum LogMessageLevel lev, const std::string &text)
+static void log_printline(enum LogMessageLevel lev, const std::string &text)
 {
 	std::string threadname = "(unknown thread)";
 	std::map<threadid_t, std::string>::const_iterator i;
+	
+	log_mutex.Lock();
 	i = log_threadnames.find(get_current_thread_id());
 	if(i != log_threadnames.end())
 		threadname = i->second;
+	log_mutex.Unlock();
+
 	std::string levelname = get_lev_string(lev);
 	std::ostringstream os(std::ios_base::binary);
 	os<<getTimestamp()<<": "<<levelname<<"["<<threadname<<"]: "<<text;
 	for(std::list<ILogOutput*>::iterator i = log_outputs[lev].begin();
 			i != log_outputs[lev].end(); i++){
@@ -95,12 +101,14 @@
 
 class Logbuf : public std::streambuf
 {
 public:
 	Logbuf(enum LogMessageLevel lev):
-		m_lev(lev)
+			m_lev(lev),m_buf(),m_mutex()
 	{
+		m_mutex.Init();
+		assert(m_mutex.IsInitialized());
 	}
 
 	~Logbuf()
 	{
 	}
@@ -115,31 +123,29 @@
 		for(int i=0; i<n; i++)
 			bufchar(s[i]);
 		return n;
 	}
 
-	void printbuf()
-	{
-		log_printline(m_lev, m_buf);
-	}
-
 	void bufchar(char c)
 	{
+	    	JMutexAutoLock lock(m_mutex);
 		if(c == '\n' || c == '\r'){
 			if(m_buf != "")
-				printbuf();
+			    log_printline(m_lev, m_buf);
 			m_buf = "";
 			return;
 		}
 		m_buf += c;
 	}
 
 private:
 	enum LogMessageLevel m_lev;
 	std::string m_buf;
+	JMutex m_mutex;
 };
 
+JMutex log_mutex;
 Logbuf errorbuf(LMT_ERROR);
 Logbuf actionbuf(LMT_ACTION);
 Logbuf infobuf(LMT_INFO);
 Logbuf verbosebuf(LMT_VERBOSE);
 std::ostream errorstream(&errorbuf);
diff -rU5 voxelands-v1709.00old/src/log.h voxelands-v1709.00good/src/log.h
--- voxelands-v1709.00old/src/log.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/log.h	2024-09-22 18:41:01.709655800 +0200
@@ -25,10 +25,11 @@
 
 #ifndef LOG_HEADER
 #define LOG_HEADER
 
 #include <string>
+#include "jmutex.h"
 
 /*
 	Use this for logging everything.
 
 	If you need to explicitly print something, use dstream or cout or cerr.
@@ -43,10 +44,12 @@
 };
 
 class ILogOutput
 {
 public:
+	virtual ~ILogOutput() {};
+	
 	/* line: Full line with timestamp, level and thread */
 	virtual void printLog(const std::string &line){};
 	/* line: Only actual printed text */
 	virtual void printLog(enum LogMessageLevel lev, const std::string &line){};
 };
@@ -55,21 +58,13 @@
 void log_add_output_maxlev(ILogOutput *out, enum LogMessageLevel lev);
 void log_add_output_all_levs(ILogOutput *out);
 
 void log_register_thread(const std::string &name);
 
-void log_printline(enum LogMessageLevel lev, const std::string &text);
-
-#define LOGLINEF(lev, ...)\
-{\
-	char buf[10000];\
-	snprintf(buf, 10000, __VA_ARGS__);\
-	log_printline(lev, buf);\
-}
-
 extern std::ostream errorstream;
 extern std::ostream actionstream;
 extern std::ostream infostream;
 extern std::ostream verbosestream;
+extern jthread::JMutex log_mutex;
 
 #endif
 
diff -rU5 voxelands-v1709.00old/src/main.cpp voxelands-v1709.00good/src/main.cpp
--- voxelands-v1709.00old/src/main.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/main.cpp	2024-09-22 18:41:01.710655801 +0200
@@ -132,10 +132,11 @@
 
 // A small helper class
 class TimeGetter
 {
 public:
+	virtual ~TimeGetter() {};
 	virtual u32 getTime() = 0;
 };
 
 // A precise irrlicht one
 class IrrlichtTimeGetter: public TimeGetter
@@ -715,14 +716,13 @@
 int main(int argc, char *argv[])
 {
 	/*
 		Initialization
 	*/
-
+	log_mutex.Init();
 	log_add_output_maxlev(&main_stderr_log_out, LMT_ACTION);
 	log_add_output_all_levs(&main_dstream_no_stderr_log_out);
-
 	log_register_thread("main");
 
 	/*
 		Low-level initialization
 	*/
@@ -796,11 +796,11 @@
 		DSTACK("Dedicated server branch");
 
 		// Create time getter
 		g_timegetter = new SimpleTimeGetter();
 
-		char* v = config_get("server.world");
+		const char* const v = config_get("server.world");
 		world_init(v);
 
 		// Create server
 		Server server;
 		server.start();
@@ -834,11 +834,11 @@
 	// Determine driver
 
 	video::E_DRIVER_TYPE driverType = video::EDT_OPENGL;
 
 	{
-		char* v = config_get("client.video.driver");
+		const char* v = config_get("client.video.driver");
 		if (v && !strcmp(v,"d3d9"))
 			driverType = video::EDT_DIRECT3D9;
 	}
 
 	/*
@@ -856,11 +856,11 @@
 	params.Stencilbuffer = false;
 	params.Vsync         = vsync;
 	params.EventReceiver = &receiver;
 	params.HighPrecisionFPU = config_get_bool("client.video.hpfpu");
 
-	IrrlichtDevice * device = createDeviceEx(params);
+	IrrlichtDevice* const device = createDeviceEx(params);
 
 	if (device == 0)
 		return 1; // could not create selected driver.
 
 	/*
@@ -898,11 +898,11 @@
 	gui::IGUIFont* font = NULL;
 	{
 		char buff[1024];
 #if USE_FREETYPE
 		uint16_t font_size = config_get_int("client.ui.font.size");
-		char* v = config_get("client.ui.font");
+		const char* v = config_get("client.ui.font");
 		if (!v)
 			v = "unifont.ttf";
 		if (path_get("font",v,1,buff,1024))
 			font = gui::CGUITTFont::createTTFont(guienv, buff, font_size, true, true, 1, 128);
 #else
@@ -969,11 +969,11 @@
 	std::string password;
 
 	// if there's no chardef then put the player directly into the character creator
 	bool character_creator = true;
 	{
-		char* v = config_get("client.character");
+		const char* v = config_get("client.character");
 		if (v && v[0])
 			character_creator = false;
 	}
 
 	/*
@@ -1009,11 +1009,11 @@
 				smgr->clear();
 
 				// Initialize menu data
 				std::string playername = "";
 				{
-					char* v = config_get("client.name");
+					const char* v = config_get("client.name");
 					if (v)
 						playername = std::string(v);
 				}
 				if (playername == "")
 					playername = porting::getUser();
@@ -1038,11 +1038,11 @@
 				menudata.fixed_seed = narrow_to_wide(bridge_config_get("world.seed"));
 				if (menudata.fixed_seed != L"")
 					menudata.use_fixed_seed = true;
 				menudata.map_type = config_get("world.map.type");
 
-				GUIMainMenu *menu = new GUIMainMenu(
+				GUIMainMenu* const menu = new GUIMainMenu(
 					guienv,
 					guiroot,
 					-1,
 					&g_menumgr,
 					&menudata,
@@ -1052,11 +1052,11 @@
 
 				if (error_message != L"") {
 					errorstream<<"error_message = "
 							<<wide_to_narrow(error_message)<<std::endl;
 
-					GUIMessageMenu *menu2 =
+					GUIMessageMenu* const menu2 =
 							new GUIMessageMenu(guienv, guiroot, -1,
 								&g_menumgr, error_message.c_str());
 					menu2->drop();
 					error_message = L"";
 				}
@@ -1103,11 +1103,11 @@
 				if (device->run() == false || kill == true)
 					break;
 
 				infostream<<"Dropping main menu"<<std::endl;
 
-				menu->drop();
+				menu->drop(); // Don't use after.
 
 				character_creator = menudata.character_creator;
 
 				if (character_creator)
 					break;
@@ -1167,11 +1167,11 @@
 
 			if (character_creator) {
 				character_creator = false;
 				video::IVideoDriver* driver = device->getVideoDriver();
 
-				GUICharDefMenu *menu = new GUICharDefMenu(device, guienv, guiroot, -1, &g_menumgr);
+				GUICharDefMenu* const menu = new GUICharDefMenu(device, guienv, guiroot, -1, &g_menumgr);
 				menu->allowFocusRemoval(true);
 
 #if USE_AUDIO == 1
 				sound_play_music("bg-charcreator",1.0,1);
 #endif
@@ -1199,21 +1199,20 @@
 #if USE_AUDIO == 1
 				sound_stop_music(1.0);
 #endif
 
 				menu->drop();
-
 				continue;
 			}
 			// Initialize mapnode again to enable changed graphics settings
 			init_mapnode(device);
 
 			/*
 				Run game
 			*/
 			{
-				char* v = config_get("world.server.address");
+				const char* v = config_get("world.server.address");
 				if (!v || !v[0]) {
 					if (!world_init(NULL)) {
 						the_game(
 							kill,
 							input,
diff -rU5 voxelands-v1709.00old/src/map.cpp voxelands-v1709.00good/src/map.cpp
--- voxelands-v1709.00old/src/map.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/map.cpp	2024-10-27 18:00:49.329292131 +0100
@@ -68,27 +68,33 @@
 
 /*
 	Map
 */
 
-Map::Map(std::ostream &dout):
-	m_dout(dout),
-	m_sector_cache(NULL)
+Map::Map(std::ostream &dout) : m_dout(dout),
+			       m_event_receivers(),
+			       m_sectors(),
+			       m_sectors_mutex(),
+			       m_sector_cache(NULL),
+			       m_sector_cache_p(),
+			       m_transforming_liquid()
 {
-	/*m_sector_mutex.Init();
-	assert(m_sector_mutex.IsInitialized());*/
+	m_sectors_mutex.Init();
+	assert(m_sectors_mutex.IsInitialized());
 }
 
 Map::~Map()
 {
 	/*
 		Free all MapSectors
 	*/
+	JMutexAutoLock lock(m_sectors_mutex);
 	core::map<v2s16, MapSector*>::Iterator i = m_sectors.getIterator();
+	
 	for(; i.atEnd() == false; i++)
 	{
-		MapSector *sector = i.getNode()->getValue();
+		MapSector* const sector = i.getNode()->getValue();
 		delete sector;
 	}
 }
 
 void Map::addEventReceiver(MapEventReceiver *event_receiver)
@@ -112,122 +118,151 @@
 		MapEventReceiver* event_receiver = i.getNode()->getKey();
 		event_receiver->onMapEditEvent(event);
 	}
 }
 
-MapSector * Map::getSectorNoGenerateNoExNoLock(v2s16 p)
+MapSector* Map::getSectorNoGenerateNoExNoLock(v2s16 p)
 {
-	if(m_sector_cache != NULL && p == m_sector_cache_p){
-		MapSector * sector = m_sector_cache;
+	if(m_sector_cache != NULL && p == m_sector_cache_p)
+	{
+		MapSector* const sector = m_sector_cache;
 		return sector;
 	}
 
-	core::map<v2s16, MapSector*>::Node *n = m_sectors.find(p);
+	core::map<v2s16, MapSector*>::Node* const n = m_sectors.find(p);
 
 	if(n == NULL)
 		return NULL;
 
-	MapSector *sector = n->getValue();
+	MapSector* const sector = n->getValue();
 
 	// Cache the last result
 	m_sector_cache_p = p;
 	m_sector_cache = sector;
 
 	return sector;
 }
 
-MapSector * Map::getSectorNoGenerateNoEx(v2s16 p)
+MapSector* Map::getSectorNoGenerateNoEx(v2s16 p)
 {
+	JMutexAutoLock lock(m_sectors_mutex);
 	return getSectorNoGenerateNoExNoLock(p);
 }
 
-MapSector * Map::getSectorNoGenerate(v2s16 p)
+MapSector* Map::getSectorNoGenerate(v2s16 p)
 {
-	MapSector *sector = getSectorNoGenerateNoEx(p);
+	MapSector* const sector = getSectorNoGenerateNoEx(p);
 	if(sector == NULL)
 		throw InvalidPositionException();
 
 	return sector;
 }
 
-MapBlock * Map::getBlockNoCreateNoEx(v3s16 p3d)
+MapBlock* Map::getBlockNoCreateNoExNoLock(v3s16 p3d)
 {
-	v2s16 p2d(p3d.X, p3d.Z);
-	MapSector * sector = getSectorNoGenerateNoEx(p2d);
+	const v2s16 p2d(p3d.X, p3d.Z);
+	MapSector* const sector = getSectorNoGenerateNoExNoLock(p2d);
 	if(sector == NULL)
 		return NULL;
-	MapBlock *block = sector->getBlockNoCreateNoEx(p3d.Y);
+	
+	MapBlock* const block = sector->getBlockNoCreateNoEx(p3d.Y);
 	return block;
 }
 
-MapBlock * Map::getBlockNoCreate(v3s16 p3d)
+MapBlock* Map::getBlockNoCreateNoEx(v3s16 p3d)
 {
-	MapBlock *block = getBlockNoCreateNoEx(p3d);
+	JMutexAutoLock lock(m_sectors_mutex);
+	MapBlock* const block = getBlockNoCreateNoExNoLock(p3d);
+
+	if(block)
+	    block->SetCurrent();
+	return block;
+}
+
+MapBlock* Map::getBlockNoCreate(v3s16 p3d)
+{
+	MapBlock* const block = getBlockNoCreateNoEx(p3d);
 	if(block == NULL)
 		throw InvalidPositionException();
 	return block;
 }
 
 bool Map::isNodeUnderground(v3s16 p)
 {
-	v3s16 blockpos = getNodeBlockPos(p);
-	try{
-		MapBlock * block = getBlockNoCreate(blockpos);
-		return block->getIsUnderground();
+	const v3s16 blockpos = getNodeBlockPos(p);
+	try
+	{
+		MapBlock* const block = getBlockNoCreate(blockpos);
+		const bool nug = block->getIsUnderground();
+
+		block->ResetCurrent();
+		return nug;
 	}
 	catch(InvalidPositionException &e)
 	{
 		return false;
 	}
 }
 
 bool Map::isValidPosition(v3s16 p)
 {
-	v3s16 blockpos = getNodeBlockPos(p);
-	MapBlock *block = getBlockNoCreate(blockpos);
-	return (block != NULL);
+	const v3s16 blockpos = getNodeBlockPos(p);
+	JMutexAutoLock lock(m_sectors_mutex);
+	MapBlock* const block = getBlockNoCreateNoExNoLock(blockpos);
+	if(block == NULL)
+		throw InvalidPositionException();
+	return block != NULL;
 }
 
 // Returns a CONTENT_IGNORE node if not found
-MapNode Map::getNodeNoEx(v3s16 p, bool *is_valid_position)
+MapNode Map::getNodeNoEx(v3s16 p, bool* is_valid_position)
 {
-	v3s16 blockpos = getNodeBlockPos(p);
-	MapBlock *block = getBlockNoCreateNoEx(blockpos);
-	if (block == NULL) {
+	const v3s16 blockpos = getNodeBlockPos(p);
+	JMutexAutoLock lock(m_sectors_mutex);
+	MapBlock* const block = getBlockNoCreateNoExNoLock(blockpos);
+	if (block == NULL)
+	{
 		if (is_valid_position)
 			*is_valid_position = false;
 		return MapNode(CONTENT_IGNORE);
 	}
-	v3s16 relpos = p - blockpos*MAP_BLOCKSIZE;
+	
+	const v3s16 relpos = p - blockpos*MAP_BLOCKSIZE;
 	bool is_valid_p;
 	MapNode node = block->getNodeNoCheck(relpos, &is_valid_p);
 	if (is_valid_position != NULL)
 		*is_valid_position = is_valid_p;
 	return node;
 }
 
 // throws InvalidPositionException if not found
 MapNode Map::getNode(v3s16 p)
 {
-	v3s16 blockpos = getNodeBlockPos(p);
-	MapBlock *block = getBlockNoCreateNoEx(blockpos);
+	const v3s16 blockpos = getNodeBlockPos(p);
+	JMutexAutoLock lock(m_sectors_mutex);
+	MapBlock* const block = getBlockNoCreateNoExNoLock(blockpos);
 	if (block == NULL)
 		throw InvalidPositionException();
-	v3s16 relpos = p - blockpos*MAP_BLOCKSIZE;
+	
+	const v3s16 relpos = p - blockpos*MAP_BLOCKSIZE;
 	bool is_valid_position;
 	MapNode node = block->getNodeNoCheck(relpos, &is_valid_position);
 	if (!is_valid_position)
 		throw InvalidPositionException();
 	return node;
 }
 
 // throws InvalidPositionException if not found
 void Map::setNode(v3s16 p, MapNode & n)
 {
-	v3s16 blockpos = getNodeBlockPos(p);
-	MapBlock *block = getBlockNoCreate(blockpos);
-	v3s16 relpos = p - blockpos*MAP_BLOCKSIZE;
+	const v3s16 blockpos = getNodeBlockPos(p);
+	JMutexAutoLock lock(m_sectors_mutex);
+	MapBlock* const block = getBlockNoCreateNoExNoLock(blockpos);
+	if (block == NULL)
+		throw InvalidPositionException();
+	
+	const v3s16 relpos = p - blockpos*MAP_BLOCKSIZE;
 	block->setNodeNoCheck(relpos, n);
 }
 
 
 /*
@@ -250,11 +285,11 @@
 void Map::unspreadLight(enum LightBank bank,
 		core::map<v3s16, u8> & from_nodes,
 		core::map<v3s16, bool> & light_sources,
 		core::map<v3s16, MapBlock*>  & modified_blocks)
 {
-	v3s16 dirs[6] = {
+	const v3s16 dirs[6] = {
 		v3s16(0,0,1), // back
 		v3s16(0,1,0), // top
 		v3s16(1,0,0), // right
 		v3s16(0,0,-1), // front
 		v3s16(0,-1,0), // bottom
@@ -263,71 +298,79 @@
 
 	if(from_nodes.size() == 0)
 		return;
 
 	u32 blockchangecount = 0;
-
 	core::map<v3s16, u8> unlighted_nodes;
-	core::map<v3s16, u8>::Iterator j;
-	j = from_nodes.getIterator();
+	core::map<v3s16, u8>::Iterator j = from_nodes.getIterator();
 
 	/*
 		Initialize block cache
 	*/
 	v3s16 blockpos_last;
-	MapBlock *block = NULL;
+	MapBlock* block = NULL;
 	// Cache this a bit, too
 	bool block_checked_in_modified = false;
 
 	for(; j.atEnd() == false; j++)
 	{
-		v3s16 pos = j.getNode()->getKey();
-		v3s16 blockpos = getNodeBlockPos(pos);
+		const v3s16 pos = j.getNode()->getKey();
+		const v3s16 blockpos = getNodeBlockPos(pos);
 
 		// Only fetch a new block if the block position has changed
-		try{
-			if(block == NULL || blockpos != blockpos_last){
-				block = getBlockNoCreate(blockpos);
-				blockpos_last = blockpos;
+		try
+		{
+			if(block == NULL || blockpos != blockpos_last)
+			{
+			    
+			    if(block)
+				block->ResetCurrent();
+	
+			    block = getBlockNoCreate(blockpos);
+			    blockpos_last = blockpos;
 
-				block_checked_in_modified = false;
-				blockchangecount++;
+			    block_checked_in_modified = false;
+			    blockchangecount++;
 			}
 		}
 		catch(InvalidPositionException &e)
 		{
 			continue;
 		}
 
 		if (block->isDummy())
 			continue;
 
-		u8 oldlight = j.getNode()->getValue();
+		const u8 oldlight = j.getNode()->getValue();
 
 		// Loop through 6 neighbors
-		for (u16 i=0; i<6; i++) {
+		for (u16 i=0; i<6; i++)
+		{
 			// Get the position of the neighbor node
-			v3s16 n2pos = pos + dirs[i];
-
+			const v3s16 n2pos = pos + dirs[i];
 			// Get the block where the node is located
-			v3s16 blockpos = getNodeBlockPos(n2pos);
+			const v3s16 blockpos = getNodeBlockPos(n2pos);
 
 			// Only fetch a new block if the block position has changed
-			try{
-				if (block == NULL || blockpos != blockpos_last) {
+			try
+			{
+				if (block == NULL || blockpos != blockpos_last)
+				{
 					block = getBlockNoCreate(blockpos);
 					blockpos_last = blockpos;
 
 					block_checked_in_modified = false;
 					blockchangecount++;
 				}
-			}catch(InvalidPositionException &e) {
+			}
+			catch(InvalidPositionException &e)
+			{
 				continue;
 			}
 
 			// Calculate relative position in block
-			v3s16 relpos = n2pos - blockpos * MAP_BLOCKSIZE;
+			const v3s16 relpos = n2pos - blockpos * MAP_BLOCKSIZE;
 			// Get node straight from the block
 			bool is_valid_position;
 			MapNode n2 = block->getNode(relpos, &is_valid_position);
 			if (!is_valid_position)
 				continue;
@@ -338,29 +381,31 @@
 
 			/*
 				If the neighbor is dimmer than what was specified
 				as oldlight (the light of the previous node)
 			*/
-			if (n2.getLight(bank) < oldlight) {
+			if (n2.getLight(bank) < oldlight)
+			{
 				/*
-					And the neighbor is transparent and it has some light
+				  And the neighbor is transparent and it has some light
 				*/
-				if (content_features(n2).light_propagates && n2.getLight(bank) != 0) {
+				if (content_features(n2).light_propagates && n2.getLight(bank) != 0)
+				{
 					/*
-						Set light to 0 and add to queue
+					  Set light to 0 and add to queue
 					*/
 
-					u8 current_light = n2.getLight(bank);
+					const u8 current_light = n2.getLight(bank);
 					n2.setLight(bank, 0);
 					block->setNode(relpos, n2);
 
 					unlighted_nodes.insert(n2pos, current_light);
 					changed = true;
 
 					/*
-						Remove from light_sources if it is there
-						NOTE: This doesn't happen nearly at all
+					  Remove from light_sources if it is there
+					  NOTE: This doesn't happen nearly at all
 					*/
 					/*if(light_sources.find(n2pos))
 					{
 						infostream<<"Removed from light_sources"<<std::endl;
 						light_sources.remove(n2pos);
@@ -368,24 +413,27 @@
 				}
 
 				/*// DEBUG
 				if(light_sources.find(n2pos) != NULL)
 					light_sources.remove(n2pos);*/
-			}else{
+			}else
 				light_sources.insert(n2pos, true);
-			}
 
 			// Add to modified_blocks
-			if (changed == true && block_checked_in_modified == false) {
+			if (changed == true && block_checked_in_modified == false)
+			{
 				// If the block is not found in modified_blocks, add.
 				if (modified_blocks.find(blockpos) == NULL)
 					modified_blocks.insert(blockpos, block);
 				block_checked_in_modified = true;
 			}
 		}
 	}
 
+	if(block)
+	    block->ResetCurrent();
+	
 	/*infostream<<"unspreadLight(): Changed block "
 			<<blockchangecount<<" times"
 			<<" for "<<from_nodes.size()<<" nodes"
 			<<std::endl;*/
 
@@ -435,11 +483,11 @@
 
 	/*
 		Initialize block cache
 	*/
 	v3s16 blockpos_last;
-	MapBlock *block = NULL;
+	MapBlock* block = NULL;
 	// Cache this a bit, too
 	bool block_checked_in_modified = false;
 
 	for(; j.atEnd() == false; j++)
 	//for(; j != from_nodes.end(); j++)
@@ -449,16 +497,21 @@
 		//infostream<<"pos=("<<pos.X<<","<<pos.Y<<","<<pos.Z<<")"<<std::endl;
 		v3s16 blockpos = getNodeBlockPos(pos);
 
 		// Only fetch a new block if the block position has changed
 		try{
-			if(block == NULL || blockpos != blockpos_last){
-				block = getBlockNoCreate(blockpos);
-				blockpos_last = blockpos;
+			if(block == NULL || blockpos != blockpos_last)
+			{
 
-				block_checked_in_modified = false;
-				blockchangecount++;
+			    if(block)
+				block->ResetCurrent();
+	
+			    block = getBlockNoCreate(blockpos);
+			    blockpos_last = blockpos;
+
+			    block_checked_in_modified = false;
+			    blockchangecount++;
 			}
 		}
 		catch(InvalidPositionException &e)
 		{
 			continue;
@@ -476,71 +529,80 @@
 
 		u8 oldlight = n.getLight(bank);
 		u8 newlight = diminish_light(oldlight);
 
 		// Loop through 6 neighbors
-		for (u16 i=0; i<6; i++) {
+		for (u16 i=0; i<6; i++)
+		{
 			// Get the position of the neighbor node
-			v3s16 n2pos = pos + dirs[i];
-
+			const v3s16 n2pos = pos + dirs[i];
 			// Get the block where the node is located
-			v3s16 blockpos = getNodeBlockPos(n2pos);
+			const v3s16 blockpos = getNodeBlockPos(n2pos);
 
 			// Only fetch a new block if the block position has changed
-			try{
-				if (block == NULL || blockpos != blockpos_last) {
+			try
+			{
+				if (block == NULL || blockpos != blockpos_last)
+				{
 					block = getBlockNoCreate(blockpos);
 					blockpos_last = blockpos;
 
 					block_checked_in_modified = false;
 					blockchangecount++;
 				}
-			}catch(InvalidPositionException &e) {
+			}
+			catch(InvalidPositionException &e)
+			{
 				continue;
 			}
 
 			// Calculate relative position in block
-			v3s16 relpos = n2pos - blockpos * MAP_BLOCKSIZE;
+			const v3s16 relpos = n2pos - blockpos * MAP_BLOCKSIZE;
 			// Get node straight from the block
 			MapNode n2 = block->getNode(relpos, &is_valid_position);
 			if (!is_valid_position)
 				continue;
 
 			bool changed = false;
 			/*
 				If the neighbor is brighter than the current node,
 				add to list (it will light up this node on its turn)
 			*/
-			if (n2.getLight(bank) > undiminish_light(oldlight)) {
+			if (n2.getLight(bank) > undiminish_light(oldlight))
+			{
 				lighted_nodes.insert(n2pos, true);
 				//lighted_nodes.push_back(n2pos);
 				changed = true;
 			}
 			/*
 				If the neighbor is dimmer than how much light this node
 				would spread on it, add to list
 			*/
-			if (n2.getLight(bank) < newlight) {
-				if (content_features(n2).light_propagates) {
+			if (n2.getLight(bank) < newlight)
+				if (content_features(n2).light_propagates)
+				{
 					n2.setLight(bank, newlight);
 					block->setNode(relpos, n2);
 					lighted_nodes.insert(n2pos, true);
 					//lighted_nodes.push_back(n2pos);
 					changed = true;
 				}
-			}
 
 			// Add to modified_blocks
-			if (changed == true && block_checked_in_modified == false) {
+			if (changed == true && block_checked_in_modified == false)
+			{
 				// If the block is not found in modified_blocks, add.
 				if (modified_blocks.find(blockpos) == NULL)
 					modified_blocks.insert(blockpos, block);
 				block_checked_in_modified = true;
 			}
 		}
 	}
 
+	if(block)
+	    block->ResetCurrent();
+	
 	/*infostream<<"spreadLight(): Changed block "
 			<<blockchangecount<<" times"
 			<<" for "<<from_nodes.size()<<" nodes"
 			<<std::endl;*/
 
@@ -574,18 +636,21 @@
 	u8 brightest_light = 0;
 	v3s16 brightest_pos(0,0,0);
 	bool found_something = false;
 
 	// Loop through 6 neighbors
-	for(u16 i=0; i<6; i++){
+	for(u16 i=0; i<6; i++)
+	{
 		// Get the position of the neighbor node
 		v3s16 n2pos = p + dirs[i];
 		bool pos_ok;
 		MapNode n2 = getNodeNoEx(n2pos,&pos_ok);
 		if (!pos_ok)
 			continue;
-		if (n2.getLight(bank) > brightest_light || found_something == false) {
+		if (n2.getLight(bank) > brightest_light
+				|| found_something == false)
+		{
 			brightest_light = n2.getLight(bank);
 			brightest_pos = n2pos;
 			found_something = true;
 		}
 	}
@@ -606,18 +671,22 @@
 */
 s16 Map::propagateSunlight(v3s16 start,
 		core::map<v3s16, MapBlock*> & modified_blocks)
 {
 	s16 y = start.Y;
-	for (; ; y--) {
+	for (; ; y--)
+	{
 		v3s16 pos(start.X, y, start.Z);
 
 		v3s16 blockpos = getNodeBlockPos(pos);
-		MapBlock *block;
-		try{
+		MapBlock* block = NULL;
+		try
+		{
 			block = getBlockNoCreate(blockpos);
-		}catch(InvalidPositionException &e) {
+		}
+		catch(InvalidPositionException &e)
+		{
 			break;
 		}
 
 		v3s16 relpos = pos - blockpos*MAP_BLOCKSIZE;
 		bool is_valid_position;
@@ -631,10 +700,13 @@
 
 		n.setLight(LIGHTBANK_DAY, LIGHT_SUN);
 		block->setNode(relpos, n);
 
 		modified_blocks.insert(blockpos, block);
+		
+		if(block)
+		    block->ResetCurrent();
 	}
 	return y + 1;
 }
 
 void Map::updateLighting(enum LightBank bank,
@@ -650,16 +722,18 @@
 
 	core::map<v3s16, bool> light_sources;
 
 	core::map<v3s16, u8> unlight_from;
 
-	core::map<v3s16, MapBlock*>::Iterator i;
-	i = a_blocks.getIterator();
-	for (; i.atEnd() == false; i++) {
-		MapBlock *block = i.getNode()->getValue();
+	core::map<v3s16, MapBlock*>::Iterator i = a_blocks.getIterator();
+	
+	for (; i.atEnd() == false; i++)
+	{
+		MapBlock* block = i.getNode()->getValue();
 
-		for (;;) {
+		for (;;)
+		{
 			// Don't bother with dummy blocks.
 			if (block->isDummy())
 				break;
 
 			v3s16 pos = block->getPos();
@@ -670,69 +744,81 @@
 			/*
 				Clear all light from block
 			*/
 			for (s16 z=0; z<MAP_BLOCKSIZE; z++)
 			for (s16 x=0; x<MAP_BLOCKSIZE; x++)
-			for (s16 y=0; y<MAP_BLOCKSIZE; y++) {
+			for (s16 y=0; y<MAP_BLOCKSIZE; y++)
+			{
 					v3s16 p(x,y,z);
 					bool is_valid_position;
 					MapNode n = block->getNode(v3s16(x,y,z),&is_valid_position);
 					if (!is_valid_position)
 						continue;
 					u8 oldlight = n.getLight(bank);
 					n.setLight(bank, 0);
 					block->setNode(v3s16(x,y,z), n);
 
 					// Collect borders for unlighting
-					if (
-						x==0 || x == MAP_BLOCKSIZE-1
-						|| y==0 || y == MAP_BLOCKSIZE-1
-						|| z==0 || z == MAP_BLOCKSIZE-1
-					) {
+					if (x==0 || x == MAP_BLOCKSIZE-1
+							|| y==0 || y == MAP_BLOCKSIZE-1
+							|| z==0 || z == MAP_BLOCKSIZE-1)
+					{
 						v3s16 p_map = p + v3s16(
 								MAP_BLOCKSIZE*pos.X,
 								MAP_BLOCKSIZE*pos.Y,
 								MAP_BLOCKSIZE*pos.Z);
 						unlight_from.insert(p_map, oldlight);
 					}
 			}
 
-			if (bank == LIGHTBANK_DAY) {
+			if (bank == LIGHTBANK_DAY)
+			{
 				bool bottom_valid = block->propagateSunlight(light_sources);
 
 				// If bottom is valid, we're done.
 				if(bottom_valid)
 					break;
-			}else if (bank == LIGHTBANK_NIGHT) {
+			}
+			else if (bank == LIGHTBANK_NIGHT)
 				// For night lighting, sunlight is not propagated
 				break;
-			}else{
+			else
 				// Invalid lighting bank
 				assert(0);
-			}
 
 			// Bottom sunlight is not valid; get the block and loop to it
 
 			pos.Y--;
-			try{
+			try
+			{				
+				if(block)
+				    block->ResetCurrent();
+				
 				block = getBlockNoCreate(pos);
-			}catch(InvalidPositionException &e) {
+			}
+			catch(InvalidPositionException &e)
+			{
 				assert(0);
 			}
 
 		}
+		
+		if(block)
+		    block->ResetCurrent();
+
 	}
 
 	{
 		//MapVoxelManipulator vmanip(this);
 
 		// Make a manual voxel manipulator and load all the blocks
 		// that touch the requested blocks
 		ManualMapVoxelManipulator vmanip(this);
-		core::map<v3s16, MapBlock*>::Iterator i;
-		i = blocks_to_update.getIterator();
-		for (; i.atEnd() == false; i++) {
+		core::map<v3s16, MapBlock*>::Iterator i = blocks_to_update.getIterator();
+		
+		for (; i.atEnd() == false; i++)
+		{
 			MapBlock *block = i.getNode()->getValue();
 			v3s16 p = block->getPos();
 
 			// Add all surrounding blocks
 			vmanip.initialEmerge(p - v3s16(1,1,1), p + v3s16(1,1,1));
@@ -777,11 +863,12 @@
 }
 
 /*
 */
 void Map::addNodeAndUpdate(v3s16 p, MapNode n,
-		core::map<v3s16, MapBlock*> &modified_blocks, std::string &player_name)
+		core::map<v3s16, MapBlock*> &modified_blocks,
+		std::string &player_name)
 {
 	/*PrintInfo(m_dout);
 	m_dout<<DTIME<<"Map::addNodeAndUpdate(): p=("
 			<<p.X<<","<<p.Y<<","<<p.Z<<")"<<std::endl;*/
 
@@ -790,12 +877,11 @@
 		If lighting is sunlight (1.0), unlight neighbours and
 		set lighting to 0.
 		Else discontinue.
 	*/
 
-	v3s16 toppos = p + v3s16(0,1,0);
-
+	const v3s16 toppos = p + v3s16(0,1,0);
 	bool node_under_sunlight = true;
 	core::map<v3s16, bool> light_sources;
 
 	/*
 		If there is a node at top and it doesn't have sunlight,
@@ -818,19 +904,20 @@
 	enum LightBank banks[] =
 	{
 		LIGHTBANK_DAY,
 		LIGHTBANK_NIGHT
 	};
+	
 	for(s32 i=0; i<2; i++)
 	{
 		enum LightBank bank = banks[i];
 
 		u8 lightwas = getNode(p).getLight(bank);
 
 		// Add the block of the added node to modified_blocks
 		v3s16 blockpos = getNodeBlockPos(p);
-		MapBlock * block = getBlockNoCreate(blockpos);
+		MapBlock* const block = getBlockNoCreate(blockpos);
 		assert(block != NULL);
 		modified_blocks.insert(blockpos, block);
 
 		assert(isValidPosition(p));
 
@@ -838,12 +925,12 @@
 		// This means setting light of all consequent dimmer nodes
 		// to 0.
 		// This also collects the nodes at the border which will spread
 		// light again into this.
 		unLightNeighbors(bank, p, lightwas, light_sources, modified_blocks);
-
 		n.setLight(bank, 0);
+		block->ResetCurrent();
 	}
 
 	/*
 		If node lets sunlight through and is under sunlight, it has
 		sunlight too.
@@ -859,11 +946,11 @@
 
 	/*
 		Add intial metadata
 	*/
 
-	NodeMetadata *meta_proto = content_features(n).initial_metadata;
+	NodeMetadata* const meta_proto = content_features(n).initial_metadata;
 	if (meta_proto) {
 		NodeMetadata *meta = meta_proto->clone();
 		meta->setOwner(player_name);
 		setNodeMetadata(p, meta);
 	}
@@ -873,22 +960,25 @@
 		take all sunlighted nodes under it and clear light from them
 		and from where the light has been spread.
 		TODO: This could be optimized by mass-unlighting instead
 			  of looping
 	*/
-	if (node_under_sunlight && !content_features(n).sunlight_propagates) {
+	if (node_under_sunlight && !content_features(n).sunlight_propagates)
+	{
 		s16 y = p.Y - 1;
-		for (;; y--) {
+		for (;; y--)
+		{
 			//m_dout<<DTIME<<"y="<<y<<std::endl;
 			v3s16 n2pos(p.X, y, p.Z);
 			bool pos_ok;
 
 			MapNode n2 = getNodeNoEx(n2pos,&pos_ok);
 			if (!pos_ok)
 				break;
 
-			if (n2.getLight(LIGHTBANK_DAY) == LIGHT_SUN) {
+			if (n2.getLight(LIGHTBANK_DAY) == LIGHT_SUN)
+			{
 				unLightNeighbors(LIGHTBANK_DAY,
 						n2pos, n2.getLight(LIGHTBANK_DAY),
 						light_sources, modified_blocks);
 				n2.setLight(LIGHTBANK_DAY, 0);
 				setNode(n2pos, n2);
@@ -896,11 +986,12 @@
 			else
 				break;
 		}
 	}
 
-	for (s32 i=0; i<2; i++) {
+	for (s32 i=0; i<2; i++)
+	{
 		enum LightBank bank = banks[i];
 
 		/*
 			Spread light from all nodes that might be capable of doing so
 		*/
@@ -920,25 +1011,29 @@
 
 	/*
 		Add neighboring liquid nodes and the node itself if it is
 		liquid (=water node was added) to transform queue.
 	*/
-	v3s16 dirs[7] = {
+	const v3s16 dirs[7] = {
 		v3s16(0,0,0), // self
 		v3s16(0,0,1), // back
 		v3s16(0,1,0), // top
 		v3s16(1,0,0), // right
 		v3s16(0,0,-1), // front
 		v3s16(0,-1,0), // bottom
 		v3s16(-1,0,0), // left
 	};
-	for (u16 i=0; i<7; i++) {
-		v3s16 p2 = p + dirs[i];
-		bool pos_ok;
-		MapNode n2 = getNodeNoEx(p2,&pos_ok);
-		if (pos_ok && (content_features(n2).liquid_type != LIQUID_NONE || n2.getContent() == CONTENT_AIR))
-			m_transforming_liquid.push_back(p2);
+	
+	for (u16 i=0; i<7; i++)
+	{
+	    const v3s16 p2 = p + dirs[i];
+	    bool pos_ok;
+	    const MapNode n2 = getNodeNoEx(p2,&pos_ok);
+		
+	    if (pos_ok && (content_features(n2).liquid_type != LIQUID_NONE
+					    || n2.getContent() == CONTENT_AIR))
+		m_transforming_liquid.push_back(p2);
 	}
 }
 
 /*
 */
@@ -948,12 +1043,11 @@
 	/*PrintInfo(m_dout);
 	m_dout<<DTIME<<"Map::removeNodeAndUpdate(): p=("
 			<<p.X<<","<<p.Y<<","<<p.Z<<")"<<std::endl;*/
 
 	bool node_under_sunlight = true;
-
-	v3s16 toppos = p + v3s16(0,1,0);
+	const v3s16 toppos = p + v3s16(0,1,0);
 
 	// Node will be replaced with this
 	content_t replace_material = CONTENT_AIR;
 
 	/*
@@ -972,11 +1066,13 @@
 
 	enum LightBank banks[] = {
 		LIGHTBANK_DAY,
 		LIGHTBANK_NIGHT
 	};
-	for (s32 i=0; i<2; i++) {
+	
+	for (s32 i=0; i<2; i++)
+	{
 		enum LightBank bank = banks[i];
 
 		/*
 			Unlight neighbors (in case the node is a light source)
 		*/
@@ -998,55 +1094,62 @@
 
 	MapNode n;
 	n.setContent(replace_material);
 	setNode(p, n);
 
-	for (s32 i=0; i<2; i++) {
+	for (s32 i=0; i<2; i++)
+	{
 		enum LightBank bank = banks[i];
 
 		/*
 			Recalculate lighting
 		*/
 		spreadLight(bank, light_sources, modified_blocks);
 	}
 
 	// Add the block of the removed node to modified_blocks
 	v3s16 blockpos = getNodeBlockPos(p);
-	MapBlock * block = getBlockNoCreate(blockpos);
+	MapBlock* const block = getBlockNoCreate(blockpos);
 	assert(block != NULL);
 	modified_blocks.insert(blockpos, block);
 
 	/*
 		If the removed node was under sunlight, propagate the
 		sunlight down from it and then light all neighbors
 		of the propagated blocks.
 	*/
-	if (node_under_sunlight) {
+	if (node_under_sunlight)
+	{
 		s16 ybottom = propagateSunlight(p, modified_blocks);
 		/*m_dout<<DTIME<<"Node was under sunlight. "
 				"Propagating sunlight";
 		m_dout<<DTIME<<" -> ybottom="<<ybottom<<std::endl;*/
 		s16 y = p.Y;
-		for (; y >= ybottom; y--) {
+		for (; y >= ybottom; y--)
+		{
 			v3s16 p2(p.X, y, p.Z);
 			/*m_dout<<DTIME<<"lighting neighbors of node ("
 					<<p2.X<<","<<p2.Y<<","<<p2.Z<<")"
 					<<std::endl;*/
 			lightNeighbors(LIGHTBANK_DAY, p2, modified_blocks);
 		}
-	}else{
+	}
+	else
+	{
 		// Set the lighting of this node to 0
 		// TODO: Is this needed? Lighting is cleared up there already.
 		bool pos_ok;
 		MapNode n = getNodeNoEx(p,&pos_ok);
-		if (pos_ok) {
+		if (pos_ok)
+		{
 			n.setLight(LIGHTBANK_DAY, 0);
 			setNode(p, n);
 		}
 	}
 
-	for (s32 i=0; i<2; i++) {
+	for (s32 i=0; i<2; i++)
+	{
 		enum LightBank bank = banks[i];
 
 		// Get the brightest neighbour node and propagate light from it
 		v3s16 n2p = getBrightestNeighbour(bank, p);
 		bool pos_ok = isValidPosition(n2p);
@@ -1067,39 +1170,45 @@
 
 	/*
 		Add neighboring liquid nodes and this node to transform queue.
 		(it's vital for the node itself to get updated last.)
 	*/
-	v3s16 dirs[7] = {
+	const v3s16 dirs[7] = {
 		v3s16(0,0,1), // back
 		v3s16(0,1,0), // top
 		v3s16(1,0,0), // right
 		v3s16(0,0,-1), // front
 		v3s16(0,-1,0), // bottom
 		v3s16(-1,0,0), // left
 		v3s16(0,0,0), // self
 	};
-	for (u16 i=0; i<7; i++) {
-		bool pos_ok;
-
-		v3s16 p2 = p + dirs[i];
-
-		MapNode n2 = getNodeNoEx(p2,&pos_ok);
-		if (pos_ok && (content_features(n2).liquid_type != LIQUID_NONE || n2.getContent() == CONTENT_AIR))
-			m_transforming_liquid.push_back(p2);
+	
+	for (u16 i=0; i<7; i++)
+	{
+	    bool pos_ok;
+	    const v3s16 p2 = p + dirs[i];
+	    const MapNode n2 = getNodeNoEx(p2,&pos_ok);
+		
+	    if (pos_ok && (content_features(n2).liquid_type != LIQUID_NONE
+					    || n2.getContent() == CONTENT_AIR))
+		m_transforming_liquid.push_back(p2);
 	}
+
+	if(block)
+	    block->ResetCurrent();
 }
 
 bool Map::addNodeWithEvent(v3s16 p, MapNode n)
 {
 	MapEditEvent event;
 	event.type = MEET_ADDNODE;
 	event.p = p;
 	event.n = n;
 
 	bool succeeded = true;
-	try{
+	try
+	{
 		core::map<v3s16, MapBlock*> modified_blocks;
 		std::string st = std::string("");
 		addNodeAndUpdate(p, n, modified_blocks, st);
 
 		// Copy modified_blocks to event
@@ -1108,11 +1217,12 @@
 				i.atEnd()==false; i++)
 		{
 			event.modified_blocks.insert(i.getNode()->getKey(), false);
 		}
 	}
-	catch(InvalidPositionException &e){
+	catch(InvalidPositionException &e)
+	{
 		succeeded = false;
 	}
 
 	dispatchEvent(&event);
 
@@ -1124,11 +1234,12 @@
 	MapEditEvent event;
 	event.type = MEET_REMOVENODE;
 	event.p = p;
 
 	bool succeeded = true;
-	try{
+	try
+	{
 		core::map<v3s16, MapBlock*> modified_blocks;
 		removeNodeAndUpdate(p, modified_blocks);
 
 		// Copy modified_blocks to event
 		for(core::map<v3s16, MapBlock*>::Iterator
@@ -1136,11 +1247,12 @@
 				i.atEnd()==false; i++)
 		{
 			event.modified_blocks.insert(i.getNode()->getKey(), false);
 		}
 	}
-	catch(InvalidPositionException &e){
+	catch(InvalidPositionException &e)
+	{
 		succeeded = false;
 	}
 
 	dispatchEvent(&event);
 
@@ -1152,11 +1264,11 @@
 	MapEditEvent event;
 	event.type = MEET_ADDNODE;
 	event.p = p;
 	event.n = n;
 
-	MapNode nn = getNodeNoEx(p);
+	const MapNode nn = getNodeNoEx(p);
 	if (nn.getContent() != n.getContent())
 		return false;
 
 	setNode(p, n);
 	dispatchEvent(&event);
@@ -1164,58 +1276,99 @@
 	return true;
 }
 
 bool Map::dayNightDiffed(v3s16 blockpos)
 {
-	try{
+	try
+	{
 		v3s16 p = blockpos + v3s16(0,0,0);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+
+		b->ResetCurrent();
+		
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
+	
 	// Leading edges
-	try{
+	try
+	{
 		v3s16 p = blockpos + v3s16(-1,0,0);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+
+		b->ResetCurrent();
+
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
-	try{
+	
+	try
+	{
 		v3s16 p = blockpos + v3s16(0,-1,0);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+		
+		b->ResetCurrent();
+
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
-	try{
+	
+	try
+	{
 		v3s16 p = blockpos + v3s16(0,0,-1);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+		
+		b->ResetCurrent();
+
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
+	
 	// Trailing edges
-	try{
+	try
+	{
 		v3s16 p = blockpos + v3s16(1,0,0);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+		
+		b->ResetCurrent();
+
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
-	try{
+	
+	try
+	{
 		v3s16 p = blockpos + v3s16(0,1,0);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+		
+		b->ResetCurrent();
+
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
-	try{
+	
+	try
+	{
 		v3s16 p = blockpos + v3s16(0,0,1);
-		MapBlock *b = getBlockNoCreate(p);
-		if(b->dayNightDiffed())
+		MapBlock* const b = getBlockNoCreate(p);
+		const bool dnd = b->dayNightDiffed();
+		
+		b->ResetCurrent();
+
+		if(dnd)
 			return true;
 	}
 	catch(InvalidPositionException &e){}
 
 	return false;
@@ -1226,66 +1379,69 @@
 */
 void Map::timerUpdate(float dtime, float unload_timeout,
 		core::list<v3s16> *unloaded_blocks)
 {
 	bool save_before_unloading = (mapType() == MAPTYPE_SERVER);
-
 	core::list<v2s16> sector_deletion_queue;
 	u32 deleted_blocks_count = 0;
 	u32 saved_blocks_count = 0;
 
-	core::map<v2s16, MapSector*>::Iterator si;
-
 	beginSave();
-	si = m_sectors.getIterator();
+	m_sectors_mutex.Lock();
+	
+	core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
+	
 	for(; si.atEnd() == false; si++)
 	{
-		MapSector *sector = si.getNode()->getValue();
+	    MapSector* const sector = si.getNode()->getValue();
+	    bool all_blocks_deleted = true;
 
-		bool all_blocks_deleted = true;
+	    core::list<MapBlock*> blocks;
+	    sector->getBlocks(blocks);
 
-		core::list<MapBlock*> blocks;
-		sector->getBlocks(blocks);
+	    for(core::list<MapBlock*>::Iterator i = blocks.begin();
+		i != blocks.end(); i++)
+	    {
+		MapBlock* const block = (*i);
 
-		for(core::list<MapBlock*>::Iterator i = blocks.begin();
-				i != blocks.end(); i++)
-		{
-			MapBlock *block = (*i);
-
-			block->incrementUsageTimer(dtime);
-
-			if(block->getUsageTimer() > unload_timeout)
-			{
-				v3s16 p = block->getPos();
-
-				// Save if modified
-				if(block->getModified() != MOD_STATE_CLEAN
-						&& save_before_unloading)
-				{
-					saveBlock(block);
-					saved_blocks_count++;
-				}
+		block->incrementUsageTimer(dtime);
 
-				// Delete from memory
-				sector->deleteBlock(block);
+		if(block->getUsageTimer() > unload_timeout)
+		{
+		    const v3s16 p = block->getPos();
 
-				if(unloaded_blocks)
-					unloaded_blocks->push_back(p);
+		// Save if modified
+		    if(block->getModified() != MOD_STATE_CLEAN
+				    && save_before_unloading)
+		    {
+			saveBlock(block);
+			saved_blocks_count++;
+		    }
 
-				deleted_blocks_count++;
-			}
-			else
-			{
-				all_blocks_deleted = false;
-			}
-		}
+		// If not in current use.
+		    if(!block->GetCurrent())
+		    {
+		    // Delete from memory
+			sector->deleteBlock(block);
+
+			if(unloaded_blocks)
+			    unloaded_blocks->push_back(p);
+
+			deleted_blocks_count++;
+		    }
+		    else
+			all_blocks_deleted = false;
+		}
+		else
+		    all_blocks_deleted = false;
+	    }
 
-		if(all_blocks_deleted)
-		{
-			sector_deletion_queue.push_back(si.getNode()->getKey());
-		}
+	    if(all_blocks_deleted)
+		sector_deletion_queue.push_back(si.getNode()->getKey());
 	}
+	
+	m_sectors_mutex.Unlock();
 	endSave();
 
 	// Finally delete the empty sectors
 	deleteSectors(sector_deletion_queue);
 
@@ -1301,19 +1457,21 @@
 }
 
 void Map::deleteSectors(core::list<v2s16> &list)
 {
 	core::list<v2s16>::Iterator j;
+	JMutexAutoLock lock(m_sectors_mutex);
+
 	for(j=list.begin(); j!=list.end(); j++)
 	{
-		MapSector *sector = m_sectors[*j];
-		// If sector is in sector cache, remove it from there
-		if(m_sector_cache == sector)
-			m_sector_cache = NULL;
-		// Remove from map and delete
-		m_sectors.remove(*j);
-		delete sector;
+	    MapSector* const sector = m_sectors[*j];
+	// If sector is in sector cache, remove it from there
+	    if(m_sector_cache == sector)
+		m_sector_cache = NULL;
+	// Remove from map and delete
+	    m_sectors.remove(*j);
+	    delete sector;
 	}
 }
 
 void Map::PrintInfo(std::ostream &out)
 {
@@ -1325,10 +1483,11 @@
 enum NeighborType {
 	NEIGHBOR_UPPER,
 	NEIGHBOR_SAME_LEVEL,
 	NEIGHBOR_LOWER
 };
+
 struct NodeNeighbor {
 	MapNode n;
 	NeighborType t;
 	v3s16 p;
 };
@@ -1359,29 +1518,30 @@
 
 		/*
 			Get a queued transforming liquid node
 		*/
 		v3s16 p0 = m_transforming_liquid.pop_front();
-
 		MapNode n0 = getNodeNoEx(p0);
 
 		/*
 			Collect information about current node
 		 */
 		s8 liquid_level = -1;
 		u8 liquid_kind = CONTENT_IGNORE;
 		LiquidType liquid_type = content_features(n0.getContent()).liquid_type;
-		switch (liquid_type) {
-		case LIQUID_SOURCE:
+		
+		switch (liquid_type)
+		{
+		  case LIQUID_SOURCE:
 			liquid_level = LIQUID_LEVEL_SOURCE;
 			liquid_kind = content_features(n0.getContent()).liquid_alternative_flowing;
 			break;
-		case LIQUID_FLOWING:
+		  case LIQUID_FLOWING:
 			liquid_level = (n0.param2 & LIQUID_LEVEL_MASK);
 			liquid_kind = n0.getContent();
 			break;
-		case LIQUID_NONE:
+		  case LIQUID_NONE:
 			// if this is an air node, it *could* be transformed into a liquid. otherwise,
 			// continue with the next node.
 			if (n0.getContent() != CONTENT_AIR)
 				continue;
 			liquid_kind = CONTENT_AIR;
@@ -1399,22 +1559,27 @@
 		NodeNeighbor airs[6]; // surrounding air
 		int num_airs = 0;
 		NodeNeighbor neutrals[6]; // nodes that are solid or another kind of liquid
 		int num_neutrals = 0;
 		bool flowing_down = false;
-		for (u16 i = 0; i < 6; i++) {
+		
+		for (u16 i = 0; i < 6; i++)
+		{
 			NeighborType nt = NEIGHBOR_SAME_LEVEL;
-			switch (i) {
+			switch (i)
+			{
 				case 1:
 					nt = NEIGHBOR_UPPER;
 					break;
 				case 4:
 					nt = NEIGHBOR_LOWER;
 					break;
 			}
-			v3s16 npos = p0 + dirs[i];
-			NodeNeighbor nb = {getNodeNoEx(npos), nt, npos};
+			
+			const v3s16 npos = p0 + dirs[i];
+			const NodeNeighbor nb = {getNodeNoEx(npos), nt, npos};
+			
 			switch (content_features(nb.n.getContent()).liquid_type) {
 				case LIQUID_NONE:
 					if (nb.n.getContent() == CONTENT_AIR) {
 						airs[num_airs++] = nb;
 						// if the current node is a water source the neighbor
@@ -1542,38 +1707,44 @@
 			// set the liquid level and flow bit to 0
 			n0.param2 = ~(LIQUID_LEVEL_MASK | LIQUID_FLOW_DOWN_MASK);
 		}
 		n0.setContent(new_node_content);
 		setNode(p0, n0);
+
+	    // PB a traiter.
 		v3s16 blockpos = getNodeBlockPos(p0);
-		MapBlock *block = getBlockNoCreateNoEx(blockpos);
-		if(block != NULL) {
+		MapBlock* const block = getBlockNoCreateNoEx(blockpos);
+		if(block != NULL)
+		{
 			modified_blocks.insert(blockpos, block);
 			// If node emits light, MapBlock requires lighting update
 			if(content_features(n0).light_source != 0)
 				lighting_modified_blocks[block->getPos()] = block;
+			
+			block->ResetCurrent();
 		}
 
 		/*
 			enqueue neighbors for update if neccessary
 		 */
-		switch (content_features(n0.getContent()).liquid_type) {
-			case LIQUID_SOURCE:
-			case LIQUID_FLOWING:
-				// make sure source flows into all neighboring nodes
-				for (u16 i = 0; i < num_flows; i++)
-					if (flows[i].t != NEIGHBOR_UPPER)
-						m_transforming_liquid.push_back(flows[i].p);
-				for (u16 i = 0; i < num_airs; i++)
-					if (airs[i].t != NEIGHBOR_UPPER)
-						m_transforming_liquid.push_back(airs[i].p);
-				break;
-			case LIQUID_NONE:
-				// this flow has turned to air; neighboring flows might need to do the same
-				for (u16 i = 0; i < num_flows; i++)
-					m_transforming_liquid.push_back(flows[i].p);
-				break;
+		switch (content_features(n0.getContent()).liquid_type)
+		{
+		  case LIQUID_SOURCE:
+		  case LIQUID_FLOWING:
+		// make sure source flows into all neighboring nodes
+		    for (u16 i = 0; i < num_flows; i++)
+			if (flows[i].t != NEIGHBOR_UPPER)
+			    m_transforming_liquid.push_back(flows[i].p);
+		    for (u16 i = 0; i < num_airs; i++)
+			if (airs[i].t != NEIGHBOR_UPPER)
+			    m_transforming_liquid.push_back(airs[i].p);
+		    break;
+		  case LIQUID_NONE:
+		// this flow has turned to air; neighboring flows might need to do the same
+		    for (u16 i = 0; i < num_flows; i++)
+			m_transforming_liquid.push_back(flows[i].p);
+		    break;
 		}
 	}
 	//infostream<<"Map::transformLiquids(): loopcount="<<loopcount<<std::endl;
 	while (must_reflow.size() > 0)
 		m_transforming_liquid.push_back(must_reflow.pop_front());
@@ -1582,115 +1753,138 @@
 
 NodeMetadata* Map::getNodeMetadata(v3s16 p)
 {
 	v3s16 blockpos = getNodeBlockPos(p);
 	v3s16 p_rel = p - blockpos*MAP_BLOCKSIZE;
-	MapBlock *block = getBlockNoCreateNoEx(blockpos);
-	if (!block) {
+	MapBlock* block = getBlockNoCreateNoEx(blockpos);
+	if (!block)
+	{
 		infostream<<"Map::getNodeMetadata(): Need to emerge "
 				<<PP(blockpos)<<std::endl;
 		block = emergeBlock(blockpos, false);
 	}
-	if (!block) {
+	
+	if (!block)
+	{
 		infostream<<"WARNING: Map::getNodeMetadata(): Block not found"
 				<<std::endl;
 		return NULL;
 	}
-	NodeMetadata *meta = block->m_node_metadata.get(p_rel);
+	NodeMetadata* const meta = block->m_node_metadata.get(p_rel);
+	
+	block->ResetCurrent();
+
 	return meta;
 }
 
 NodeMetadata* Map::getNodeMetadataClone(v3s16 p)
 {
 	v3s16 blockpos = getNodeBlockPos(p);
 	v3s16 p_rel = p - blockpos*MAP_BLOCKSIZE;
-	MapBlock *block = getBlockNoCreateNoEx(blockpos);
-	if (!block) {
+	MapBlock* block = getBlockNoCreateNoEx(blockpos);
+	if (!block)
+	{
 		infostream<<"Map::getNodeMetadata(): Need to emerge "
 				<<PP(blockpos)<<std::endl;
 		block = emergeBlock(blockpos, false);
 	}
-	if (!block) {
+	
+	if (!block)
+	{
 		infostream<<"WARNING: Map::getNodeMetadata(): Block not found"
 				<<std::endl;
 		return NULL;
 	}
-	NodeMetadata *meta = block->m_node_metadata.getClone(p_rel);
+	NodeMetadata* const meta = block->m_node_metadata.getClone(p_rel);
+
+	block->ResetCurrent();
 	return meta;
 }
 
 void Map::setNodeMetadata(v3s16 p, NodeMetadata *meta)
 {
 	v3s16 blockpos = getNodeBlockPos(p);
 	v3s16 p_rel = p - blockpos*MAP_BLOCKSIZE;
-	MapBlock *block = getBlockNoCreateNoEx(blockpos);
-	if(!block){
+	MapBlock* block = getBlockNoCreateNoEx(blockpos);
+	if(!block)
+	{
 		infostream<<"Map::setNodeMetadata(): Need to emerge "
 				<<PP(blockpos)<<std::endl;
 		block = emergeBlock(blockpos, false);
 	}
+	
 	if(!block)
 	{
 		infostream<<"WARNING: Map::setNodeMetadata(): Block not found"
 				<<std::endl;
 		return;
 	}
+	
 	block->m_node_metadata.set(p_rel, meta);
+	block->ResetCurrent();
+	
 }
 
 void Map::removeNodeMetadata(v3s16 p)
 {
 	v3s16 blockpos = getNodeBlockPos(p);
 	v3s16 p_rel = p - blockpos*MAP_BLOCKSIZE;
-	MapBlock *block = getBlockNoCreateNoEx(blockpos);
+	MapBlock* const block = getBlockNoCreateNoEx(blockpos);
 	if(block == NULL)
 	{
 		infostream<<"WARNING: Map::removeNodeMetadata(): Block not found"
 				<<std::endl;
 		return;
 	}
+	
 	block->m_node_metadata.remove(p_rel);
+	block->ResetCurrent();
 }
 
-void Map::nodeMetadataStep(float dtime, core::map<v3s16, MapBlock*> &changed_blocks, ServerEnvironment *env)
+void Map::nodeMetadataStep(float dtime,
+		core::map<v3s16,MapBlock*> &changed_blocks,
+		ServerEnvironment *env)
 {
 	/*
 		NOTE:
 		Currently there is no way to ensure that all the necessary
 		blocks are loaded when this is run. (They might get unloaded)
 		NOTE: ^- Actually, that might not be so. In a quick test it
 		reloaded a block with a furnace when I walked back to it from
 		a distance.
 	*/
-	core::map<v2s16, MapSector*>::Iterator si;
-	si = m_sectors.getIterator();
+	JMutexAutoLock lock(m_sectors_mutex);
+	core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
+	
 	for(; si.atEnd() == false; si++)
 	{
-		MapSector *sector = si.getNode()->getValue();
-		core::list< MapBlock * > sectorblocks;
+		MapSector* const sector = si.getNode()->getValue();
+		core::list<MapBlock*> sectorblocks;
+		
 		sector->getBlocks(sectorblocks);
-		core::list< MapBlock * >::Iterator i;
+		
+		core::list<MapBlock*>::Iterator i;
 		for(i=sectorblocks.begin(); i!=sectorblocks.end(); i++)
 		{
-			MapBlock *block = *i;
-			bool changed = block->m_node_metadata.step(dtime,block->getPosRelative(),env);
+			MapBlock* const block = *i;
+			const bool changed = block->m_node_metadata.step(dtime,
+					block->getPosRelative(),env);
 			if(changed)
 				changed_blocks[block->getPos()] = block;
 		}
 	}
 }
 
 /*
 	ServerMap
 */
 
-ServerMap::ServerMap():
-	Map(dout_server),
-	m_seed(0),
-	m_database(NULL),
-	m_database_read(NULL),
-	m_database_write(NULL)
+ServerMap::ServerMap() : Map(dout_server),
+			 m_seed(0),
+			 m_database(NULL),
+			 m_database_read(NULL),
+			 m_database_write(NULL)
 {
 	char b[1024];
 	infostream<<__FUNCTION_NAME<<std::endl;
 
 	config_load("world","world.cfg");
@@ -1766,17 +1960,19 @@
 			v2s16 sectorpos(blockpos.X+x, blockpos.Z+z);
 			// Sector metadata is loaded from disk if not already loaded.
 			ServerMapSector *sector = createSector(sectorpos);
 			assert(sector);
 
-			for (s16 y=-1; y<=1; y++) {
+			for (s16 y=-1; y<=1; y++)
+			{
 				v3s16 p(blockpos.X+x, blockpos.Y+y, blockpos.Z+z);
 				//MapBlock *block = createBlock(p);
 				// 1) get from memory, 2) load from disk
-				MapBlock *block = emergeBlock(p, false);
+				MapBlock* block = emergeBlock(p, false);
 				// 3) create a blank one
-				if (block == NULL) {
+				if (!block)
+				{
 					block = createBlock(p);
 
 					/*
 						Block gets sunlight if this is true.
 
@@ -1786,10 +1982,11 @@
 					block->setIsUnderground(ug);
 				}
 
 				// Lighting will not be valid after make_chunk is called
 				block->setLightingExpired(true);
+				block->ResetCurrent();
 			}
 		}
 	}
 
 	/*
@@ -1831,128 +2028,142 @@
 	}
 
 	/*
 		Copy transforming liquid information
 	*/
-	while (data->transforming_liquid.size() > 0) {
+	while (data->transforming_liquid.size() > 0)
+	{
 		v3s16 p = data->transforming_liquid.pop_front();
 		m_transforming_liquid.push_back(p);
 	}
 
 	/*
 		Get central block
 	*/
-	MapBlock *block = getBlockNoCreateNoEx(data->blockpos);
+	MapBlock* const block = getBlockNoCreateNoEx(data->blockpos);
 	assert(block);
 
 	block->setBiome(data->biome);
 
 	{
-		v3s16 p0;
-		for (p0.X=0; p0.X<MAP_BLOCKSIZE; p0.X++) {
-		for (p0.Y=0; p0.Y<MAP_BLOCKSIZE; p0.Y++) {
-		for (p0.Z=0; p0.Z<MAP_BLOCKSIZE; p0.Z++) {
-			MapNode n = block->getNodeNoEx(p0);
-			if (n.getContent() == CONTENT_CHEST) {
-				// chest? give it metadata and put shit in it
-				NodeMetadata *f = block->m_node_metadata.get(p0);
-				Inventory *inv = f->getInventory();
-				if (inv) {
-					InventoryList *ilist = inv->getList("main");
-					if (ilist) {
-						if (myrand_range(0,2) == 0)
-							ilist->addItem(new CraftItem(CONTENT_CRAFTITEM_GRAPE,10,0));
-						if (myrand_range(0,2) == 0)
-							ilist->addItem(new CraftItem(CONTENT_CRAFTITEM_OERKKI_DUST,6,0));
-						if (myrand_range(0,3) == 0)
-							ilist->addItem(new ClothesItem(CONTENT_CLOTHESITEM_QUARTZ_MEDALLION,0,0));
-						if (myrand_range(0,3) == 0)
-							ilist->addItem(new ClothesItem(CONTENT_CLOTHESITEM_SPACESUIT_PANTS,0,0));
-						if (myrand_range(0,4) == 0) {
-							content_t c = CONTENT_CRAFTITEM_IRON_INGOT;
-							switch (myrand_range(0,4)) {
-							case 0:
-								c = CONTENT_CRAFTITEM_MITHRIL_UNBOUND;
-								break;
-							case 1:
-								c = CONTENT_CRAFTITEM_FLINT;
-								break;
-							case 2:
-								c = CONTENT_CRAFTITEM_TIN_INGOT;
-								break;
-							case 3:
-								c = CONTENT_CRAFTITEM_QUARTZ;
-								break;
-							default:;
-							}
-							ilist->addItem(new CraftItem(c,50,0));
-						}
-						if (myrand_range(0,4) == 0) {
-							content_t c = CONTENT_CRAFTITEM_RUBY;
-							switch (myrand_range(0,4)) {
-							case 0:
-								c = CONTENT_CRAFTITEM_TURQUOISE;
-								break;
-							case 1:
-								c = CONTENT_CRAFTITEM_AMETHYST;
-								break;
-							case 2:
-								c = CONTENT_CRAFTITEM_SAPPHIRE;
-								break;
-							case 3:
-								c = CONTENT_CRAFTITEM_SUNSTONE;
-								break;
-							default:;
-							}
-							ilist->addItem(new CraftItem(c,20,0));
-						}
-						if (myrand_range(0,5) == 0) {
-							uint16_t en = enchantment_create(ENCHANTMENT_LONGLASTING,3);
-							ilist->addItem(new ToolItem(CONTENT_TOOLITEM_MITHRIL_PICK,0,en));
-						}
-						if (ilist->getUsedSlots() == 0)
-							ilist->addItem(new CraftItem(CONTENT_CRAFTITEM_COAL,10,0));
-					}
+	    v3s16 p0;
+	    for (p0.X=0; p0.X<MAP_BLOCKSIZE; p0.X++) {
+	    for (p0.Y=0; p0.Y<MAP_BLOCKSIZE; p0.Y++) {
+		for (p0.Z=0; p0.Z<MAP_BLOCKSIZE; p0.Z++)
+		{
+		    const MapNode n = block->getNodeNoEx(p0);
+		    if (n.getContent() == CONTENT_CHEST)
+		    {
+		    // chest? give it metadata and put shit in it
+			NodeMetadata* const f = block->m_node_metadata.get(p0);
+			Inventory* const inv = f->getInventory();
+			if (inv)
+			{
+			    InventoryList* const ilist = inv->getList("main");
+			    if (ilist)
+			    {
+				if (myrand_range(0,2) == 0)
+				    ilist->addItem(new CraftItem(CONTENT_CRAFTITEM_GRAPE,10,0));
+				if (myrand_range(0,2) == 0)
+				    ilist->addItem(new CraftItem(CONTENT_CRAFTITEM_OERKKI_DUST,6,0));
+				if (myrand_range(0,3) == 0)
+				    ilist->addItem(new ClothesItem(CONTENT_CLOTHESITEM_QUARTZ_MEDALLION,0,0));
+				if (myrand_range(0,3) == 0)
+				    ilist->addItem(new ClothesItem(CONTENT_CLOTHESITEM_SPACESUIT_PANTS,0,0));
+				if (myrand_range(0,4) == 0)
+				{
+				    content_t c = CONTENT_CRAFTITEM_IRON_INGOT;
+				    switch (myrand_range(0,4)) {
+				      case 0:
+					c = CONTENT_CRAFTITEM_MITHRIL_UNBOUND;
+					break;
+				      case 1:
+					c = CONTENT_CRAFTITEM_FLINT;
+					break;
+				      case 2:
+					c = CONTENT_CRAFTITEM_TIN_INGOT;
+					break;
+				      case 3:
+					c = CONTENT_CRAFTITEM_QUARTZ;
+					break;
+				      default:;
+				    }
+				    ilist->addItem(new CraftItem(c,50,0));
 				}
-				continue;
+				if (myrand_range(0,4) == 0)
+				{
+				    content_t c = CONTENT_CRAFTITEM_RUBY;
+				    switch (myrand_range(0,4)) {
+				      case 0:
+					c = CONTENT_CRAFTITEM_TURQUOISE;
+					break;
+				      case 1:
+					c = CONTENT_CRAFTITEM_AMETHYST;
+					break;
+				      case 2:
+					c = CONTENT_CRAFTITEM_SAPPHIRE;
+					break;
+				      case 3:
+					c = CONTENT_CRAFTITEM_SUNSTONE;
+					break;
+				      default:;
+				    }
+				    ilist->addItem(new CraftItem(c,20,0));
+				}
+				if (myrand_range(0,5) == 0)
+				{
+				    uint16_t en = enchantment_create(ENCHANTMENT_LONGLASTING,3);
+				    ilist->addItem(new ToolItem(CONTENT_TOOLITEM_MITHRIL_PICK,0,en));
+				}
+				if (ilist->getUsedSlots() == 0)
+				    ilist->addItem(new CraftItem(CONTENT_CRAFTITEM_COAL,10,0));
+			    }
 			}
+			continue;
+		    }
 		}
-		}
-		}
+	    }
+	    }
 	}
 
 	/*
 		Update lighting
 		NOTE: This takes ~60ms, TODO: Investigate why
 	*/
 	{
-		core::map<v3s16, MapBlock*> lighting_update_blocks;
+	    core::map<v3s16, MapBlock*> lighting_update_blocks;
 		// Center block
-		lighting_update_blocks.insert(block->getPos(), block);
-		updateLighting(lighting_update_blocks, changed_blocks);
+	    lighting_update_blocks.insert(block->getPos(), block);
+	    updateLighting(lighting_update_blocks, changed_blocks);
 
-		/*
-			Set lighting to non-expired state in all of them.
-			This is cheating, but it is not fast enough if all of them
-			would actually be updated.
-		*/
-		for(s16 x=-1; x<=1; x++)
-		for(s16 y=-1; y<=1; y++)
-		for(s16 z=-1; z<=1; z++)
+	/*
+	  Set lighting to non-expired state in all of them.
+	  This is cheating, but it is not fast enough if all of them
+	  would actually be updated.
+	*/
+	    for(s16 x=-1; x<=1; x++)
+	    for(s16 y=-1; y<=1; y++)
+	    for(s16 z=-1; z<=1; z++)
+	    {
+		const v3s16 p = block->getPos()+v3s16(x,y,z);
+		MapBlock* const b = getBlockNoCreateNoEx(p);
+
+		if(b)
 		{
-			v3s16 p = block->getPos()+v3s16(x,y,z);
-			getBlockNoCreateNoEx(p)->setLightingExpired(false);
+		    b->setLightingExpired(false);
+		    b->ResetCurrent();
 		}
+	    }
 	}
 
 	/*
 		Go through changed blocks
 	*/
 	for(core::map<v3s16, MapBlock*>::Iterator i = changed_blocks.getIterator();
 			i.atEnd() == false; i++)
 	{
-		MapBlock *block = i.getNode()->getValue();
+		MapBlock* const block = i.getNode()->getValue();
 		assert(block);
 		/*
 			Update day/night difference cache of the MapBlocks
 		*/
 		block->updateDayNightDiff();
@@ -1964,66 +2175,69 @@
 
 	/*
 		Set central block as generated
 	*/
 	block->setGenerated(true);
+	block->ResetCurrent();
 
 	return block;
 }
 
-ServerMapSector * ServerMap::createSector(v2s16 p2d)
+ServerMapSector* ServerMap::createSector(v2s16 p2d)
 {
 	DSTACKF("%s: p2d=(%d,%d)",
 			__FUNCTION_NAME,
 			p2d.X, p2d.Y);
 
 	/*
 		Check if it exists already in memory
 	*/
-	ServerMapSector *sector = (ServerMapSector*)getSectorNoGenerateNoEx(p2d);
+	ServerMapSector* sector =
+	    (ServerMapSector*) getSectorNoGenerateNoEx(p2d);
 	if(sector != NULL)
 		return sector;
 
 	/*
 		Do not create over-limit
 	*/
 	if(p2d.X < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p2d.X > MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p2d.Y < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p2d.Y > MAP_GENERATION_LIMIT / MAP_BLOCKSIZE)
-		throw InvalidPositionException("createSector(): pos. over limit");
+			|| p2d.X > MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+			|| p2d.Y < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+			|| p2d.Y > MAP_GENERATION_LIMIT / MAP_BLOCKSIZE)
+	        throw InvalidPositionException("createSector(): pos. over limit");
 
 	/*
 		Generate blank sector
 	*/
 
 	sector = new ServerMapSector(this, p2d);
 
 	/*
 		Insert to container
 	*/
+	m_sectors_mutex.Lock();
 	m_sectors.insert(p2d, sector);
+	m_sectors_mutex.Unlock();
 
 	return sector;
 }
 
 /*
 	This is a quick-hand function for calling makeBlock().
 */
-MapBlock * ServerMap::generateBlock(
-		v3s16 p,
-		core::map<v3s16, MapBlock*> &modified_blocks
-)
+MapBlock* ServerMap::generateBlock(v3s16 p,
+		core::map<v3s16, MapBlock*> &modified_blocks)
 {
 	DSTACKF("%s: p=(%d,%d,%d)", __FUNCTION_NAME, p.X, p.Y, p.Z);
 
-	v2s16 p2d(p.X, p.Z);
+	const v2s16 p2d(p.X, p.Z);
 
 	/*
 		Do not generate over-limit
 	*/
-	if (blockpos_over_limit(p)) {
+	if (blockpos_over_limit(p))
+	{
 		infostream<<__FUNCTION_NAME<<": Block position over limit"<<std::endl;
 		throw InvalidPositionException("generateBlock(): pos. over limit");
 	}
 
 	/*
@@ -2043,16 +2257,16 @@
 	finishBlockMake(&data, modified_blocks);
 
 	/*
 		Get central block
 	*/
-	MapBlock *block = getBlockNoCreateNoEx(p);
+	MapBlock* const block = getBlockNoCreateNoEx(p);
 
 	return block;
 }
 
-MapBlock * ServerMap::createBlock(v3s16 p)
+MapBlock* ServerMap::createBlock(v3s16 p)
 {
 	DSTACKF("%s: p=(%d,%d,%d)",
 			__FUNCTION_NAME, p.X, p.Y, p.Z);
 
 	/*
@@ -2064,12 +2278,12 @@
 	|| p.Y > MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
 	|| p.Z < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
 	|| p.Z > MAP_GENERATION_LIMIT / MAP_BLOCKSIZE)
 		throw InvalidPositionException("createBlock(): pos. over limit");
 
-	v2s16 p2d(p.X, p.Z);
-	s16 block_y = p.Y;
+	const v2s16 p2d(p.X, p.Z);
+	const s16 block_y = p.Y;
 	/*
 		This will create or load a sector if not found in memory.
 		If block exists on disk, it will be loaded.
 
 		NOTE: On old save formats, this will be slow, as it generates
@@ -2099,46 +2313,49 @@
 
 	/*
 		Try to get a block from the sector
 	*/
 
-	MapBlock *block = sector->getBlockNoCreateNoEx(block_y);
+	MapBlock* const block = sector->getBlockNoCreateNoEx(block_y);
 	if(block)
 	{
 		if(block->isDummy())
 			block->unDummify();
 		return block;
 	}
+	
 	// Create blank
-	block = sector->createBlankBlock(block_y);
-	return block;
+	// PB A voir allocation.
+	MapBlock* const block2 = sector->createBlankBlock(block_y);
+	return block2;
 }
 
-MapBlock * ServerMap::emergeBlock(v3s16 p, bool allow_generate, bool *was_generated)
+MapBlock* ServerMap::emergeBlock(v3s16 p, bool allow_generate,
+		bool *was_generated)
 {
 	DSTACKF("%s: p=(%d,%d,%d), allow_generate=%d",
 			__FUNCTION_NAME,
 			p.X, p.Y, p.Z, allow_generate);
 	if (was_generated)
 		*was_generated = false;
 
 	{
-		MapBlock *block = getBlockNoCreateNoEx(p);
+		MapBlock* const block = getBlockNoCreateNoEx(p);
 		if(block && block->isDummy() == false)
 			return block;
 	}
 
 	{
-		MapBlock *block = loadBlock(p);
+		MapBlock* const block = loadBlock(p);
 		if(block)
 			return block;
 	}
 
 	if(allow_generate)
 	{
 		core::map<v3s16, MapBlock*> modified_blocks;
-		MapBlock *block = generateBlock(p, modified_blocks);
+		MapBlock* const block = generateBlock(p, modified_blocks);
 		if(block)
 		{
 			MapEditEvent event;
 			event.type = MEET_OTHER;
 			event.p = p;
@@ -2168,30 +2385,31 @@
 	/* determine from map generator noise functions */
 	mapgen::BlockMakeData d;
 	d.type = m_type;
 	d.seed = m_seed;
 
-	s16 level = mapgen::find_ground_level_from_noise(&d, p2d, 1);
+	const s16 level = mapgen::find_ground_level_from_noise(&d, p2d, 1);
 	return level;
 }
 
-void ServerMap::createDatabase() {
-	int e;
+void ServerMap::createDatabase()
+{
 	assert(m_database);
-	e = sqlite3_exec(m_database,
-		"CREATE TABLE IF NOT EXISTS `blocks` ("
+	const int e = sqlite3_exec(m_database,
+			"CREATE TABLE IF NOT EXISTS `blocks` ("
 			"`pos` INT NOT NULL PRIMARY KEY,"
 			"`data` BLOB"
-		");"
-	, NULL, NULL, NULL);
+			");"
+			, NULL, NULL, NULL);
 	if(e == SQLITE_ABORT)
 		throw FileNotGoodException("Could not create database structure");
 	else
 		infostream<<"Server: Database structure was created";
 }
 
-void ServerMap::verifyDatabase() {
+void ServerMap::verifyDatabase()
+{
 	if(m_database)
 		return;
 
 	{
 		char buff[1024];
@@ -2219,32 +2437,36 @@
 
 		if(needs_create)
 			createDatabase();
 
 		d = sqlite3_prepare(m_database, "SELECT `data` FROM `blocks` WHERE `pos`=? LIMIT 1", -1, &m_database_read, NULL);
-		if(d != SQLITE_OK) {
+		if(d != SQLITE_OK)
+		{
 			infostream<<"WARNING: Database read statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 			throw FileNotGoodException("map.sqlite: Cannot prepare read statement");
 		}
 
 		d = sqlite3_prepare(m_database, "REPLACE INTO `blocks` VALUES(?, ?)", -1, &m_database_write, NULL);
-		if(d != SQLITE_OK) {
+		if(d != SQLITE_OK)
+		{
 			infostream<<"WARNING: Database write statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 			throw FileNotGoodException("map.sqlite: Cannot prepare write statement");
 		}
 
 		d = sqlite3_prepare(m_database, "SELECT `pos` FROM `blocks`", -1, &m_database_list, NULL);
-		if(d != SQLITE_OK) {
+		if(d != SQLITE_OK)
+		{
 			infostream<<"WARNING: Database list statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 			throw FileNotGoodException("map.sqlite: Cannot prepare read statement");
 		}
 
 		infostream<<"Server: Database opened"<<std::endl;
 	}
 }
 
-sqlite3_int64 ServerMap::getBlockAsInteger(const v3s16 pos) {
+sqlite3_int64 ServerMap::getBlockAsInteger(const v3s16 pos)
+{
 	return (sqlite3_int64)pos.Z*16777216 +
 		(sqlite3_int64)pos.Y*4096 + (sqlite3_int64)pos.X;
 }
 
 void ServerMap::save(bool only_changed)
@@ -2258,29 +2480,36 @@
 	u32 block_count = 0;
 	u32 block_count_all = 0; // Number of blocks in memory
 
 	// Don't do anything with sqlite unless something is really saved
 	bool save_started = false;
+	JMutexAutoLock lock(m_sectors_mutex);
 
-	for (core::map<v2s16, MapSector*>::Iterator i = m_sectors.getIterator(); i.atEnd() == false; i++) {
-		ServerMapSector *sector = (ServerMapSector*)i.getNode()->getValue();
+	for (core::map<v2s16, MapSector*>::Iterator i = m_sectors.getIterator();
+	     i.atEnd() == false; i++)
+	{
+		ServerMapSector* const sector =
+		    (ServerMapSector*)i.getNode()->getValue();
 		assert(sector->getId() == MAPSECTOR_SERVER);
+		
 		core::list<MapBlock*> blocks;
 		sector->getBlocks(blocks);
+		
 		core::list<MapBlock*>::Iterator j;
 
-		for (j=blocks.begin(); j!=blocks.end(); j++) {
-			MapBlock *block = *j;
+		for (j=blocks.begin(); j!=blocks.end(); j++)
+		{
+			MapBlock* const block = *j;
 
 			block_count_all++;
 
-			if (
-				block->getModified() >= MOD_STATE_WRITE_NEEDED
-				|| only_changed == false
-			) {
+			if (block->getModified() >= MOD_STATE_WRITE_NEEDED
+					|| only_changed == false)
+			{
 				// Lazy beginSave()
-				if (!save_started) {
+				if (!save_started)
+				{
 					beginSave();
 					save_started = true;
 				}
 
 				saveBlock(block);
@@ -2292,11 +2521,12 @@
 		endSave();
 
 	/*
 		Only print if something happened or saved whole map
 	*/
-	if (only_changed == false || block_count != 0) {
+	if (only_changed == false || block_count != 0)
+	{
 		infostream<<"ServerMap: Written: "
 				<<block_count<<" block files"
 				<<", "<<block_count_all<<" blocks in memory."
 				<<std::endl;
 	}
@@ -2317,68 +2547,73 @@
 	return mod - ((-i) % mod);
 }
 
 v3s16 ServerMap::getIntegerAsBlock(sqlite3_int64 i)
 {
-	s32 x = unsignedToSigned(pythonmodulo(i, 4096), 2048);
+	const s32 x = unsignedToSigned(pythonmodulo(i, 4096), 2048);
 	i = (i - x) / 4096;
-	s32 y = unsignedToSigned(pythonmodulo(i, 4096), 2048);
+	const s32 y = unsignedToSigned(pythonmodulo(i, 4096), 2048);
 	i = (i - y) / 4096;
-	s32 z = unsignedToSigned(pythonmodulo(i, 4096), 2048);
+	const s32 z = unsignedToSigned(pythonmodulo(i, 4096), 2048);
 	return v3s16(x,y,z);
 }
 
 void ServerMap::listAllLoadableBlocks(core::list<v3s16> &dst)
 {
 	verifyDatabase();
 
-	while (sqlite3_step(m_database_list) == SQLITE_ROW) {
+	while (sqlite3_step(m_database_list) == SQLITE_ROW)
+	{
 		sqlite3_int64 block_i = sqlite3_column_int64(m_database_list, 0);
 		v3s16 p = getIntegerAsBlock(block_i);
 		dst.push_back(p);
 	}
 }
 
 void ServerMap::loadMapMeta()
 {
-	if (!config_get("world.seed")) {
+	if (!config_get("world.seed"))
+	{
 		m_seed = (
 			((uint64_t)(myrand()%0xffff)<<0)
 			+ ((uint64_t)(myrand()%0xffff)<<16)
 			+ ((uint64_t)(myrand()%0xffff)<<32)
 			+ ((uint64_t)(myrand()%0xffff)<<48)
 		);
 		config_set_int64("world.seed",m_seed);
-	}else{
-		m_seed = config_get_int64("world.seed");
 	}
+	else
+		m_seed = config_get_int64("world.seed");
 	m_type = MGT_DEFAULT;
-	if (config_get("world.map.type")) {
-		char* type = config_get("world.map.type");
-		if (!strcmp(type,"flat")) {
+	
+	if (config_get("world.map.type"))
+	{
+		const char* type = config_get("world.map.type");
+		if (!strcmp(type,"flat"))
 			m_type = MGT_FLAT;
-		}else{
+		else
 			config_set("world.map.type","default");
-		}
-	}else{
-		config_set("world.map.type","default");
 	}
+	else
+		config_set("world.map.type","default");
 }
 
-void ServerMap::beginSave() {
+void ServerMap::beginSave()
+{
 	verifyDatabase();
 	if(sqlite3_exec(m_database, "BEGIN;", NULL, NULL, NULL) != SQLITE_OK)
 		infostream<<"WARNING: beginSave() failed, saving might be slow.";
 }
 
-void ServerMap::endSave() {
+void ServerMap::endSave()
+{
 	verifyDatabase();
 	if(sqlite3_exec(m_database, "COMMIT;", NULL, NULL, NULL) != SQLITE_OK)
 		infostream<<"WARNING: endSave() failed, map might not have saved.";
 }
 
-void ServerMap::saveBlock(MapBlock *block)
+void ServerMap::saveBlock(MapBlock* const block)
 {
 	DSTACK(__FUNCTION_NAME);
 	/*
 		Dummy blocks are not written
 	*/
@@ -2434,11 +2669,12 @@
 
 void ServerMap::loadBlock(std::string *blob, v3s16 p3d, MapSector *sector, bool save_after_load)
 {
 	DSTACK(__FUNCTION_NAME);
 
-	try {
+	try
+	{
 		std::istringstream is(*blob, std::ios_base::binary);
 
 		u8 version = SER_FMT_VER_INVALID;
 		is.read((char*)&version, 1);
 
@@ -2478,12 +2714,15 @@
 		if (version < SER_FMT_VER_HIGHEST || save_after_load)
 			saveBlock(block);
 
 		// We just loaded it from, so it's up-to-date.
 		block->resetModified();
+		block->ResetCurrent();
 
-	} catch(SerializationError &e) {
+	}
+	catch(SerializationError &e)
+	{
 		infostream<<"WARNING: Invalid block data in database "
 				<<" (SerializationError). "
 				<<"what()="<<e.what()
 				<<std::endl;
 				//" Ignoring. A new one will be generated.
@@ -2499,11 +2738,12 @@
 	verifyDatabase();
 
 	if (sqlite3_bind_int64(m_database_read, 1, getBlockAsInteger(blockpos)) != SQLITE_OK)
 		infostream<<"WARNING: Could not bind block position for load: "
 			<<sqlite3_errmsg(m_database)<<std::endl;
-	if (sqlite3_step(m_database_read) == SQLITE_ROW) {
+	if (sqlite3_step(m_database_read) == SQLITE_ROW)
+	{
 		/*
 			Make sure sector is loaded
 		*/
 		MapSector *sector = createSector(p2d);
 
@@ -2537,41 +2777,37 @@
 
 /*
 	ClientMap
 */
 
-ClientMap::ClientMap(
-		Client *client,
-		MapDrawControl &control,
-		scene::ISceneNode* parent,
-		scene::ISceneManager* mgr,
-		s32 id
-):
-	Map(dout_client),
+ClientMap::ClientMap(Client* const client,
+		MapDrawControl& control,
+		scene::ISceneNode* const parent,
+		scene::ISceneManager* const mgr,
+		s32 id) : Map(dout_client),
 	scene::ISceneNode(parent, mgr, id),
 	m_client(client),
+	m_box(-BS*1000000,-BS*1000000,-BS*1000000,
+			BS*1000000,BS*1000000,BS*1000000),
 	m_control(control),
 	m_camera_position(0,0,0),
 	m_camera_direction(0,0,1),
-	m_camera_fov(PI)
+	m_camera_fov(PI),
+	m_render_trilinear(config_get_bool("client.video.trilinear")),
+	m_render_bilinear(config_get_bool("client.video.bilinear")),
+	m_render_anisotropic(config_get_bool("client.video.anisotropic")),
+	m_last_drawn_sectors()
 {
 	m_camera_mutex.Init();
 	assert(m_camera_mutex.IsInitialized());
-
-	m_box = core::aabbox3d<f32>(-BS*1000000,-BS*1000000,-BS*1000000,
-			BS*1000000,BS*1000000,BS*1000000);
-
-	m_render_trilinear = config_get_bool("client.video.trilinear");
-	m_render_bilinear = config_get_bool("client.video.bilinear");
-	m_render_anisotropic = config_get_bool("client.video.anisotropic");
 }
 
 ClientMap::~ClientMap()
 {
 }
 
-MapSector * ClientMap::emergeSector(v2s16 p2d)
+MapSector* ClientMap::emergeSector(v2s16 p2d)
 {
 	DSTACK(__FUNCTION_NAME);
 	// Check that it doesn't exist already
 	try{
 		return getSectorNoGenerate(p2d);
@@ -2579,14 +2815,14 @@
 	catch(InvalidPositionException &e)
 	{
 	}
 
 	// Create a sector
-	ClientMapSector *sector = new ClientMapSector(this, p2d);
+	ClientMapSector* const sector = new ClientMapSector(this, p2d);
 
 	{
-		//JMutexAutoLock lock(m_sector_mutex); // Bulk comment-out
+		JMutexAutoLock lock(m_sectors_mutex);
 		m_sectors.insert(p2d, sector);
 	}
 
 	return sector;
 }
@@ -2609,20 +2845,22 @@
 	v3s16 u0 = p1 - p0;
 	v3f uf = v3f(u0.X, u0.Y, u0.Z) * BS;
 	uf.normalize();
 	v3f p0f = v3f(p0.X, p0.Y, p0.Z) * BS;
 	u32 count = 0;
-	for (float s=start_off; s<d0+end_off; s+=step){
-		v3f pf = p0f + uf * s;
-		v3s16 p = floatToInt(pf, BS);
-		MapNode n = map->getNodeNoEx(p);
-		ContentFeatures &f = content_features(n);
-		if (
-			f.draw_type == CDT_CUBELIKE
-			|| f.draw_type == CDT_DIRTLIKE
-			|| f.draw_type == CDT_MELONLIKE
-		) {
+	
+	for (float s=start_off; s<d0+end_off; s+=step)
+	{
+		const v3f pf = p0f + uf * s;
+		const v3s16 p = floatToInt(pf, BS);
+		const MapNode n = map->getNodeNoEx(p);
+		const ContentFeatures& f = content_features(n);
+		
+		if (f.draw_type == CDT_CUBELIKE
+				|| f.draw_type == CDT_DIRTLIKE
+				|| f.draw_type == CDT_MELONLIKE)
+		{
 			count++;
 			if (count >= needed_count)
 				return true;
 		}
 		step *= stepfac;
@@ -2636,15 +2874,14 @@
 	DSTACK(__FUNCTION_NAME);
 
 	bool is_transparent_pass = pass == scene::ESNRP_TRANSPARENT;
 
 	std::string prefix;
-	if (pass == scene::ESNRP_SOLID) {
+	if (pass == scene::ESNRP_SOLID)
 		prefix = "CM: solid: ";
-	}else{
+	else
 		prefix = "CM: transparent: ";
-	}
 
 	/*
 		This is called two times per frame, reset on the non-transparent one
 	*/
 	if (pass == scene::ESNRP_SOLID)
@@ -2657,13 +2894,16 @@
 		machine is swapping a lot.
 	*/
 	int time1 = time(0);
 
 	m_camera_mutex.Lock();
+	
 	v3f camera_position = m_camera_position;
 	v3f camera_direction = m_camera_direction;
+	v3s16 camera_offset = m_camera_offset;
 	f32 camera_fov = m_camera_fov;
+	
 	m_camera_mutex.Unlock();
 
 	/*
 		Get all blocks and draw all visible ones
 	*/
@@ -2718,59 +2958,72 @@
 	core::map<v3s16, MapBlock*> drawset;
 
 	{
 	ScopeProfiler sp(g_profiler, prefix+"collecting blocks for drawing", SPT_AVG);
 
-	for(core::map<v2s16, MapSector*>::Iterator
-			si = m_sectors.getIterator();
+	for(core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
 			si.atEnd() == false; si++)
 	{
-		MapSector *sector = si.getNode()->getValue();
+	    	m_sectors_mutex.Lock();
+
+		MapSector* const sector = si.getNode()->getValue();
+
+		if(!sector)
+		{
+		    m_sectors_mutex.Unlock();
+		    continue;
+		}
+		
 		v2s16 sp = sector->getPos();
 
 		if(m_control.range_all == false)
 		{
-			if(sp.X < p_blocks_min.X
-			|| sp.X > p_blocks_max.X
-			|| sp.Y < p_blocks_min.Z
-			|| sp.Y > p_blocks_max.Z)
-				continue;
+		    if(sp.X < p_blocks_min.X || sp.X > p_blocks_max.X
+				    || sp.Y < p_blocks_min.Z
+				    || sp.Y > p_blocks_max.Z)
+			    continue;
 		}
 
-		core::list< MapBlock * > sectorblocks;
+		core::list<MapBlock*> sectorblocks;
+		
 		sector->getBlocks(sectorblocks);
+		m_sectors_mutex.Unlock();
 
 		/*
 			Loop through blocks in sector
 		*/
 
 		u32 sector_blocks_drawn = 0;
-
-		core::list< MapBlock * >::Iterator i;
+		core::list<MapBlock*>::Iterator i;
 		for(i=sectorblocks.begin(); i!=sectorblocks.end(); i++)
 		{
-			MapBlock *block = *i;
+			MapBlock* const block = *i;
 
+			if(!block)
+			    continue;
+			
 			/*
 				Compare block position to camera position, skip
 				if not seen on display
 			*/
 
-			if (block->mesh != NULL)
-				block->mesh->updateCameraOffset(m_camera_offset);
+			{
+			    JMutexAutoLock lock(block->mesh_mutex);
 
+			    if (block->mesh != NULL)
+				block->mesh->updateCameraOffset(camera_offset);
+			}
+			
 			float range = 100000 * BS;
 			if(m_control.range_all == false)
 				range = m_control.wanted_range * BS;
 
 			float d = 0.0;
 			if(isBlockInSight(block->getPos(), camera_position,
 					camera_direction, camera_fov,
 					range, &d) == false)
-			{
 				continue;
-			}
 
 			// This is ugly (spherical distance limit?)
 			/*if(m_control.range_all == false &&
 					d - 0.5*BS*MAP_BLOCKSIZE > range)
 				continue;*/
@@ -2792,37 +3045,37 @@
 
 				mesh_expired = block->getMeshExpired();
 
 				// Mesh has not been expired and there is no mesh:
 				// block has no content
-				if(block->mesh == NULL && mesh_expired == false){
+				if(block->mesh == NULL && mesh_expired == false)
+				{
 					blocks_in_range_without_mesh++;
 					continue;
 				}
 			}
 
-			f32 faraway = BS*100;
+			const f32 faraway = BS*100;
 			//f32 faraway = m_control.wanted_range * BS;
 
 			/*
 				This has to be done with the mesh_mutex unlocked
 			*/
 			// Pretty random but this should work somewhat nicely
-			if (
-				mesh_expired
-				&& (
-					d < faraway
-					|| mesh_update_count < 20
-					|| (m_control.range_all && mesh_update_count < 100)
-				)
-			) {
+			if (mesh_expired && (d < faraway || mesh_update_count < 20
+							|| (m_control.range_all && mesh_update_count < 100)))
+			{
 				mesh_update_count++;
 
+				JMutexAutoLock lock(block->mesh_mutex);
+
 				// Mesh has been expired: generate new mesh
-				if (block->mesh) {
-					m_client->addUpdateMeshTask(block->getPos(),false,true);
-					block->setMeshExpired(false);
+				if (block->mesh)
+				{
+				    m_client->addUpdateMeshTask(block->getPos(),
+						    false,true);
+				    block->setMeshExpired(false);
 				}
 
 				mesh_expired = false;
 			}
 #endif
@@ -2831,37 +3084,37 @@
 				Occlusion culling
 			*/
 
 			v3s16 cpn = block->getPos() * MAP_BLOCKSIZE;
 			cpn += v3s16(MAP_BLOCKSIZE/2, MAP_BLOCKSIZE/2, MAP_BLOCKSIZE/2);
+			
 			float step = BS*1;
 			float stepfac = 1.1;
 			float startoff = BS*1;
 			float endoff = -BS*MAP_BLOCKSIZE*1.42*1.42;
 			v3s16 spn = cam_pos_nodes + v3s16(0,0,0);
 			s16 bs2 = MAP_BLOCKSIZE/2 + 1;
 			u32 needed_count = 1;
-			if(
-				isOccluded(this, spn, cpn + v3s16(0,0,0),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(bs2,bs2,bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(bs2,bs2,-bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(bs2,-bs2,bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(bs2,-bs2,-bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(-bs2,bs2,bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(-bs2,bs2,-bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(-bs2,-bs2,bs2),
-						step, stepfac, startoff, endoff, needed_count) &&
-				isOccluded(this, spn, cpn + v3s16(-bs2,-bs2,-bs2),
-						step, stepfac, startoff, endoff, needed_count)
-			)
+			
+			if(isOccluded(this, spn, cpn + v3s16(0,0,0),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(bs2,bs2,bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(bs2,bs2,-bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(bs2,-bs2,bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(bs2,-bs2,-bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(-bs2,bs2,bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(-bs2,bs2,-bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(-bs2,-bs2,bs2),
+							step, stepfac, startoff, endoff, needed_count) &&
+					isOccluded(this, spn, cpn + v3s16(-bs2,-bs2,-bs2),
+							step, stepfac, startoff, endoff, needed_count))
 			{
 				blocks_occlusion_culled++;
 				continue;
 			}
 
@@ -2871,33 +3124,34 @@
 			/*
 				Ignore if mesh doesn't exist
 			*/
 			{
 				JMutexAutoLock lock(block->mesh_mutex);
+				MapBlockMesh* const mesh = block->mesh;
 
-				MapBlockMesh *mesh = block->mesh;
-
-				if (mesh == NULL) {
+				if (mesh == NULL)
+				{
 					blocks_in_range_without_mesh++;
 					continue;
 				}
 
-				block->mesh->isfar = (d > faraway);
+				mesh->isfar = d > faraway;
 			}
 
 			// Limit block count in case of a sudden increase
 			blocks_would_have_drawn++;
-			if (
-				blocks_drawn >= m_control.wanted_max_blocks
+			if (blocks_drawn >= m_control.wanted_max_blocks
 				&& m_control.range_all == false
-				&& d > m_control.wanted_min_range * BS
-			)
+					&& d > m_control.wanted_min_range * BS)
 				continue;
 
 			// Animate textures in block mesh
-			if (anim_textures && block->mesh->isAnimated()) {
-				//JMutexAutoLock lock(block->mesh_mutex); //needed?
+			if (anim_textures)
+			{
+			    JMutexAutoLock lock(block->mesh_mutex);
+
+			    if(block->mesh->isAnimated())
 				block->mesh->animate(anim_time);
 			}
 
 			// Add to set
 			drawset[block->getPos()] = block;
@@ -2914,52 +3168,55 @@
 	/*
 		Draw the selected MapBlocks
 	*/
 
 	{
-	ScopeProfiler sp(g_profiler, prefix+"drawing blocks", SPT_AVG);
-
+	const ScopeProfiler sp(g_profiler, prefix+"drawing blocks", SPT_AVG);
 	int timecheck_counter = 0;
-	for (core::map<v3s16, MapBlock*>::Iterator i = drawset.getIterator(); i.atEnd() == false; i++) {
-		{
-			timecheck_counter++;
-			if (timecheck_counter > 50) {
-				timecheck_counter = 0;
-				int time2 = time(0);
-				if (time2 > time1 + 4) {
-					infostream<<"ClientMap::renderMap(): "
-						"Rendering takes ages, returning."
-						<<std::endl;
-					return;
-				}
-			}
+	
+	for (core::map<v3s16, MapBlock*>::Iterator i = drawset.getIterator();
+	     i.atEnd() == false; i++)
+	{
+	        timecheck_counter++;
+		if (timecheck_counter > 50)
+		{
+		    timecheck_counter = 0;
+		    int time2 = time(0);
+		    if (time2 > time1 + 4)
+		    {
+			infostream<<"ClientMap::renderMap(): Rendering takes ages, returning."
+				  <<std::endl;
+			return;
+		    }
 		}
 
-		MapBlock *block = i.getNode()->getValue();
+		MapBlock* const block = i.getNode()->getValue();
 
 		/*
 			Draw the faces of the block
 		*/
 		{
 			JMutexAutoLock lock(block->mesh_mutex);
-
-			MapBlockMesh *mesh = block->mesh;
+			MapBlockMesh* const mesh = block->mesh;
+			
 			if (!mesh || !mesh->getMesh())
 				continue;
-			scene::SMesh *m = NULL;
-			if (mesh->isfar) {
+			
+			scene::SMesh* m = NULL;
+			if (mesh->isfar)
 				m = mesh->getFarMesh();
-			}else{
+			else
 				m = mesh->getMesh();
-			}
 			if (!m)
 				continue;
 
-			u32 c = m->getMeshBufferCount();
+			const u32 c = m->getMeshBufferCount();
 			bool stuff_actually_drawn = false;
-			for (u32 i=0; i<c; i++) {
-				scene::IMeshBuffer *buf = m->getMeshBuffer(i);
+			
+			for (u32 i=0; i<c; i++)
+			{
+				scene::IMeshBuffer* const buf = m->getMeshBuffer(i);
 				if (buf == NULL)
 					continue;
 
 				buf->getMaterial().setFlag(video::EMF_TRILINEAR_FILTER, m_render_trilinear);
 				buf->getMaterial().setFlag(video::EMF_BILINEAR_FILTER, m_render_bilinear);
@@ -2968,11 +3225,12 @@
 				const video::SMaterial& material = buf->getMaterial();
 				video::IMaterialRenderer* rnd =
 						driver->getMaterialRenderer(material.MaterialType);
 				bool transparent = (rnd && rnd->isTransparent());
 				// Render transparent on transparent pass and likewise.
-				if (transparent == is_transparent_pass) {
+				if (transparent == is_transparent_pass)
+				{
 					if (buf->getVertexCount() == 0)
 						errorstream<<"Block ["<<analyze_block(block)
 								<<"] contains an empty meshbuf"<<std::endl;
 					/*
 						This *shouldn't* hurt too much because Irrlicht
@@ -2984,30 +3242,31 @@
 					vertex_count += buf->getVertexCount();
 					meshbuffer_count++;
 					stuff_actually_drawn = true;
 				}
 			}
-			if (stuff_actually_drawn) {
+			if (stuff_actually_drawn)
 				blocks_had_pass_meshbuf++;
-			}else{
+			else
 				blocks_without_stuff++;
-			}
 		}
 	}
 	} // ScopeProfiler
 
 	// Log only on solid pass because values are the same
-	if(pass == scene::ESNRP_SOLID){
+	if(pass == scene::ESNRP_SOLID)
+	{
 		g_profiler->avg("CM: blocks in range", blocks_in_range);
 		g_profiler->avg("CM: blocks occlusion culled", blocks_occlusion_culled);
 		if(blocks_in_range != 0)
 			g_profiler->avg("CM: blocks in range without mesh (frac)",
 					(float)blocks_in_range_without_mesh/blocks_in_range);
 		g_profiler->avg("CM: blocks drawn", blocks_drawn);
 	}
 
 	g_profiler->avg(prefix+"vertices drawn", vertex_count);
+	
 	if(blocks_had_pass_meshbuf != 0)
 		g_profiler->avg(prefix+"meshbuffers per block",
 				(float)meshbuffer_count / (float)blocks_had_pass_meshbuf);
 	if(blocks_drawn != 0)
 		g_profiler->avg(prefix+"empty blocks (frac)",
@@ -3018,90 +3277,85 @@
 
 	/*infostream<<"renderMap(): is_transparent_pass="<<is_transparent_pass
 			<<", rendered "<<vertex_count<<" vertices."<<std::endl;*/
 }
 
-static bool getVisibleBrightness(
-	Map *map,
-	v3f p0,
-	v3f dir,
-	float step,
-	float step_multiplier,
-	float start_distance,
-	float end_distance,
-	u32 daylight_factor,
-	float sunlight_min_d,
-	int *result,
-	bool *sunlight_seen
-)
+static bool getVisibleBrightness(Map *map,v3f p0,v3f dir,
+	float step,float step_multiplier,float start_distance,
+	float end_distance,u32 daylight_factor,float sunlight_min_d,
+	int *result,bool *sunlight_seen)
 {
 	int brightness_sum = 0;
 	int brightness_count = 0;
 	float distance = start_distance;
+	
 	dir.normalize();
+	
 	v3f pf = p0;
 	pf += dir * distance;
+	
 	int noncount = 0;
 	bool nonlight_seen = false;
 	bool allow_allowing_non_sunlight_propagates = false;
 	bool allow_non_sunlight_propagates = false;
 
 	// Check content nearly at camera position
 	{
-		v3s16 p = floatToInt(p0 /*+ dir * 3*BS*/, BS);
-		MapNode n = map->getNodeNoEx(p);
-		ContentFeatures &nf = content_features(n.getContent());
+		const v3s16 p = floatToInt(p0 /*+ dir * 3*BS*/, BS);
+		const MapNode n = map->getNodeNoEx(p);
+		const ContentFeatures& nf = content_features(n.getContent());
+		
 		if (nf.param_type == CPT_LIGHT && !nf.sunlight_propagates)
 			allow_allowing_non_sunlight_propagates = true;
 	}
 	// If would start at CONTENT_IGNORE, start closer
 	{
-		v3s16 p = floatToInt(pf, BS);
-		MapNode n = map->getNodeNoEx(p);
-		if (n.getContent() == CONTENT_IGNORE) {
-			float newd = 2*BS;
+		const v3s16 p = floatToInt(pf, BS);
+		const MapNode n = map->getNodeNoEx(p);
+		
+		if (n.getContent() == CONTENT_IGNORE)
+		{
+			const float newd = 2*BS;
+			
 			pf = p0 + dir * 2*newd;
 			distance = newd;
 		}
 	}
 
-	for (int i=0; distance < end_distance; i++) {
+	for (int i=0; distance < end_distance; i++)
+	{
 		pf += dir * step;
 		distance += step;
 		step *= step_multiplier;
-		v3s16 p = floatToInt(pf, BS);
-		MapNode n = map->getNodeNoEx(p);
-		ContentFeatures &nf = content_features(n.getContent());
-		if (
-			allow_allowing_non_sunlight_propagates
-			&& i == 0
-			&& nf.param_type == CPT_LIGHT
-			&& !nf.sunlight_propagates
-		) {
+		
+		const v3s16 p = floatToInt(pf, BS);
+		const MapNode n = map->getNodeNoEx(p);
+		const ContentFeatures& nf = content_features(n.getContent());
+		
+		if (allow_allowing_non_sunlight_propagates
+				&& i == 0
+				&& nf.param_type == CPT_LIGHT
+				&& !nf.sunlight_propagates)
 			allow_non_sunlight_propagates = true;
-		}
 
-		if (
-			nf.param_type != CPT_LIGHT
-			|| (
-				!nf.sunlight_propagates
-				&& !allow_non_sunlight_propagates
-			)
-		) {
+		if (nf.param_type != CPT_LIGHT
+				|| (!nf.sunlight_propagates
+						&& !allow_non_sunlight_propagates))
+		{
 			nonlight_seen = true;
 			noncount++;
 			if (noncount >= 4)
 				break;
 			continue;
 		}
-		if (
-			distance >= sunlight_min_d
-			&& *sunlight_seen == false
-			&& nonlight_seen == false
-			&& n.getLight(LIGHTBANK_DAY) == LIGHT_SUN
-		)
+		
+		if (distance >= sunlight_min_d
+				&& *sunlight_seen == false
+				&& nonlight_seen == false
+				&& n.getLight(LIGHTBANK_DAY) == LIGHT_SUN)
 			*sunlight_seen = true;
+		
 		noncount = 0;
 		brightness_sum += decode_light(n.getLightBlend(daylight_factor));
 		brightness_count++;
 	}
 
@@ -3111,25 +3365,24 @@
 		return false;
 	*result = brightness_sum / brightness_count;
 	return true;
 }
 
-int ClientMap::getBackgroundBrightness(
-	float max_d,
-	u32 daylight_factor,
-	int oldvalue,
-	bool *sunlight_seen_result
-)
+int ClientMap::getBackgroundBrightness(float max_d,u32 daylight_factor,
+	int oldvalue,bool *sunlight_seen_result)
 {
 	static v3f z_directions[50] = {
 		v3f(-100, 0, 0)
 	};
 	static f32 z_offsets[sizeof(z_directions)/sizeof(*z_directions)] = {
 		-1000,
 	};
-	if (z_directions[0].X < -99) {
-		for (u32 i=0; i<sizeof(z_directions)/sizeof(*z_directions); i++) {
+	
+	if (z_directions[0].X < -99)
+	{
+		for (u32 i=0; i<sizeof(z_directions)/sizeof(*z_directions); i++)
+		{
 			z_directions[i] = v3f(
 				0.01 * myrand_range(-80, 80),
 				1.0,
 				0.01 * myrand_range(-80, 80)
 			);
@@ -3138,32 +3391,38 @@
 	}
 
 	//std::cerr<<"In goes "<<PP(m_camera_direction)<<", out comes ";
 
 	int sunlight_seen_count = 0;
-	float sunlight_min_d = max_d*0.8;
+	float sunlight_min_d = max_d * 0.8;
 	if (sunlight_min_d > 35*BS)
 		sunlight_min_d = 35*BS;
-
+	
+	m_camera_mutex.Lock();
+	const v3f camera_position = m_camera_position;
+	const v3f camera_direction = m_camera_direction;
+	m_camera_mutex.Unlock();
+	
 	core::array<int> values;
 
-	for (u32 i=0; i<sizeof(z_directions)/sizeof(*z_directions); i++) {
+	for (u32 i=0; i<sizeof(z_directions)/sizeof(*z_directions); i++)
+	{
 		v3f z_dir = z_directions[i];
 		z_dir.normalize();
 		core::CMatrix4<f32> a;
 		a.buildRotateFromTo(v3f(0,1,0), z_dir);
-		v3f dir = m_camera_direction;
+		v3f dir = camera_direction;
 		a.rotateVect(dir);
 		int br = 0;
 		float step = BS*1.5;
 		if (max_d > 35*BS)
 			step = max_d / 35 * 1.5;
 		float off = step * z_offsets[i];
 		bool sunlight_seen_now = false;
 		bool ok = getVisibleBrightness(
 			this,
-			m_camera_position,
+			camera_position,
 			dir,
 			step,
 			1.0,
 			max_d*0.6+off,
 			max_d,
@@ -3182,130 +3441,140 @@
 			break;
 	}
 
 	int brightness_sum = 0;
 	int brightness_count = 0;
+	
 	values.sort();
+	
 	u32 num_values_to_use = values.size();
-	if (num_values_to_use >= 10) {
+	
+	if (num_values_to_use >= 10)
 		num_values_to_use -= num_values_to_use/2;
-	}else if (num_values_to_use >= 7) {
+	else if (num_values_to_use >= 7)
 		num_values_to_use -= num_values_to_use/3;
-	}
 
 	u32 first_value_i = (values.size() - num_values_to_use) / 2;
-	for (u32 i=first_value_i; i < first_value_i+num_values_to_use; i++) {
+	for (u32 i=first_value_i; i < first_value_i+num_values_to_use; i++)
+	{
 		brightness_sum += values[i];
 		brightness_count++;
 	}
 
 	int ret = 0;
-	if (brightness_count == 0) {
-		MapNode n = getNodeNoEx(floatToInt(m_camera_position, BS));
-		if (content_features(n).param_type == CPT_LIGHT) {
+	if (brightness_count == 0)
+	{
+		const MapNode n = getNodeNoEx(floatToInt(camera_position, BS));
+		
+		if (content_features(n).param_type == CPT_LIGHT)
 			ret = decode_light(n.getLightBlend(daylight_factor));
-		}else{
+		else
 			ret = oldvalue;
-		}
-	}else{
-		ret = brightness_sum / brightness_count;
 	}
+	else
+		ret = brightness_sum / brightness_count;
 
 	*sunlight_seen_result = (sunlight_seen_count > 0);
 	return ret;
 }
 
 void ClientMap::renderPostFx()
 {
-	// Sadly ISceneManager has no "post effects" render pass, in that case we
-	// could just register for that and handle it in renderMap().
+    // Sadly ISceneManager has no "post effects" render pass, in that case we
+    // could just register for that and handle it in renderMap().
 
 	m_camera_mutex.Lock();
-	v3f camera_position = m_camera_position;
+	const v3f camera_position = m_camera_position;
 	m_camera_mutex.Unlock();
 	video::SColor post_effect_color(0,0,0,0);
 
-	if (m_client->getSleepAlpha() > 0) {
-		post_effect_color = video::SColor(m_client->getSleepAlpha(),0,0,0);
-	}else{
-		MapNode n = getNodeNoEx(floatToInt(camera_position, BS));
-
-		// - If the player is in a solid node, make everything black.
-		// - If the player is in liquid, draw a semi-transparent overlay.
-		ContentFeatures &f = content_features(n);
-		post_effect_color = f.post_effect_color;
-		if (
-			f.draw_type == CDT_CUBELIKE
-			|| f.draw_type == CDT_DIRTLIKE
-			|| f.draw_type == CDT_MELONLIKE
-		) {
-			post_effect_color = video::SColor(255, 0, 0, 0);
-		}
-	}
-	if (post_effect_color.getAlpha() != 0) {
-		// Draw a full-screen rectangle
-		video::IVideoDriver* driver = SceneManager->getVideoDriver();
-		v2u32 ss = driver->getScreenSize();
-		core::rect<s32> rect(0,0, ss.X, ss.Y);
-		driver->draw2DRectangle(post_effect_color, rect);
-	}
-
-	if (m_client->getServerSuffocation()) {
-		u16 a = m_client->getAir();
-		if (a < 50) {
-			char buff[1024];
-			u8 c = 255-(a*5);
-			const video::SColor color(c,255,255,255);
-			const video::SColor colors[] = {color,color,color,color};
-
-			if (path_get((char*)"texture",(char*)"low_air.png",1,buff,1024)) {
-				video::IVideoDriver* driver = SceneManager->getVideoDriver();
-				v2u32 ss = driver->getScreenSize();
-				video::ITexture *texture = driver->getTexture(buff);
-				core::rect<s32> rect(0,0,ss.X,ss.Y);
-				driver->draw2DImage(
-					texture,
-					rect,
-					core::rect<s32>(
-						core::position2d<s32>(0,0),
-						core::dimension2di(texture->getOriginalSize())
-					),
-					NULL,
-					colors,
-					true
-				);
-			}
+	if (m_client->getSleepAlpha() > 0)
+	    post_effect_color = video::SColor(m_client->getSleepAlpha(),0,0,0);
+	else
+	{
+	    const MapNode n = getNodeNoEx(floatToInt(camera_position, BS));
+	// - If the player is in a solid node, make everything black.
+	// - If the player is in liquid, draw a semi-transparent overlay.
+	    const ContentFeatures& f = content_features(n);
+		
+	    post_effect_color = f.post_effect_color;
+		
+	    if (f.draw_type == CDT_CUBELIKE
+			    || f.draw_type == CDT_DIRTLIKE
+			    || f.draw_type == CDT_MELONLIKE)
+		post_effect_color = video::SColor(255, 0, 0, 0);
+	}
+	
+	if (post_effect_color.getAlpha() != 0)
+	{
+	// Draw a full-screen rectangle
+	    video::IVideoDriver* const driver = SceneManager->getVideoDriver();
+	    const v2u32 ss = driver->getScreenSize();
+	    const core::rect<s32> rect(0,0, ss.X, ss.Y);
+		
+	    driver->draw2DRectangle(post_effect_color, rect);
+	}
+
+	if (m_client->getServerSuffocation())
+	{
+	    const u16 a = m_client->getAir();
+	    if (a < 50)
+	    {
+		char buff[1024];
+		const u8 c = 255 - (a*5);
+		const video::SColor color(c,255,255,255);
+		const video::SColor colors[] = {color,color,color,color};
+
+		if (path_get((char*)"texture",(char*)"low_air.png",1,buff,1024))
+		{
+		    video::IVideoDriver* const driver = SceneManager->getVideoDriver();
+		    const v2u32 ss = driver->getScreenSize();
+		    video::ITexture* const texture = driver->getTexture(buff);
+		    const core::rect<s32> rect(0,0,ss.X,ss.Y);
+				
+		    driver->draw2DImage(texture,rect,
+				    core::rect<s32>(core::position2d<s32>(0,0),
+						    core::dimension2di(texture->getOriginalSize())),
+				    NULL,colors,true);
 		}
+	    }
 	}
 }
 
 void ClientMap::expireMeshes(bool only_daynight_diffed)
 {
 	TimeTaker timer("expireMeshes()");
+	core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
+    // PB Lock ?
+	
+	m_sectors_mutex.Lock();
 
-	core::map<v2s16, MapSector*>::Iterator si;
-	si = m_sectors.getIterator();
-	for (; si.atEnd() == false; si++) {
-		MapSector *sector = si.getNode()->getValue();
+	for (; si.atEnd() == false; si++)
+	{
+	    MapSector* const sector = si.getNode()->getValue();
+	    core::list<MapBlock*> sectorblocks;
+		
+	    sector->getBlocks(sectorblocks);
 
-		core::list< MapBlock * > sectorblocks;
-		sector->getBlocks(sectorblocks);
+	    core::list<MapBlock*>::Iterator i;
+	    for (i=sectorblocks.begin(); i!=sectorblocks.end(); i++)
+	    {
+		MapBlock* const block = *i;
 
-		core::list< MapBlock * >::Iterator i;
-		for (i=sectorblocks.begin(); i!=sectorblocks.end(); i++) {
-			MapBlock *block = *i;
+		if (only_daynight_diffed
+				&& block->dayNightDiffed() == false)
+		    continue;
 
-			if (only_daynight_diffed && block->dayNightDiffed() == false)
-				continue;
-
-			{
-				JMutexAutoLock lock(block->mesh_mutex);
-				if (block->mesh != NULL)
-					block->setMeshExpired(true);
-			}
+		{
+		    JMutexAutoLock lock(block->mesh_mutex);
+		    if (block->mesh != NULL)
+			block->setMeshExpired(true);
 		}
+	    }
 	}
+	
+	m_sectors_mutex.Unlock();
 }
 
 void ClientMap::PrintInfo(std::ostream &out)
 {
 	out<<"ClientMap: ";
@@ -3331,25 +3600,23 @@
 void MapVoxelManipulator::emerge(VoxelArea a, s32 caller_id)
 {
 	TimeTaker timer1("emerge", &emerge_time);
 
 	// Units of these are MapBlocks
-	v3s16 p_min = getNodeBlockPos(a.MinEdge);
-	v3s16 p_max = getNodeBlockPos(a.MaxEdge);
-
-	VoxelArea block_area_nodes
-			(p_min*MAP_BLOCKSIZE, (p_max+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
+	const v3s16 p_min = getNodeBlockPos(a.MinEdge);
+	const v3s16 p_max = getNodeBlockPos(a.MaxEdge);
+	const VoxelArea block_area_nodes(p_min * MAP_BLOCKSIZE,
+			(p_max + 1) * MAP_BLOCKSIZE-v3s16(1,1,1));
 
 	addArea(block_area_nodes);
 
 	for(s32 z=p_min.Z; z<=p_max.Z; z++)
 	for(s32 y=p_min.Y; y<=p_max.Y; y++)
 	for(s32 x=p_min.X; x<=p_max.X; x++)
 	{
-		v3s16 p(x,y,z);
-		core::map<v3s16, bool>::Node *n;
-		n = m_loaded_blocks.find(p);
+		const v3s16 p(x,y,z);
+		core::map<v3s16, bool>::Node* const n = m_loaded_blocks.find(p);
 		if(n != NULL)
 			continue;
 
 		bool block_data_inexistent = false;
 		try
@@ -3360,29 +3627,31 @@
 					<<" ("<<p.X<<","<<p.Y<<","<<p.Z<<")"
 					<<" wanted area: ";
 			a.print(infostream);
 			infostream<<std::endl;*/
 
-			MapBlock *block = m_map->getBlockNoCreate(p);
+			MapBlock* const block = m_map->getBlockNoCreate(p);
 			if(block->isDummy())
 				block_data_inexistent = true;
 			else
 				block->copyTo(*this);
+			block->ResetCurrent();
 		}
 		catch(InvalidPositionException &e)
 		{
 			block_data_inexistent = true;
 		}
 
 		if(block_data_inexistent)
 		{
-			VoxelArea a(p*MAP_BLOCKSIZE, (p+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
+			const VoxelArea a(p*MAP_BLOCKSIZE, (p+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
+			
 			// Fill with VOXELFLAG_INEXISTENT
 			for(s32 z=a.MinEdge.Z; z<=a.MaxEdge.Z; z++)
 			for(s32 y=a.MinEdge.Y; y<=a.MaxEdge.Y; y++)
 			{
-				s32 i = m_area.index(a.MinEdge.X,y,z);
+				const s32 i = m_area.index(a.MinEdge.X,y,z);
 				memset(&m_flags[i], VOXELFLAG_INEXISTENT, MAP_BLOCKSIZE);
 			}
 		}
 
 		m_loaded_blocks.insert(p, !block_data_inexistent);
@@ -3408,47 +3677,52 @@
 
 	/*
 		Initialize block cache
 	*/
 	v3s16 blockpos_last;
-	MapBlock *block = NULL;
+	MapBlock* block = NULL;
 	bool block_checked_in_modified = false;
 
 	for (s32 z=m_area.MinEdge.Z; z<=m_area.MaxEdge.Z; z++)
 	for (s32 y=m_area.MinEdge.Y; y<=m_area.MaxEdge.Y; y++)
-	for (s32 x=m_area.MinEdge.X; x<=m_area.MaxEdge.X; x++) {
-		v3s16 p(x,y,z);
+	for (s32 x=m_area.MinEdge.X; x<=m_area.MaxEdge.X; x++)
+	{
+		const v3s16 p(x,y,z);
 
 		u8 f = m_flags[m_area.index(p)];
 		if (f & (VOXELFLAG_NOT_LOADED|VOXELFLAG_INEXISTENT))
 			continue;
 
-		MapNode &n = m_data[m_area.index(p)];
-
-		v3s16 blockpos = getNodeBlockPos(p);
+		MapNode& n = m_data[m_area.index(p)];
+		const v3s16 blockpos = getNodeBlockPos(p);
 
-		if (block == NULL || blockpos != blockpos_last) {
+		if (block == NULL || blockpos != blockpos_last)
+		{
 			block = m_map->getBlockNoCreate(blockpos);
 			blockpos_last = blockpos;
 			block_checked_in_modified = false;
+			if(block)
+			    block->ResetCurrent();
 		}
 
 		// Calculate relative position in block
-		v3s16 relpos = p - blockpos * MAP_BLOCKSIZE;
+		const v3s16 relpos = p - blockpos * MAP_BLOCKSIZE;
 
 		// Don't continue if nothing has changed here
 		bool is_valid_position;
-		if (block->getNode(relpos,&is_valid_position) == n || !is_valid_position)
+		if (block->getNode(relpos,&is_valid_position) == n
+				|| !is_valid_position)
 			continue;
 
 		//m_map->setNode(m_area.MinEdge + p, n);
 		block->setNode(relpos, n);
 
 		/*
 			Make sure block is in modified_blocks
 		*/
-		if (block_checked_in_modified == false) {
+		if (block_checked_in_modified == false)
+		{
 			modified_blocks[blockpos] = block;
 			block_checked_in_modified = true;
 		}
 	}
 }
@@ -3473,17 +3747,17 @@
 		v3s16 blockpos_min, v3s16 blockpos_max)
 {
 	TimeTaker timer1("initialEmerge", &emerge_time);
 
 	// Units of these are MapBlocks
-	v3s16 p_min = blockpos_min;
-	v3s16 p_max = blockpos_max;
-
-	VoxelArea block_area_nodes
-			(p_min*MAP_BLOCKSIZE, (p_max+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
-
-	u32 size_MB = block_area_nodes.getVolume()*4/1000000;
+	const v3s16 p_min = blockpos_min;
+	const v3s16 p_max = blockpos_max;
+	const VoxelArea block_area_nodes
+			(p_min*MAP_BLOCKSIZE,
+					(p_max+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
+	const u32 size_MB = block_area_nodes.getVolume()*4/1000000;
+	
 	if(size_MB >= 1)
 	{
 		infostream<<"initialEmerge: area: ";
 		block_area_nodes.print(infostream);
 		infostream<<" ("<<size_MB<<"MB)";
@@ -3494,26 +3768,25 @@
 
 	for(s32 z=p_min.Z; z<=p_max.Z; z++)
 	for(s32 y=p_min.Y; y<=p_max.Y; y++)
 	for(s32 x=p_min.X; x<=p_max.X; x++)
 	{
-		v3s16 p(x,y,z);
-		core::map<v3s16, bool>::Node *n;
-		n = m_loaded_blocks.find(p);
+		const v3s16 p(x,y,z);
+		core::map<v3s16, bool>::Node* const n = m_loaded_blocks.find(p);
 		if(n != NULL)
 			continue;
 
 		bool block_data_inexistent = false;
 		try
 		{
 			TimeTaker timer1("emerge load", &emerge_load_time);
-
-			MapBlock *block = m_map->getBlockNoCreate(p);
+			MapBlock* const block = m_map->getBlockNoCreate(p);
 			if(block->isDummy())
 				block_data_inexistent = true;
 			else
 				block->copyTo(*this);
+			block->ResetCurrent();
 		}
 		catch(InvalidPositionException &e)
 		{
 			block_data_inexistent = true;
 		}
@@ -3521,11 +3794,12 @@
 		if(block_data_inexistent)
 		{
 			/*
 				Mark area inexistent
 			*/
-			VoxelArea a(p*MAP_BLOCKSIZE, (p+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
+			const VoxelArea a(p*MAP_BLOCKSIZE,
+					(p+1)*MAP_BLOCKSIZE-v3s16(1,1,1));
 			// Fill with VOXELFLAG_INEXISTENT
 			for(s32 z=a.MinEdge.Z; z<=a.MaxEdge.Z; z++)
 			for(s32 y=a.MinEdge.Y; y<=a.MaxEdge.Y; y++)
 			{
 				s32 i = m_area.index(a.MinEdge.X,y,z);
@@ -3544,22 +3818,28 @@
 		return;
 
 	/*
 		Copy data of all blocks
 	*/
-	for (core::map<v3s16, bool>::Iterator i = m_loaded_blocks.getIterator(); i.atEnd() == false; i++) {
-		v3s16 p = i.getNode()->getKey();
-		bool existed = i.getNode()->getValue();
-		if (existed == false) {
+	for (core::map<v3s16, bool>::Iterator i = m_loaded_blocks.getIterator();
+	     i.atEnd() == false; i++)
+	{
+		const v3s16 p = i.getNode()->getKey();
+		const bool existed = i.getNode()->getValue();
+		
+		if (existed == false)
+		{
 			// The Great Bug was found using this
-			/*infostream<<"ManualMapVoxelManipulator::blitBackAll: "
-					<<"Inexistent ("<<p.X<<","<<p.Y<<","<<p.Z<<")"
-					<<std::endl;*/
+			/*infostream << "ManualMapVoxelManipulator::blitBackAll: "
+					<< "Inexistent (" << p.X << "," << p.Y << "," << p.Z<<")"
+					<< std::endl;*/
 			continue;
 		}
-		MapBlock *block = m_map->getBlockNoCreateNoEx(p);
-		if (block == NULL) {
+		
+		MapBlock* const block = m_map->getBlockNoCreateNoEx(p);
+		if (block == NULL)
+		{
 			infostream<<"WARNING: "<<__FUNCTION_NAME
 					<<": got NULL block "
 					<<"("<<p.X<<","<<p.Y<<","<<p.Z<<")"
 					<<std::endl;
 			continue;
@@ -3567,10 +3847,11 @@
 
 		block->copyFrom(*this);
 
 		if (modified_blocks)
 			modified_blocks->insert(p, block);
+		block->ResetCurrent();
 	}
 }
 
 void ManualMapVoxelManipulator::blitBackAllWithMeta(
 		core::map<v3s16, MapBlock*> * modified_blocks)
@@ -3579,22 +3860,28 @@
 		return;
 
 	/*
 		Copy data of all blocks
 	*/
-	for (core::map<v3s16, bool>::Iterator i = m_loaded_blocks.getIterator(); i.atEnd() == false; i++) {
-		v3s16 p = i.getNode()->getKey();
-		bool existed = i.getNode()->getValue();
-		if (existed == false) {
+	for (core::map<v3s16, bool>::Iterator i = m_loaded_blocks.getIterator();
+	     i.atEnd() == false; i++)
+	{
+		const v3s16 p = i.getNode()->getKey();
+		const bool existed = i.getNode()->getValue();
+		
+		if (existed == false)
+		{
 			// The Great Bug was found using this
 			/*infostream<<"ManualMapVoxelManipulator::blitBackAll: "
-					<<"Inexistent ("<<p.X<<","<<p.Y<<","<<p.Z<<")"
-					<<std::endl;*/
+			  <<"Inexistent ("<<p.X<<","<<p.Y<<","<<p.Z<<")"
+			  <<std::endl;*/
 			continue;
 		}
-		MapBlock *block = m_map->getBlockNoCreateNoEx(p);
-		if (block == NULL) {
+		
+		MapBlock* const block = m_map->getBlockNoCreateNoEx(p);
+		if (block == NULL)
+		{
 			infostream<<"WARNING: "<<__FUNCTION_NAME
 					<<": got NULL block "
 					<<"("<<p.X<<","<<p.Y<<","<<p.Z<<")"
 					<<std::endl;
 			continue;
@@ -3602,34 +3889,42 @@
 
 		block->copyFrom(*this);
 
 		if (modified_blocks)
 			modified_blocks->insert(p, block);
+		block->ResetCurrent();
 	}
 	if (!modified_blocks)
 		return;
+	
 	// iterate over the modified blocks search for
 	// nodes that have metadata that shouldn't
 	// nodes that don't have metadata that should
 	// nodes that have the wrong metadata
-	for (core::map<v3s16, MapBlock*>::Iterator i = modified_blocks->getIterator(); i.atEnd() == false; i++) {
-		MapBlock *block = i.getNode()->getValue();
+	for (core::map<v3s16,MapBlock*>::Iterator i = modified_blocks->getIterator(); i.atEnd() == false; i++)
+	{
+		MapBlock* const block = i.getNode()->getValue();
 		if (block == NULL)
-			continue;
+		    continue;
+		
 		v3s16 p0;
 		for(p0.X=0; p0.X<MAP_BLOCKSIZE; p0.X++)
 		for(p0.Y=0; p0.Y<MAP_BLOCKSIZE; p0.Y++)
-		for(p0.Z=0; p0.Z<MAP_BLOCKSIZE; p0.Z++) {
-			MapNode n = block->getNodeNoEx(p0);
-			if (content_features(n).initial_metadata != NULL) {
-				NodeMetadata *f = content_features(n).initial_metadata;
-				NodeMetadata *a = block->m_node_metadata.get(p0);
-				if (!a || f->typeId() != a->typeId())
-					block->m_node_metadata.set(p0,f->clone());
-			}else if (block->m_node_metadata.get(p0) != NULL) {
-				block->m_node_metadata.remove(p0);
-			}
+		for(p0.Z=0; p0.Z<MAP_BLOCKSIZE; p0.Z++)
+		{
+		    const MapNode n = block->getNodeNoEx(p0);
+			
+		    if (content_features(n).initial_metadata != NULL)
+		    {
+			NodeMetadata* const f =
+			    content_features(n).initial_metadata;
+			NodeMetadata* const a = block->m_node_metadata.get(p0);
+			if (!a || f->typeId() != a->typeId())
+			    block->m_node_metadata.set(p0,f->clone());
+		    }
+		    else if (block->m_node_metadata.get(p0) != NULL)
+			block->m_node_metadata.remove(p0);
 		}
 	}
 }
 
 //END
diff -rU5 voxelands-v1709.00old/src/map.h voxelands-v1709.00good/src/map.h
--- voxelands-v1709.00old/src/map.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/map.h	2024-10-27 15:35:49.792238926 +0100
@@ -102,11 +102,11 @@
 	{
 	}
 
 	MapEditEvent * clone()
 	{
-		MapEditEvent *event = new MapEditEvent();
+		MapEditEvent* const event = new MapEditEvent();
 		event->type = type;
 		event->p = p;
 		event->n = n;
 		for(core::map<v3s16, bool>::Iterator
 				i = modified_blocks.getIterator();
@@ -120,18 +120,20 @@
 	}
 };
 
 class MapEventReceiver
 {
-public:
+    public:
+	virtual ~MapEventReceiver() {};
+	
 	// event shall be deleted by caller after the call.
 	virtual void onMapEditEvent(MapEditEvent *event) = 0;
 };
 
 class Map /*: public NodeContainer*/
 {
-public:
+    public:
 
 	Map(std::ostream &dout);
 	virtual ~Map();
 
 	/*virtual u16 nodeContainerId() const
@@ -155,34 +157,34 @@
 	void addEventReceiver(MapEventReceiver *event_receiver);
 	void removeEventReceiver(MapEventReceiver *event_receiver);
 	// event shall be deleted by caller after the call.
 	void dispatchEvent(MapEditEvent *event);
 
-	// On failure returns NULL
-	MapSector * getSectorNoGenerateNoExNoLock(v2s16 p2d);
 	// Same as the above (there exists no lock anymore)
-	MapSector * getSectorNoGenerateNoEx(v2s16 p2d);
+	MapSector* getSectorNoGenerateNoEx(v2s16 p2d);
 	// On failure throws InvalidPositionException
-	MapSector * getSectorNoGenerate(v2s16 p2d);
+	MapSector* getSectorNoGenerate(v2s16 p2d);
 	// Gets an existing sector or creates an empty one
 	//MapSector * getSectorCreate(v2s16 p2d);
 
 	/*
 		This is overloaded by ClientMap and ServerMap to allow
 		their differing fetch methods.
 	*/
-	virtual MapSector * emergeSector(v2s16 p){ return NULL; }
-	virtual MapSector * emergeSector(v2s16 p,
-			core::map<v3s16, MapBlock*> &changed_blocks){ return NULL; }
+	virtual MapSector* emergeSector(v2s16 p){ return NULL; }
+	virtual MapSector* emergeSector(v2s16 p,
+			core::map<v3s16, MapBlock*> &changed_blocks)
+		{ return NULL; }
 
-	// Returns InvalidPositionException if not found
-	MapBlock * getBlockNoCreate(v3s16 p);
 	// Returns NULL if not found
-	MapBlock * getBlockNoCreateNoEx(v3s16 p);
-
+	MapBlock* getBlockNoCreateNoEx(v3s16 p);
+	// Returns InvalidPositionException if not found
+	MapBlock* getBlockNoCreate(v3s16 p);
+	
 	/* Server overrides */
-	virtual MapBlock * emergeBlock(v3s16 p, bool allow_generate=true, bool *was_generated=NULL)
+	virtual MapBlock* emergeBlock(v3s16 p, bool allow_generate=true,
+			bool *was_generated=NULL)
 	{ return getBlockNoCreateNoEx(p); }
 
 	// Returns InvalidPositionException if not found
 	bool isNodeUnderground(v3s16 p);
 
@@ -229,11 +231,12 @@
 
 	/*
 		These handle lighting but not faces.
 	*/
 	void addNodeAndUpdate(v3s16 p, MapNode n,
-			core::map<v3s16, MapBlock*> &modified_blocks, std::string &player_name);
+			core::map<v3s16, MapBlock*> &modified_blocks,
+			std::string &player_name);
 	void removeNodeAndUpdate(v3s16 p,
 			core::map<v3s16, MapBlock*> &modified_blocks);
 
 	/*
 		Wrappers for the latter ones.
@@ -301,31 +304,36 @@
 	NodeMetadata* getNodeMetadata(v3s16 p);
 	NodeMetadata* getNodeMetadataClone(v3s16 p);
 	void setNodeMetadata(v3s16 p, NodeMetadata *meta);
 	void removeNodeMetadata(v3s16 p);
 	void nodeMetadataStep(float dtime,
-			core::map<v3s16, MapBlock*> &changed_blocks, ServerEnvironment *env);
-
-	/*
-		Misc.
-	*/
-	core::map<v2s16, MapSector*> *getSectorsPtr(){return &m_sectors;}
+			core::map<v3s16, MapBlock*> &changed_blocks,
+			ServerEnvironment *env);
 
+    protected:
+	
+	// On failure returns NULL
+	MapSector* getSectorNoGenerateNoExNoLock(v2s16 p2d);
+	
+        // Returns NULL if not found
+	MapBlock* getBlockNoCreateNoExNoLock(v3s16 p3d);
+	
 	/*
 		Variables
 	*/
 
-protected:
+    protected:
 
 	std::ostream &m_dout;
 
 	core::map<MapEventReceiver*, bool> m_event_receivers;
 
 	core::map<v2s16, MapSector*> m_sectors;
+	JMutex m_sectors_mutex;
 
 	// Be sure to set this to NULL when the cached sector is deleted
-	MapSector *m_sector_cache;
+	MapSector* m_sector_cache;
 	v2s16 m_sector_cache_p;
 
 	// Queued transforming water nodes
 	UniqueQueue<v3s16> m_transforming_liquid;
 };
@@ -336,11 +344,11 @@
 	This is the only map class that is able to generate map.
 */
 
 class ServerMap : public Map
 {
-public:
+    public:
 	ServerMap();
 	~ServerMap();
 
 	s32 mapType() const
 	{
@@ -379,11 +387,12 @@
 		Forcefully get a block from somewhere.
 		- Memory
 		- Load from disk
 		- Generate
 	*/
-	MapBlock * emergeBlock(v3s16 p, bool allow_generate=true, bool *was_generated=NULL);
+	MapBlock * emergeBlock(v3s16 p, bool allow_generate = true,
+			bool* was_generated = NULL);
 
 	// Helper for placing objects on ground level
 	s16 findGroundLevel(v2s16 p2d);
 
 	/*
@@ -417,11 +426,11 @@
 	virtual void PrintInfo(std::ostream &out);
 
 	uint64_t getSeed(){ return m_seed; }
 	MapGenType getType() {return m_type;}
 
-private:
+    private:
 	// Seed used for all kinds of randomness
 	uint64_t m_seed;
 	MapGenType m_type;
 
 	/*
@@ -473,19 +482,17 @@
 */
 
 class ClientMap : public Map, public scene::ISceneNode
 {
 public:
-	ClientMap(
-			Client *client,
-			MapDrawControl &control,
-			scene::ISceneNode* parent,
-			scene::ISceneManager* mgr,
-			s32 id
-	);
+	ClientMap(Client* const client,
+		        MapDrawControl& control,
+			scene::ISceneNode* const parent,
+			scene::ISceneManager* const mgr,
+			s32 id);
 
-	~ClientMap();
+	virtual ~ClientMap();
 
 	s32 mapType() const
 	{
 		return MAPTYPE_CLIENT;
 	}
@@ -547,11 +554,11 @@
 	}
 
 private:
 	Client *m_client;
 
-	core::aabbox3d<f32> m_box;
+	const core::aabbox3d<f32> m_box;
 
 	// This is the master heightmap mesh
 	//scene::SMesh *mesh;
 	//JMutex mesh_mutex;
 
@@ -561,13 +568,13 @@
 	v3f m_camera_direction;
 	f32 m_camera_fov;
 	v3s16 m_camera_offset;
 	JMutex m_camera_mutex;
 
-	bool m_render_trilinear;
-	bool m_render_bilinear;
-	bool m_render_anisotropic;
+	const bool m_render_trilinear;
+	const bool m_render_bilinear;
+	const bool m_render_anisotropic;
 
 	core::map<v2s16, bool> m_last_drawn_sectors;
 };
 
 #endif
diff -rU5 voxelands-v1709.00old/src/mapblock.cpp voxelands-v1709.00good/src/mapblock.cpp
--- voxelands-v1709.00old/src/mapblock.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapblock.cpp	2024-10-27 17:14:58.467515259 +0100
@@ -29,96 +29,123 @@
 #include "map.h"
 // For g_settings
 #include "main.h"
 #include "light.h"
 #include <sstream>
+
 #ifndef SERVER
-#include "sound.h"
+# include "sound.h"
+# include "xsync.h"
 #endif
 
 /*
 	MapBlock
 */
 
-MapBlock::MapBlock(Map *parent, v3s16 pos, bool dummy):
+MapBlock::MapBlock(Map* const parent,const v3s16 pos,const bool dummy):
 	has_spawn_area(false),
 	spawn_area(0,0,0),
 	last_spawn(0),
 	m_parent(parent),
 	m_pos(pos),
 	m_biome(BIOME_UNKNOWN),
+	data(NULL),
 	m_modified(MOD_STATE_WRITE_NEEDED),
 	is_underground(false),
 	m_lighting_expired(true),
 	m_day_night_differs(false),
 	m_generated(false),
 	m_timestamp(BLOCK_TIMESTAMP_UNDEFINED),
 	m_usage_timer(0)
 {
-	data = NULL;
 	if (dummy == false)
 		reallocate();
 
-	//m_spawn_timer = -10000;
-
 #ifndef SERVER
-	m_mesh_expired = false;
-	mesh_mutex.Init();
 	mesh = NULL;
+	mesh_mutex.Init();
+	m_mesh_expired = false;
+	mesh_current = 0;
+	X1SyncSet(&mesh_current,0);
 #endif
 }
 
 MapBlock::~MapBlock()
 {
 #ifndef SERVER
 	{
 		JMutexAutoLock lock(mesh_mutex);
 
-		if (mesh) {
-			delete mesh;
-			mesh = NULL;
+		if (mesh)
+		{
+			delete mesh;mesh = NULL;
 		}
 #if USE_AUDIO == 1
-		for (std::map<v3s16,MapBlockSound>::iterator i = m_sounds.begin(); i != m_sounds.end(); i++) {
+		for (std::map<v3s16,MapBlockSound>::iterator i = m_sounds.begin(); i != m_sounds.end(); i++)
+		{
 			sound_stop_single(i->second.id);
 		}
 #endif
 	}
 #endif
 
 	if (data)
 		delete[] data;
 }
 
+void MapBlock::SetCurrent()
+{
+#ifndef SERVER // Only on client
+	X1SyncBSet(&mesh_current);
+#endif
+}
+
+void MapBlock::ResetCurrent()
+{
+#ifndef SERVER // Only on client
+	X1SyncBReset(&mesh_current);
+#endif
+}
+
+int MapBlock::GetCurrent()
+{
+#ifndef SERVER // Only on client
+	return X1SyncGet(&mesh_current);
+#else
+	return 0;
+#endif
+}
+
 bool MapBlock::isValidPositionParent(v3s16 p)
 {
 	if (isValidPosition(p.X,p.Y,p.Z))
 		return true;
 	return m_parent->isValidPosition(getPosRelative() + p);
 }
 
 MapNode MapBlock::getNodeParent(v3s16 p, bool *is_valid_position)
 {
 	if (isValidPosition(p.X,p.Y,p.Z) == false)
-		return m_parent->getNodeNoEx(getPosRelative() + p, is_valid_position);
-	if (data == NULL) {
+		return m_parent->getNodeNoEx(getPosRelative() + p,
+				is_valid_position);
+	if (data == NULL)
+	{
 		if (is_valid_position)
 			*is_valid_position = false;
 		return MapNode(CONTENT_IGNORE);
 	}
 	if (is_valid_position)
 		*is_valid_position = true;
-	return data[p.Z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + p.Y*MAP_BLOCKSIZE + p.X];
+	return data[p.Z * MAP_BLOCKSIZE2 + p.Y * MAP_BLOCKSIZE + p.X];
 }
 
 void MapBlock::setNodeParent(v3s16 p, MapNode & n)
 {
-	if (isValidPosition(p.X,p.Y,p.Z) == false) {
+	if (isValidPosition(p.X,p.Y,p.Z) == false)
 		m_parent->setNode(getPosRelative() + p, n);
-	}else{
-		data[p.Z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + p.Y*MAP_BLOCKSIZE + p.X] = n;
-	}
+	else
+		data[p.Z * MAP_BLOCKSIZE2 + p.Y * MAP_BLOCKSIZE + p.X] = n;
 }
 
 /*
 	Propagates sunlight down through the block.
 	Doesn't modify nodes that are not affected by sunlight.
@@ -141,35 +168,39 @@
 bool MapBlock::propagateSunlight(core::map<v3s16, bool> & light_sources,
 		bool remove_light, bool *black_air_left)
 {
 	// Whether the sunlight at the top of the bottom block is valid
 	bool block_below_is_valid = true;
+	const v3s16 pos_relative = getPosRelative();
 
-	v3s16 pos_relative = getPosRelative();
-
-	for (s16 x=0; x<MAP_BLOCKSIZE; x++) {
-		for (s16 z=0; z<MAP_BLOCKSIZE; z++) {
+	for (s16 x=0; x<MAP_BLOCKSIZE; x++)
+	{
+		for (s16 z=0; z<MAP_BLOCKSIZE; z++)
+		{
 			bool no_sunlight = false;
 			//bool no_top_block = false;
 			// Check if node above block has sunlight
 			bool is_valid_position;
 			MapNode np = getNodeParent(v3s16(x, MAP_BLOCKSIZE, z), &is_valid_position);
-			if (is_valid_position) {
-				if (np.getContent() == CONTENT_IGNORE) {
+			if (is_valid_position)
+			{
+				if (np.getContent() == CONTENT_IGNORE)
 					// Trust heuristics
 					no_sunlight = is_underground;
-				}else if (np.getLight(LIGHTBANK_DAY) != LIGHT_SUN) {
+				else if (np.getLight(LIGHTBANK_DAY) != LIGHT_SUN)
 					no_sunlight = true;
-				}
-			}else{
+			}
+			else
+			{
 				//no_top_block = true;
 
 				// NOTE: This makes over-ground roofed places sunlighted
 				// Assume sunlight, unless is_underground==true
-				if (is_underground) {
+				if (is_underground)
 					no_sunlight = true;
-				}else{
+				else
+				{
 					MapNode n = getNodeNoEx(v3s16(x, MAP_BLOCKSIZE-1, z));
 					//if(n.getContent() == CONTENT_WATER || n.getContent() == CONTENT_WATERSOURCE)
 					if (content_features(n).sunlight_propagates == false)
 						no_sunlight = true;
 				}
@@ -183,29 +214,32 @@
 			// This makes difference to diminishing in water.
 			bool stopped_to_solid_object = false;
 
 			u8 current_light = no_sunlight ? 0 : LIGHT_SUN;
 
-			for (; y >= 0; y--) {
+			for (; y >= 0; y--)
+			{
 				v3s16 pos(x, y, z);
-				MapNode &n = getNodeRef(pos);
-				ContentFeatures &f = content_features(n);
+				MapNode& n = getNodeRef(pos);
+				const ContentFeatures& f = content_features(n);
 
-				if (current_light != 0 && (current_light != LIGHT_SUN || !f.sunlight_propagates)) {
-					if (!f.light_propagates) {
+				if (current_light != 0 && (current_light != LIGHT_SUN || !f.sunlight_propagates))
+				{
+					if (!f.light_propagates)
+					{
 						// A solid object is on the way.
 						stopped_to_solid_object = true;
 
 						// Light stops.
 						current_light = 0;
-					}else{
+					}
+					else
 						// Diminish light
 						current_light = diminish_light(current_light);
-					}
 				}
 
-				u8 old_light = n.getLight(LIGHTBANK_DAY);
+				const u8 old_light = n.getLight(LIGHTBANK_DAY);
 
 				if (current_light > old_light || remove_light)
 					n.setLight(LIGHTBANK_DAY, current_light);
 
 				if (diminish_light(current_light) != 0)
@@ -224,28 +258,28 @@
 				Check if the node below the block has proper sunlight at top.
 				If not, the block below is invalid.
 
 				Ignore non-transparent nodes as they always have no light
 			*/
-			try {
-				if (block_below_is_valid) {
+			try
+			{
+				if (block_below_is_valid)
+				{
 					MapNode n = getNodeParent(v3s16(x, -1, z));
-					if (content_features(n).light_propagates) {
-						if (
-							n.getLight(LIGHTBANK_DAY) == LIGHT_SUN
-							&& sunlight_should_go_down == false
-						) {
+					if (content_features(n).light_propagates)
+					{
+						if (n.getLight(LIGHTBANK_DAY) == LIGHT_SUN
+								&& sunlight_should_go_down == false)
 							block_below_is_valid = false;
-						}else if (
-							n.getLight(LIGHTBANK_DAY) != LIGHT_SUN
-							&& sunlight_should_go_down == true
-						) {
+						else if (n.getLight(LIGHTBANK_DAY) != LIGHT_SUN
+								&& sunlight_should_go_down == true)
 							block_below_is_valid = false;
-						}
 					}
 				}
-			}catch(InvalidPositionException &e) {
+			}
+			catch(InvalidPositionException &e)
+			{
 				// Just no block below, no need to panic.
 			}
 		}
 	}
 
@@ -284,13 +318,13 @@
 	bool differs = false;
 
 	/*
 		Check if any lighting value differs
 	*/
-	for(u32 i=0; i<MAP_BLOCKSIZE*MAP_BLOCKSIZE*MAP_BLOCKSIZE; i++)
+	for(u32 i=0; i<MAP_BLOCKSIZE3; i++)
 	{
-		MapNode &n = data[i];
+		const MapNode& n = data[i];
 		if(n.getLight(LIGHTBANK_DAY) != n.getLight(LIGHTBANK_NIGHT))
 		{
 			differs = true;
 			break;
 		}
@@ -301,13 +335,13 @@
 		just air. If it is, differ = false
 	*/
 	if(differs)
 	{
 		bool only_air = true;
-		for(u32 i=0; i<MAP_BLOCKSIZE*MAP_BLOCKSIZE*MAP_BLOCKSIZE; i++)
+		for(u32 i=0; i<MAP_BLOCKSIZE3; i++)
 		{
-			MapNode &n = data[i];
+			const MapNode& n = data[i];
 			if(n.getContent() != CONTENT_AIR)
 			{
 				only_air = false;
 				break;
 			}
@@ -372,12 +406,11 @@
 		os.write((char*)&flags, 1);
 
 		if (version > 21)
 			os.write((char*)&m_biome,1);
 
-		u32 nodecount = MAP_BLOCKSIZE*MAP_BLOCKSIZE*MAP_BLOCKSIZE;
-
+		const u32 nodecount = MAP_BLOCKSIZE3;
 		u32 sl = MapNode::serializedLength(version);
 
 		/*
 			Get data
 		*/
@@ -387,15 +420,13 @@
 			data[i].serialize(&databuf_nodelist[i*sl], version);
 		}
 
 		// Create buffer with different parameters sorted
 		SharedBuffer<u8> databuf(nodecount*sl);
-		for (u32 i=0; i<nodecount; i++) {
-			for (u32 k=0; k<sl; k++) {
+		for (u32 i=0; i<nodecount; i++)
+			for (u32 k=0; k<sl; k++)
 				databuf[i+(nodecount*k)] = databuf_nodelist[(i*sl)+k];
-			}
-		}
 
 		/*
 			Compress data to output stream
 		*/
 
@@ -416,13 +447,13 @@
 {
 	if (!ser_ver_supported(version))
 		throw VersionMismatchException("ERROR: MapBlock format not supported");
 
 	{
-		u32 nodecount = MAP_BLOCKSIZE*MAP_BLOCKSIZE*MAP_BLOCKSIZE;
-
+		const u32 nodecount = MAP_BLOCKSIZE3;
 		u8 flags;
+		
 		is.read((char*)&flags, 1);
 		is_underground = (flags & 0x01) ? true : false;
 		m_day_night_differs = (flags & 0x02) ? true : false;
 		m_lighting_expired = (flags & 0x04) ? true : false;
 		m_generated = (flags & 0x08) ? false : true;
@@ -438,28 +469,31 @@
 		if (s.size() != nodecount*sl)
 			throw SerializationError("MapBlock::deSerialize: decompress resulted in size"
 						" other than nodecount*nodelength");
 
 		// deserialize nodes from buffer
-		for (u32 i=0; i<nodecount; i++) {
+		for (u32 i=0; i<nodecount; i++)
+		{
 			SharedBuffer<u8> buf(sl);
-			for (u32 k=0; k<sl; k++) {
+			for (u32 k=0; k<sl; k++)
 				buf[k] = s[i+(nodecount*k)];
-			}
 			data[i].deSerialize(*buf, version);
 		}
 
 		/*
 			NodeMetadata
 		*/
 		// Ignore errors
-		try{
+		try
+		{
 			std::ostringstream oss(std::ios_base::binary);
 			decompressZlib(is, oss);
 			std::istringstream iss(oss.str(), std::ios_base::binary);
 			m_node_metadata.deSerialize(iss);
-		}catch(SerializationError &e) {
+		}
+		catch(SerializationError &e)
+		{
 			dstream<<"WARNING: MapBlock::deSerialize(): Ignoring an error"
 					<<" while deserializing node metadata"<<std::endl;
 		}
 	}
 }
@@ -493,65 +527,58 @@
 	*/
 	if(version >= 9)
 	{
 		u16 count = readU16(is);
 		// Not supported and length not known if count is not 0
-		if(count != 0){
+		if(count != 0)
+		{
 			dstream<<"WARNING: MapBlock::deSerializeDiskExtra(): "
 					<<"Ignoring stuff coming at and after MBOs"<<std::endl;
 			return;
 		}
 	}
 
 	/*
 		Versions up from 15 have static objects.
 	*/
 	if(version >= 15)
-	{
 		m_static_objects.deSerialize(is);
-	}
 
 	// Timestamp
 	if(version >= 17)
-	{
 		setTimestamp(readU32(is));
-	}
 	else
-	{
 		setTimestamp(BLOCK_TIMESTAMP_UNDEFINED);
-	}
 }
 
 /*
 	Get a quick string to describe what a block actually contains
 */
 std::string analyze_block(MapBlock *block)
 {
 	if(block == NULL)
-	{
 		return "NULL";
-	}
 
 	std::ostringstream desc;
 
 	v3s16 p = block->getPos();
-	char spos[20];
-	snprintf(spos, 20, "(%2d,%2d,%2d), ", p.X, p.Y, p.Z);
+	char spos[32];
+	snprintf(spos, 32, "(%2d,%2d,%2d), ", p.X, p.Y, p.Z);
 	desc<<spos;
 
 	switch(block->getModified())
 	{
-	case MOD_STATE_CLEAN:
+	  case MOD_STATE_CLEAN:
 		desc<<"CLEAN,           ";
 		break;
-	case MOD_STATE_WRITE_AT_UNLOAD:
+	  case MOD_STATE_WRITE_AT_UNLOAD:
 		desc<<"WRITE_AT_UNLOAD, ";
 		break;
-	case MOD_STATE_WRITE_NEEDED:
+	  case MOD_STATE_WRITE_NEEDED:
 		desc<<"WRITE_NEEDED,    ";
 		break;
-	default:
+	  default:
 		desc<<"unknown getModified()="+itos(block->getModified())+", ";
 	}
 
 	if(block->isGenerated())
 		desc<<"is_gen [X], ";
@@ -574,13 +601,11 @@
 		desc<<"lighting_exp [X], ";
 	else
 		desc<<"lighting_exp [ ], ";
 
 	if(block->isDummy())
-	{
 		desc<<"Dummy, ";
-	}
 	else
 	{
 		// We'll just define the numbers here, don't want to include
 		// content_mapnode.h
 		const content_t content_water = 2;
@@ -593,10 +618,11 @@
 		bool some_ignore = false;
 		bool full_air = true;
 		bool some_air = false;
 		bool trees = false;
 		bool water = false;
+		
 		for(s16 z0=0; z0<MAP_BLOCKSIZE; z0++)
 		for(s16 y0=0; y0<MAP_BLOCKSIZE; y0++)
 		for(s16 x0=0; x0<MAP_BLOCKSIZE; x0++)
 		{
 			v3s16 p(x0,y0,z0);
diff -rU5 voxelands-v1709.00old/src/mapblock.h voxelands-v1709.00good/src/mapblock.h
--- voxelands-v1709.00old/src/mapblock.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapblock.h	2024-10-27 17:13:30.285707200 +0100
@@ -37,12 +37,13 @@
 #include "serialization.h"
 #include "constants.h"
 #include "voxel.h"
 #include "nodemetadata.h"
 #include "staticobject.h"
+
 #ifndef SERVER
-	#include "mapblock_mesh.h"
+# include "mapblock_mesh.h"
 #endif
 
 class Map;
 
 #define BLOCK_TIMESTAMP_UNDEFINED 0xffffffff
@@ -97,11 +98,11 @@
 	NODECONTAINER_ID_VOXELMANIPULATOR,
 };
 
 class NodeContainer
 {
-public:
+    public:
 	virtual bool isValidPosition(v3s16 p) = 0;
 	virtual MapNode getNode(v3s16 p) = 0;
 	virtual void setNode(v3s16 p, MapNode & n) = 0;
 	virtual u16 nodeContainerId() const = 0;
 
@@ -121,44 +122,46 @@
 	MapBlock itself
 */
 
 class MapBlock /*: public NodeContainer*/
 {
-public:
-	MapBlock(Map *parent, v3s16 pos, bool dummy=false);
+    public:
+	
+	MapBlock(Map* const parent,const v3s16 pos,const bool dummy = false);
 	~MapBlock();
 
 	/*virtual u16 nodeContainerId() const
 	{
 		return NODECONTAINER_ID_MAPBLOCK;
 	}*/
 
-	Map * getParent()
+	Map* getParent()
 	{
 		return m_parent;
 	}
 
 	void reallocate()
 	{
 		if(data != NULL)
 			delete[] data;
-		u32 l = MAP_BLOCKSIZE * MAP_BLOCKSIZE * MAP_BLOCKSIZE;
-		data = new MapNode[l];
-		for(u32 i=0; i<l; i++){
+				
+		data = new MapNode[MAP_BLOCKSIZE3];
+		
+		for(u32 i=0; i<MAP_BLOCKSIZE3; i++)
 			//data[i] = MapNode();
 			data[i] = MapNode(CONTENT_IGNORE);
-		}
+		
 		raiseModified(MOD_STATE_WRITE_NEEDED);
 	}
 
 	/*
 		Flags
 	*/
 
 	bool isDummy()
 	{
-		return (data == NULL);
+		return data == NULL;
 	}
 	void unDummify()
 	{
 		assert(isDummy());
 		reallocate();
@@ -287,11 +290,12 @@
 
 	core::aabbox3d<s16> getBox()
 	{
 		return core::aabbox3d<s16>(getPosRelative(),
 				getPosRelative()
-				+ v3s16(MAP_BLOCKSIZE, MAP_BLOCKSIZE, MAP_BLOCKSIZE)
+				+ v3s16(MAP_BLOCKSIZE, MAP_BLOCKSIZE,
+						MAP_BLOCKSIZE)
 				- v3s16(1,1,1));
 	}
 
 	/*
 		Regular MapNode get-setters
@@ -299,23 +303,21 @@
 
 	bool isValidPosition(s16 x, s16 y, s16 z)
 	{
 		if (data == NULL)
 			return false;
-		return (
-			x >= 0 && x < MAP_BLOCKSIZE
-			&& y >= 0 && y < MAP_BLOCKSIZE
-			&& z >= 0 && z < MAP_BLOCKSIZE
-		);
+		return x >= 0 && x < MAP_BLOCKSIZE
+		    && y >= 0 && y < MAP_BLOCKSIZE
+		    && z >= 0 && z < MAP_BLOCKSIZE;
 	}
 
 	MapNode getNode(s16 x, s16 y, s16 z, bool *valid_position)
 	{
 		*valid_position = isValidPosition(x, y, z);
 		if (!*valid_position)
 			return MapNode(CONTENT_IGNORE);
-		return data[z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + y*MAP_BLOCKSIZE + x];
+		return data[z * MAP_BLOCKSIZE2 + y * MAP_BLOCKSIZE + x];
 	}
 
 	MapNode getNode(v3s16 p, bool *valid_position)
 	{
 		return getNode(p.X, p.Y, p.Z, valid_position);
@@ -332,11 +334,11 @@
 
 	void setNode(s16 x, s16 y, s16 z, MapNode & n)
 	{
 		if (!isValidPosition(x,y,z))
 			throw InvalidPositionException();
-		data[z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + y*MAP_BLOCKSIZE + x] = n;
+		data[z * MAP_BLOCKSIZE2 + y * MAP_BLOCKSIZE + x] = n;
 		raiseModified(MOD_STATE_WRITE_NEEDED);
 	}
 
 	void setNode(v3s16 p, MapNode & n)
 	{
@@ -345,11 +347,11 @@
 
 	void incNodeTicks(v3s16 p)
 	{
 		if (!isValidPosition(p.X,p.Y,p.Z))
 			return;
-		data[p.Z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + p.Y*MAP_BLOCKSIZE + p.X].envticks++;
+		data[p.Z * MAP_BLOCKSIZE2 + p.Y * MAP_BLOCKSIZE + p.X].envticks++;
 	}
 
 	/*
 		Non-checking variants of the above
 	*/
@@ -357,11 +359,11 @@
 	MapNode getNodeNoCheck(s16 x, s16 y, s16 z, bool *valid_position)
 	{
 		*valid_position = isValidPosition(x, y, z);
 		if (!*valid_position)
 			return MapNode(CONTENT_IGNORE);
-		return data[z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + y*MAP_BLOCKSIZE + x];
+		return data[z * MAP_BLOCKSIZE2 + y * MAP_BLOCKSIZE + x];
 	}
 
 	MapNode getNodeNoCheck(v3s16 p, bool *valid_position)
 	{
 		return getNodeNoCheck(p.X, p.Y, p.Z, valid_position);
@@ -369,11 +371,11 @@
 
 	void setNodeNoCheck(s16 x, s16 y, s16 z, MapNode & n)
 	{
 		if(data == NULL)
 			throw InvalidPositionException();
-		data[z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + y*MAP_BLOCKSIZE + x] = n;
+		data[z * MAP_BLOCKSIZE2 + y * MAP_BLOCKSIZE + x] = n;
 		raiseModified(MOD_STATE_WRITE_NEEDED);
 	}
 
 	void setNodeNoCheck(v3s16 p, MapNode & n)
 	{
@@ -491,82 +493,91 @@
 	u32 getUsageTimer()
 	{
 		return m_usage_timer;
 	}
 
+	void SetCurrent();
+	
+	void ResetCurrent();
+
+	int GetCurrent();
+
 	/*
 		Serialization
 	*/
 
 	// These don't write or read version by itself
 	void serialize(std::ostream &os, u8 version);
 	void deSerialize(std::istream &is, u8 version);
 	// Used after the basic ones when writing on disk (serverside)
 	void serializeDiskExtra(std::ostream &os, u8 version);
 	void deSerializeDiskExtra(std::istream &is, u8 version);
+	
+    public:
 
 	// Used by the server env for mob spawning
 	bool has_spawn_area;
 	v3s16 spawn_area;
 	u32 last_spawn;
 
-private:
+    private:
 	/*
 		Private methods
 	*/
 
 	/*
 		Used only internally, because changes can't be tracked
 	*/
 
-	MapNode & getNodeRef(s16 x, s16 y, s16 z)
+	MapNode& getNodeRef(s16 x, s16 y, s16 z) const
 	{
 		if(data == NULL)
 			throw InvalidPositionException();
 		if(x < 0 || x >= MAP_BLOCKSIZE) throw InvalidPositionException();
 		if(y < 0 || y >= MAP_BLOCKSIZE) throw InvalidPositionException();
 		if(z < 0 || z >= MAP_BLOCKSIZE) throw InvalidPositionException();
-		return data[z*MAP_BLOCKSIZE*MAP_BLOCKSIZE + y*MAP_BLOCKSIZE + x];
+		return data[z * MAP_BLOCKSIZE2 + y * MAP_BLOCKSIZE + x];
 	}
-	MapNode & getNodeRef(v3s16 &p)
+	MapNode& getNodeRef(v3s16 &p) const
 	{
 		return getNodeRef(p.X, p.Y, p.Z);
 	}
 
-public:
+    public:
 	/*
 		Public member variables
 	*/
 
 #ifndef SERVER // Only on client
-	MapBlockMesh *mesh;
+	MapBlockMesh* mesh;
 	JMutex mesh_mutex;
+	volatile int mesh_current;
 
 	std::map<v3s16,MapBlockSound> m_sounds;
 #endif
 
 	NodeMetadataList m_node_metadata;
 	StaticObjectList m_static_objects;
 	std::list<u16> m_active_objects;
 
-private:
+    private:
 	/*
 		Private member variables
 	*/
 
 	// NOTE: Lots of things rely on this being the Map
-	Map *m_parent;
+	Map* m_parent;
 	// Position in blocks on parent
 	v3s16 m_pos;
 
 	uint8_t m_biome;
 
 	/*
 		If NULL, block is a dummy block.
 		Dummy blocks are used for caching not-found-on-disk blocks.
 	*/
-	MapNode * data;
+	MapNode* data;
 
 	/*
 		- On the server, this is used for telling whether the
 		  block has been modified from the one on disk.
 		- On the client, this is used for nothing.
@@ -619,17 +630,16 @@
 	float m_usage_timer;
 };
 
 inline bool blockpos_over_limit(v3s16 p)
 {
-	return
-	  (p.X < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p.X >  MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p.Y < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p.Y >  MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p.Z < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
-	|| p.Z >  MAP_GENERATION_LIMIT / MAP_BLOCKSIZE);
+	return p.X < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+		     || p.X >  MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+	    || p.Y < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+		     || p.Y >  MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+	    || p.Z < -MAP_GENERATION_LIMIT / MAP_BLOCKSIZE
+		     || p.Z >  MAP_GENERATION_LIMIT / MAP_BLOCKSIZE;
 }
 
 /*
 	Returns the position of the block where the node is located
 */
diff -rU5 voxelands-v1709.00old/src/mapblock_mesh.cpp voxelands-v1709.00good/src/mapblock_mesh.cpp
--- voxelands-v1709.00old/src/mapblock_mesh.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapblock_mesh.cpp	2024-10-27 17:10:49.091060891 +0100
@@ -37,20 +37,23 @@
 #include "profiler.h"
 #include "mesh.h"
 #include "base64.h"
 #include "sound.h"
 
-void MeshMakeData::fill(u32 daynight_ratio, MapBlock *block)
+void MeshMakeData::fill(const u32 daynight_ratio,MapBlock* const block)
 {
 	m_daynight_ratio = daynight_ratio;
+	
 	if (!block)
 		return;
+	
 	m_blockpos = block->getPos();
+	
 	if (m_env)
-		m_vmanip.m_env = m_env;
+	    m_vmanip.setEnv(m_env);
 
-	m_blockpos_nodes = m_blockpos*MAP_BLOCKSIZE;
+	m_blockpos_nodes = m_blockpos * MAP_BLOCKSIZE;
 
 	/*
 		Copy data
 	*/
 
@@ -74,19 +77,22 @@
 			Copy neighbors. This is lightning fast.
 			Copying only the borders would be *very* slow.
 		*/
 
 		// Get map
-		Map *map = block->getParent();
+		Map* const map = block->getParent();
 
 		for(u16 i=0; i<6; i++)
 		{
 			const v3s16 &dir = g_6dirs[i];
 			v3s16 bp = m_blockpos + dir;
-			MapBlock *b = map->getBlockNoCreateNoEx(bp);
+			MapBlock* const b = map->getBlockNoCreateNoEx(bp);
 			if(b)
+			{
 				b->copyTo(m_vmanip);
+				b->ResetCurrent();
+			}
 		}
 	}
 }
 
 video::SColor blend_light(u32 data, u32 daylight_factor)
@@ -194,11 +200,11 @@
 		u32 orig_id = spec.texture.id;
 		std::string orig_name = g_texturesource->getTextureName(orig_id);
 
 		// Create new texture name
 		std::ostringstream os;
-		os<<orig_name<<"^[crack"<<select.crack;
+		os << orig_name << "^[crack" << select.crack;
 
 		// Get new texture
 		u32 new_id = g_texturesource->getTextureId(os.str());
 
 		spec.texture = g_texturesource->getTexture(new_id);
@@ -341,16 +347,17 @@
 	}
 
 	std::string rot = mn.getTileRotationString(face_dir);
 	if (rot != "") {
 		// Get original texture name
-		u32 orig_id = spec.texture.id;
-		std::string orig_name = g_texturesource->getTextureName(orig_id);
+		const u32 orig_id = spec.texture.id;
+		const std::string orig_name = g_texturesource->getTextureName(orig_id);
 		// new name
-		std::string texture_name = orig_name + rot;
+		const std::string texture_name = orig_name + rot;
 		// Get new texture
-		u32 new_id = g_texturesource->getTextureId(texture_name);
+		const u32 new_id = g_texturesource->getTextureId(texture_name);
+		
 		spec.texture = g_texturesource->getTexture(new_id);
 	}
 
 	/*
 		apply crack to this node
@@ -360,19 +367,20 @@
 			Get texture id, translate it to name, append stuff to
 			name, get texture id
 		*/
 
 		// Get original texture name
-		u32 orig_id = spec.texture.id;
-		std::string orig_name = g_texturesource->getTextureName(orig_id);
+		const u32 orig_id = spec.texture.id;
+		const std::string orig_name = g_texturesource->getTextureName(orig_id);
 
 		// Create new texture name
 		std::ostringstream os;
-		os<<orig_name<<"^[crack"<<select.crack;
+		
+		os << orig_name << "^[crack" << select.crack;
 
 		// Get new texture
-		u32 new_id = g_texturesource->getTextureId(os.str());
+		const u32 new_id = g_texturesource->getTextureId(os.str());
 
 		spec.texture = g_texturesource->getTexture(new_id);
 	}
 
 	return spec;
@@ -382,12 +390,11 @@
 	Gets node meta tile from any place relative to block.
 	Returns TILE_NODE if doesn't exist or should not be drawn.
 */
 TileSpec getMetaTile(MapNode mn, v3s16 p, v3s16 face_dir, SelectedNode &select)
 {
-	TileSpec spec;
-	spec = mn.getMetaTile(face_dir);
+	const TileSpec spec = mn.getMetaTile(face_dir);
 
 	return spec;
 }
 
 static const v3s16 dirs8[8] = {
@@ -414,24 +421,24 @@
 	if (corner.Y == 1)
 		p.Y += 1;
 	if (corner.Z == 1)
 		p.Z += 1;
 
-		for (u8 i = 0; i < 8; i++) {
-		MapNode n = vmanip.getNodeRO(p - dirs8[i]);
-		ContentFeatures &f = content_features(n);
-		if (f.param_type == CPT_LIGHT) {
-			dl += n.getLight(LIGHTBANK_DAY);
-			nl += n.getLight(LIGHTBANK_NIGHT);
-			light_count++;
-			if (f.light_source > 0)
-				ambient_occlusion -= 1.0;
-		} else if (f.draw_type == CDT_CUBELIKE || f.draw_type == CDT_DIRTLIKE) {
-			ambient_occlusion += 0.5;
-		} else if (n.getContent() != CONTENT_IGNORE) {
-			ambient_occlusion += 0.25;
-		}
+	for (u8 i = 0; i < 8; i++) {
+	    MapNode n = vmanip.getNodeRO(p - dirs8[i]);
+	    ContentFeatures &f = content_features(n);
+	    if (f.param_type == CPT_LIGHT) {
+		dl += n.getLight(LIGHTBANK_DAY);
+		nl += n.getLight(LIGHTBANK_NIGHT);
+		light_count++;
+		if (f.light_source > 0)
+		    ambient_occlusion -= 1.0;
+	    } else if (f.draw_type == CDT_CUBELIKE || f.draw_type == CDT_DIRTLIKE) {
+		ambient_occlusion += 0.5;
+	    } else if (n.getContent() != CONTENT_IGNORE) {
+		ambient_occlusion += 0.25;
+	    }
 	}
 
 	if (light_count == 0)
 		return 0;
 
@@ -445,45 +452,52 @@
 	}
 
 	u8 idl;
 	u8 inl;
 
-	if (dl >= LIGHT_SUN) {
+	if (dl >= LIGHT_SUN)
 		idl = LIGHT_SUN;
-	}else{
+	else
 		idl = ceilf(dl);
-	}
+
 	inl = ceilf(nl);
 
 	return ((inl<<4)&0xF0)|(idl&0x0F);;
 }
 
-MapBlockMesh::MapBlockMesh(MeshMakeData *data, v3s16 camera_offset):
-	m_mesh(NULL),
-	m_farmesh(NULL),
-	m_camera_offset(camera_offset)
+/**
+   MapBlockMesh
+**/
+
+MapBlockMesh::MapBlockMesh(MeshMakeData* const data,const v3s16 camera_offset):
+		isfar(false),m_pos(),m_mesh(NULL),m_farmesh(NULL),
+		m_camera_offset(camera_offset),m_meshdata(),m_fardata(),
+		m_animation_data()
 {
 	generate(data,camera_offset,NULL);
 }
 
 MapBlockMesh::~MapBlockMesh()
 {
+    // PB Lock en amont dans client.cpp
 	m_mesh->drop();
 	m_mesh = NULL;
 	m_farmesh->drop();
 	m_farmesh = NULL;
+	
 	if (!m_animation_data.empty())
 		m_animation_data.clear();
 }
 
 void MapBlockMesh::animate(float time)
 {
 	if (!m_mesh)
 		return;
 
 	for (std::map<u32, AnimationData>::iterator it = m_animation_data.begin();
-				it != m_animation_data.end(); ++it) {
+				it != m_animation_data.end(); ++it)
+	{
 
 		 // Make sure we don't cause an overflow
 		if (it->first >= m_mesh->getMeshBufferCount())
 			return;
 
@@ -498,249 +512,279 @@
 		if (frame == it->second.frame)
 			continue;
 
 		m_animation_data[it->first].frame = frame;
 
-		u16 mc = m_mesh->getMeshBufferCount();
+		const u16 mc = m_mesh->getMeshBufferCount();
 		if (mc <= it->first)
 			continue;
-		scene::IMeshBuffer *buf = m_mesh->getMeshBuffer(it->first);
+		
+		scene::IMeshBuffer* const buf = m_mesh->getMeshBuffer(it->first);
 
 		// Create new texture name from original
-		if (g_texturesource && frame >= 0) {
+		if (g_texturesource && frame >= 0)
+		{
 			std::ostringstream os(std::ios::binary);
+			
 			os << g_texturesource->getTextureName(tile.texture.id);
 			os << "^[verticalframe:" << (int)tile.animation_frame_count << ":" << frame;
 			// Set the texture
 			AtlasPointer ap = g_texturesource->getTexture(os.str());
 			buf->getMaterial().setTexture(0, ap.atlas);
 		}
 	}
 }
 
-void MapBlockMesh::generate(MeshMakeData *data, v3s16 camera_offset, JMutex *mutex)
+void MapBlockMesh::generate(MeshMakeData* const data,const v3s16 camera_offset,
+		JMutex* const mutex)
 {
 	DSTACK(__FUNCTION_NAME);
 
 	data->mesh_detail = config_get_int("client.graphics.mesh.lod");
 	data->texture_detail = config_get_int("client.graphics.texture.lod");
 	data->light_detail = config_get_int("client.graphics.light.lod");
 	m_pos = data->m_blockpos;
+	
 	SelectedNode selected;
+	
 	if (!m_animation_data.empty())
 		m_animation_data.clear();
 
 	for(s16 z=0; z<MAP_BLOCKSIZE; z++)
 	for(s16 y=0; y<MAP_BLOCKSIZE; y++)
 	for(s16 x=0; x<MAP_BLOCKSIZE; x++)
 	{
-		v3s16 p(x,y,z);
-
-		MapNode n = data->m_vmanip.getNodeNoEx(data->m_blockpos_nodes+p);
-
+	    const v3s16 p(x,y,z);
+	    MapNode n = data->m_vmanip.getNodeNoEx(data->m_blockpos_nodes + p);
 
 #if USE_AUDIO == 1
-		if (data->m_sounds != NULL) {
-			std::string snd = content_features(n).sound_ambient;
-			std::map<v3s16,MapBlockSound>::iterator i = data->m_sounds->find(p);
-			if (snd != "") {
-				bool add_sound = true;
-				if (i != data->m_sounds->end()) {
-					if (i->second.name == snd && sound_exists(i->second.id)) {
-						add_sound = false;
-					}else{
-						sound_stop_single(i->second.id);
-					}
-				}
-				if (add_sound && content_features(n).liquid_type != LIQUID_NONE) {
-					if (data->m_vmanip.getNodeRO(data->m_blockpos_nodes+p+v3s16(0,1,0)).getContent() != CONTENT_AIR) {
-						add_sound = false;
-					}else if (content_features(n).param2_type != CPT_LIQUID || n.param2 < 4 || n.param2 > 7) {
-						add_sound = false;
-					}else{
-						int adj = 0;
-						for (s16 x=-1; x<2; x++) {
-							for (s16 z=-1; z<2; z++) {
-								if (!x && !z)
-									continue;
-								content_t ac = data->m_vmanip.getNodeRO(data->m_blockpos_nodes+p+v3s16(x,0,z)).getContent();
-								if (
-									ac == content_features(n).liquid_alternative_flowing
-									|| ac == content_features(n).liquid_alternative_source
-								)
-									adj++;
-							}
-						}
-						if (adj > 3)
-							add_sound = false;
-					}
-				}
-				if (add_sound) {
-					v3f pf = intToFloat(p+data->m_blockpos_nodes,BS);
-					v3_t vp = {pf.X,pf.Y,pf.Z};
-					MapBlockSound bsnd;
-					bsnd.id = sound_play_effect((char*)snd.c_str(),1.0,1,&vp);
-					bsnd.name = snd;
-					if (bsnd.id > 0)
-						(*data->m_sounds)[p] = bsnd;
+	    if (data->m_sounds != NULL)
+	    {
+		std::string snd = content_features(n).sound_ambient;
+		std::map<v3s16,MapBlockSound>::iterator i = data->m_sounds->find(p);
+		if (snd != "")
+		{
+		    bool add_sound = true;
+		    if (i != data->m_sounds->end())
+		    {
+			if (i->second.name == snd && sound_exists(i->second.id)) {
+			    add_sound = false;
+			}else{
+			    sound_stop_single(i->second.id);
+			}
+		    }
+		    if (add_sound && content_features(n).liquid_type != LIQUID_NONE) {
+			if (data->m_vmanip.getNodeRO(data->m_blockpos_nodes+p+v3s16(0,1,0)).getContent() != CONTENT_AIR) {
+			    add_sound = false;
+			}else if (content_features(n).param2_type != CPT_LIQUID || n.param2 < 4 || n.param2 > 7) {
+			    add_sound = false;
+			}else{
+			    int adj = 0;
+			    for (s16 x=-1; x<2; x++) {
+				for (s16 z=-1; z<2; z++) {
+				    if (!x && !z)
+					continue;
+				    const content_t ac = data->m_vmanip.getNodeRO(data->m_blockpos_nodes+p+v3s16(x,0,z)).getContent();
+				    if (ac == content_features(n).liquid_alternative_flowing
+						    || ac == content_features(n).liquid_alternative_source)
+					adj++;
 				}
-			}else if (i != data->m_sounds->end()) {
-				sound_stop_single(i->second.id);
-				data->m_sounds->erase(i);
+			    }
+			    if (adj > 3)
+				add_sound = false;
 			}
+		    }
+		    if (add_sound)
+		    {
+			v3f pf = intToFloat(p+data->m_blockpos_nodes,BS);
+			v3_t vp = {pf.X,pf.Y,pf.Z};
+			MapBlockSound bsnd;
+			bsnd.id = sound_play_effect((char*)snd.c_str(),1.0,1,&vp);
+			bsnd.name = snd;
+			if (bsnd.id > 0)
+			    (*data->m_sounds)[p] = bsnd;
+		    }
+		}
+		else if (i != data->m_sounds->end())
+		{
+		    sound_stop_single(i->second.id);
+		    data->m_sounds->erase(i);
 		}
+	    }
 #endif
-		if (data->light_detail > 1 && !selected.is_coloured)
-			meshgen_preset_smooth_lights(data,p);
-		switch (content_features(n).draw_type) {
-		case CDT_AIRLIKE:
-			break;
-		case CDT_CUBELIKE:
-			meshgen_cubelike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_DIRTLIKE:
-			meshgen_dirtlike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_RAILLIKE:
-			meshgen_raillike(data,p,n,selected);
-			break;
-		case CDT_PLANTLIKE:
-			meshgen_plantlike(data,p,n,selected);
-			break;
-		case CDT_PLANTLIKE_FERN:
-			meshgen_plantlike_fern(data,p,n,selected);
-			break;
-		case CDT_CROPLIKE:
-			meshgen_croplike(data,p,n,selected);
-			break;
-		case CDT_LIQUID:
-			meshgen_liquid(data,p,n,selected);
-			break;
-		case CDT_LIQUID_SOURCE:
-			meshgen_liquid_source(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_NODEBOX:
-			meshgen_nodebox(data,p,n,selected,false);
-			break;
-		case CDT_GLASSLIKE:
-			meshgen_glasslike(data,p,n,selected);
-			break;
-		case CDT_TORCHLIKE:
-			meshgen_torchlike(data,p,n,selected);
-			break;
-		case CDT_FENCELIKE:
-			meshgen_fencelike(data,p,n,selected);
-			break;
-		case CDT_FIRELIKE:
-			meshgen_firelike(data,p,n,selected);
-			break;
-		case CDT_WALLLIKE:
-			meshgen_walllike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_ROOFLIKE:
-			meshgen_rooflike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_LEAFLIKE:
-			meshgen_leaflike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_NODEBOX_META:
-			meshgen_nodebox(data,p,n,selected,true);
-			break;
-		case CDT_WIRELIKE:
-			meshgen_wirelike(data,p,n,selected,false);
-			break;
-		case CDT_3DWIRELIKE:
-			meshgen_wirelike(data,p,n,selected,true);
-			break;
-		case CDT_STAIRLIKE:
-			meshgen_stairlike(data,p,n,selected);
-			break;
-		case CDT_SLABLIKE:
-			meshgen_slablike(data,p,n,selected);
-			break;
-		case CDT_TRUNKLIKE:
-			meshgen_trunklike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_FLAGLIKE:
-			meshgen_flaglike(data,p,n,selected);
-			break;
-		case CDT_MELONLIKE:
-			meshgen_melonlike(data,p,n,selected);
-			meshgen_farnode(data,p,n);
-			break;
-		case CDT_CAMPFIRELIKE:
-			meshgen_campfirelike(data,p,n,selected);
-			break;
-		case CDT_BUSHLIKE:
-			meshgen_bushlike(data,p,n,selected);
-			break;
-		default:;
-		}
-	}
-
-	scene::SMesh *mesh = new scene::SMesh();
-	scene::SMesh *fmesh = new scene::SMesh();
-	for (u32 i=0; i<data->m_meshdata.size(); i++) {
+	    if (data->light_detail > 1 && !selected.is_coloured)
+		meshgen_preset_smooth_lights(data,p);
+	    
+	    switch (content_features(n).draw_type)
+	    {
+	      case CDT_AIRLIKE:
+		break;
+	      case CDT_CUBELIKE:
+		meshgen_cubelike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_DIRTLIKE:
+		meshgen_dirtlike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_RAILLIKE:
+		meshgen_raillike(data,p,n,selected);
+		break;
+	      case CDT_PLANTLIKE:
+		meshgen_plantlike(data,p,n,selected);
+		break;
+	      case CDT_PLANTLIKE_FERN:
+		meshgen_plantlike_fern(data,p,n,selected);
+		break;
+	      case CDT_CROPLIKE:
+		meshgen_croplike(data,p,n,selected);
+		break;
+	      case CDT_LIQUID:
+		meshgen_liquid(data,p,n,selected);
+		break;
+	      case CDT_LIQUID_SOURCE:
+		meshgen_liquid_source(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_NODEBOX:
+		meshgen_nodebox(data,p,n,selected,false);
+		break;
+	      case CDT_GLASSLIKE:
+		meshgen_glasslike(data,p,n,selected);
+		break;
+	      case CDT_TORCHLIKE:
+		meshgen_torchlike(data,p,n,selected);
+		break;
+	      case CDT_FENCELIKE:
+		meshgen_fencelike(data,p,n,selected);
+		break;
+	      case CDT_FIRELIKE:
+		meshgen_firelike(data,p,n,selected);
+		break;
+	      case CDT_WALLLIKE:
+		meshgen_walllike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_ROOFLIKE:
+		meshgen_rooflike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_LEAFLIKE:
+		meshgen_leaflike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_NODEBOX_META:
+		meshgen_nodebox(data,p,n,selected,true);
+		break;
+	      case CDT_WIRELIKE:
+		meshgen_wirelike(data,p,n,selected,false);
+		break;
+	      case CDT_3DWIRELIKE:
+		meshgen_wirelike(data,p,n,selected,true);
+		break;
+	      case CDT_STAIRLIKE:
+		meshgen_stairlike(data,p,n,selected);
+		break;
+	      case CDT_SLABLIKE:
+		meshgen_slablike(data,p,n,selected);
+		break;
+	      case CDT_TRUNKLIKE:
+		meshgen_trunklike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_FLAGLIKE:
+		meshgen_flaglike(data,p,n,selected);
+		break;
+	      case CDT_MELONLIKE:
+		meshgen_melonlike(data,p,n,selected);
+		meshgen_farnode(data,p,n);
+		break;
+	      case CDT_CAMPFIRELIKE:
+		meshgen_campfirelike(data,p,n,selected);
+		break;
+	      case CDT_BUSHLIKE:
+		meshgen_bushlike(data,p,n,selected);
+		break;
+	      default:;
+	    }
+	}
+
+	scene::SMesh* const mesh = new scene::SMesh();
+	scene::SMesh* const fmesh = new scene::SMesh();
+	
+	if (mutex != NULL)
+		mutex->Lock();
+
+	for (u32 i=0; i<data->m_meshdata.size(); i++)
+	{
 		MeshData &d = data->m_meshdata[i];
 
 		// - Texture animation
-		if (d.tile.material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES) {
+		if (d.tile.material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES)
+		{
 			// Add to MapBlockMesh in order to animate these tiles
 			AnimationData anim_data;
 			anim_data.tile = d.tile;
 			anim_data.frame = -1;
 			m_animation_data[i] = anim_data;
 		}
 
 		// Create meshbuffer
 		// This is a "Standard MeshBuffer",
 		// it's a typedeffed CMeshBuffer<video::S3DVertex>
-		scene::SMeshBuffer *buf = new scene::SMeshBuffer();
+		scene::SMeshBuffer* const buf = new scene::SMeshBuffer();
+
+		if(buf)
+		{
 		// Set material
-		buf->Material = d.tile.getMaterial();
+		    buf->Material = d.tile.getMaterial();
 		// Add to mesh
-		mesh->addMeshBuffer(buf);
+		    mesh->addMeshBuffer(buf);
 		// Mesh grabbed it
-		buf->drop();
-
-		buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
+		    buf->drop();
+		    buf->append(d.vertices.data(), d.vertices.size(),
+				    d.indices.data(), d.indices.size());
+		}
 	}
-	for (u32 i=0; i<data->m_fardata.size(); i++) {
+	
+	for (u32 i=0; i<data->m_fardata.size(); i++)
+	{
 		MeshData &d = data->m_fardata[i];
 		// Create meshbuffer
 		// This is a "Standard MeshBuffer",
 		// it's a typedeffed CMeshBuffer<video::S3DVertex>
-		scene::SMeshBuffer *buf = new scene::SMeshBuffer();
+		scene::SMeshBuffer* const buf = new scene::SMeshBuffer();
+
+		if(buf) {
 		// Set material
-		buf->Material = d.tile.getMaterial();
+		    buf->Material = d.tile.getMaterial();
 		// Add to mesh
-		fmesh->addMeshBuffer(buf);
+		    fmesh->addMeshBuffer(buf);
 		// Mesh grabbed it
-		buf->drop();
-
-		buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
+		    buf->drop();
+		    buf->append(d.vertices.data(), d.vertices.size(),
+				    d.indices.data(), d.indices.size());
+		}
 	}
 
-	translateMesh(mesh, intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset, BS));
-	translateMesh(fmesh, intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset, BS));
+	if (mutex != NULL)
+		mutex->Unlock();
+
+	translateMesh(mesh,intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset,BS));
+	translateMesh(fmesh,intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset,BS));
 
 	if (mutex != NULL)
 		mutex->Lock();
 
 	if (m_mesh != NULL)
 		m_mesh->drop();
+	m_mesh = mesh;
+	
 	if (m_farmesh != NULL)
 		m_farmesh->drop();
-	m_mesh = mesh;
 	m_farmesh = fmesh;
+	
 	m_meshdata.swap(data->m_meshdata);
 	m_fardata.swap(data->m_fardata);
 	refresh(data->m_daynight_ratio);
 	m_mesh->recalculateBoundingBox();
 
@@ -754,46 +798,56 @@
 void MapBlockMesh::refresh(u32 daynight_ratio)
 {
 	if (m_mesh == NULL)
 		return;
 
-	u16 mc = m_mesh->getMeshBufferCount();
-	for (u16 j=0; j<mc; j++) {
-		scene::IMeshBuffer *buf = m_mesh->getMeshBuffer(j);
+	const u16 mc = m_mesh->getMeshBufferCount();
+	for (u16 j=0; j<mc; j++)
+	{
+		scene::IMeshBuffer* const buf = m_mesh->getMeshBuffer(j);
 		if (buf == 0)
 			continue;
-		u16 vc = buf->getVertexCount();
+		
+		const u16 vc = buf->getVertexCount();
 		if (!vc)
 			continue;
-		video::S3DVertex *vertices = (video::S3DVertex*)buf->getVertices();
+		
+		video::S3DVertex* const vertices =
+		    (video::S3DVertex*)buf->getVertices();
 		if (vertices == 0)
 			continue;
-		u32 *c = m_meshdata[j].colours.data();
-		for (u16 i=0; i<vc; i++) {
+		
+		u32* const c = m_meshdata[j].colours.data();		
+		for (u16 i=0; i<vc; i++)
 			vertices[i].Color = blend_light(c[i],daynight_ratio);
-		}
 	}
-	mc = m_farmesh->getMeshBufferCount();
-	for (u16 j=0; j<mc; j++) {
-		scene::IMeshBuffer *buf = m_farmesh->getMeshBuffer(j);
+	
+	const u16 fmc = m_farmesh->getMeshBufferCount();
+	for (u16 j=0; j<fmc; j++)
+	{
+		scene::IMeshBuffer* const buf = m_farmesh->getMeshBuffer(j);
 		if (buf == 0)
 			continue;
-		u16 vc = buf->getVertexCount();
+		
+		const u16 vc = buf->getVertexCount();
 		if (!vc)
 			continue;
-		video::S3DVertex *vertices = (video::S3DVertex*)buf->getVertices();
+		
+		video::S3DVertex* const vertices =
+		    (video::S3DVertex*)buf->getVertices();
 		if (vertices == 0)
 			continue;
-		for (u16 i=0; i<vc; i++) {
+		
+		for (u16 i=0; i<vc; i++)
 			vertices[i].Color = blend_light(0x0F,daynight_ratio);
-		}
 	}
 }
 
 void MapBlockMesh::updateCameraOffset(v3s16 camera_offset)
 {
-	if (camera_offset != m_camera_offset) {
-		translateMesh(m_mesh, intToFloat(m_camera_offset-camera_offset, BS));
-		translateMesh(m_farmesh, intToFloat(m_camera_offset-camera_offset, BS));
-		m_camera_offset = camera_offset;
+	if (camera_offset != m_camera_offset)
+	{
+	    translateMesh(m_mesh,intToFloat(m_camera_offset-camera_offset,BS));
+	    translateMesh(m_farmesh,intToFloat(m_camera_offset-camera_offset,BS));
+	    m_camera_offset = camera_offset;
 	}
 }
diff -rU5 voxelands-v1709.00old/src/mapblock_mesh.h voxelands-v1709.00good/src/mapblock_mesh.h
--- voxelands-v1709.00old/src/mapblock_mesh.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapblock_mesh.h	2024-09-22 18:41:01.711655803 +0200
@@ -94,11 +94,11 @@
 
 	/*
 		Copy central data directly from block, and other data from
 		parent of block.
 	*/
-	void fill(u32 daynight_ratio, MapBlock *block);
+	void fill(const u32 daynight_ratio,MapBlock* const block);
 
 	void startSingle(v3s16 pos, TileSpec tile)
 	{
 		MeshData dd;
 		dd.single = true;
@@ -222,27 +222,33 @@
 {
 	TileSpec tile;
 	int frame;
 };
 
+/**
+   MapBlockMesh
+**/
+
 class MapBlockMesh
 {
-public:
-	MapBlockMesh(MeshMakeData *data, v3s16 camera_offset);
+    public:
+	
+	MapBlockMesh(MeshMakeData* const data,const v3s16 camera_offset);
 	~MapBlockMesh();
 
+    // Appele par map.cpp, mutex.
 	scene::SMesh* getMesh()
 	{
 		return m_mesh;
 	}
 
 	scene::SMesh* getFarMesh()
 	{
 		return m_farmesh;
 	}
 
-	void generate(MeshMakeData *data, v3s16 camera_offset, JMutex *mutex);
+	void generate(MeshMakeData* const data,const v3s16 camera_offset,JMutex* const mutex);
 	void refresh(u32 daynight_ratio);
 	void animate(float time);
 
 	bool isAnimated()
 	{
@@ -250,14 +256,16 @@
 	}
 
 	void updateCameraOffset(v3s16 camera_offset);
 
 	bool isfar;
-private:
+	
+    private:
+
 	v3s16 m_pos;
-	scene::SMesh *m_mesh;
-	scene::SMesh *m_farmesh;
+	scene::SMesh* m_mesh;
+	scene::SMesh* m_farmesh;
 	v3s16 m_camera_offset;
 	std::vector<MeshData> m_meshdata;
 	std::vector<MeshData> m_fardata;
 
 	std::map<u32, AnimationData> m_animation_data;
diff -rU5 voxelands-v1709.00old/src/mapnode.cpp voxelands-v1709.00good/src/mapnode.cpp
--- voxelands-v1709.00old/src/mapnode.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapnode.cpp	2024-09-22 18:41:01.712655805 +0200
@@ -44,40 +44,48 @@
 std::vector<NodeBox> transformNodeBox(MapNode &n,
 		const std::vector<NodeBox> &nodebox)
 {
 	std::vector<NodeBox> boxes;
 	int facedir = 0;
-	if (
-		content_features(n).param2_type == CPT_FACEDIR_SIMPLE
-		|| content_features(n).param2_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	
+	if (content_features(n).param2_type == CPT_FACEDIR_SIMPLE
+			|| content_features(n).param2_type == CPT_FACEDIR_WALLMOUNT)
 		facedir = n.param2&0x0F;
-	}else if (
-		content_features(n).param_type == CPT_FACEDIR_SIMPLE
-		|| content_features(n).param_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	else if (content_features(n).param_type == CPT_FACEDIR_SIMPLE
+			|| content_features(n).param_type == CPT_FACEDIR_WALLMOUNT)
 		facedir = n.param1;
-	}
-	for(std::vector<NodeBox>::const_iterator i = nodebox.begin(); i != nodebox.end(); i++) {
+
+	for(std::vector<NodeBox>::const_iterator i = nodebox.begin(); i != nodebox.end(); i++)
+	{
 		NodeBox box = *i;
-		if (facedir == 1) {
+		
+		if (facedir == 1)
+		{
 			box.m_box.MinEdge.rotateXZBy(-90);
 			box.m_box.MaxEdge.rotateXZBy(-90);
 			box.m_box.repair();
-		}else if (facedir == 2) {
+		}
+		else if (facedir == 2)
+		{
 			box.m_box.MinEdge.rotateXZBy(180);
 			box.m_box.MaxEdge.rotateXZBy(180);
 			box.m_box.repair();
-		}else if (facedir == 3) {
+		}
+		else if (facedir == 3)
+		{
 			box.m_box.MinEdge.rotateXZBy(90);
 			box.m_box.MaxEdge.rotateXZBy(90);
 			box.m_box.repair();
-		}else if (facedir == 4) {
+		}
+		else if (facedir == 4)
+		{
 			box.m_box.MinEdge.rotateXYBy(-90);
 			box.m_box.MaxEdge.rotateXYBy(-90);
 			box.m_box.repair();
-		}else if (facedir == 5) {
+		}
+		else if (facedir == 5)
+		{
 			box.m_box.MinEdge.rotateXYBy(90);
 			box.m_box.MaxEdge.rotateXYBy(90);
 			box.m_box.repair();
 		}
 		boxes.push_back(box);
@@ -100,18 +108,22 @@
 #ifndef SERVER
 void ContentFeatures::setTexture(u16 i, std::string name, u8 alpha)
 {
 	used_texturenames[name] = true;
 
-	if (g_texturesource) {
+	if (g_texturesource)
+	{
 		tiles[i].texture = g_texturesource->getTexture(name);
 
 		// we have an animated texture!
-		if (tiles[i].material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES) {
+		if (tiles[i].material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES)
+		{
 			// Get raw texture size to determine frame count by aspect ratio
-			video::ITexture *t = g_texturesource->getTextureRaw(name);
-			if (t != NULL) {
+			video::ITexture* const t = g_texturesource->getTextureRaw(name);
+			
+			if (t != NULL)
+			{
 				v2u32 size = t->getOriginalSize();
 				int frame_count = size.Y / size.X;
 				int frame_length_ms = 1000.0 * animation_length / frame_count;
 				tiles[i].animation_frame_count = frame_count;
 				tiles[i].animation_frame_length_ms = frame_length_ms;
@@ -138,15 +150,15 @@
 
 void ContentFeatures::setMetaTexture(u16 i, std::string name, u8 alpha)
 {
 	used_texturenames[name] = true;
 
-	if(g_texturesource) {
+	if(g_texturesource)
 		meta_tiles[i].texture = g_texturesource->getTexture(name);
-	}
 
-	if (alpha != 255) {
+	if (alpha != 255)
+	{
 		meta_tiles[i].alpha = alpha;
 		meta_tiles[i].material_type = MATERIAL_ALPHA_VERTEX;
 	}
 }
 
@@ -209,17 +221,18 @@
 }
 #endif
 
 struct ContentFeatures g_content_features[MAX_CONTENT+1];
 
-ContentFeatures & content_features(content_t i)
+ContentFeatures& content_features(content_t i)
 {
 	if (i > MAX_CONTENT)
 		i = CONTENT_IGNORE;
 	return g_content_features[i];
 }
-ContentFeatures & content_features(MapNode &n)
+
+ContentFeatures& content_features(const MapNode& n)
 {
 	return content_features(n.getContent());
 }
 
 /*
@@ -233,16 +246,20 @@
 #else
 void init_mapnode()
 #endif
 {
 	bool repeat = false;
-	if (g_texturesource == NULL) {
+	
+	if (g_texturesource == NULL)
+	{
 		dstream<<"INFO: Initial run of init_mapnode with "
 				"g_texturesource=NULL. If this segfaults, "
 				"there is a bug with something not checking for "
 				"the NULL value."<<std::endl;
-	}else{
+	}
+	else
+	{
 		repeat = true;
 		dstream<<"INFO: Full run of init_mapnode with "
 				"g_texturesource!=NULL"<<std::endl;
 	}
 
@@ -267,30 +284,33 @@
 		initial_material_type = MATERIAL_ALPHA_SIMPLE;
 	else
 		initial_material_type = MATERIAL_ALPHA_NONE;*/
 	for(u16 i=0; i<MAX_CONTENT+1; i++)
 	{
-		ContentFeatures *f = &g_content_features[i];
+		ContentFeatures& f = g_content_features[i];
 		// Re-initialize
-		f->reset();
+		f.reset();
 
 		for(u16 j=0; j<6; j++)
-			f->tiles[j].material_type = initial_material_type;
+			f.tiles[j].material_type = initial_material_type;
 	}
 #endif
 
 	/*
 		Initially set every block to be shown as an unknown block.
 		Don't touch CONTENT_IGNORE or CONTENT_AIR.
 	*/
-	for (u16 i=0; i <= MAX_CONTENT; i++) {
-		ContentFeatures *f = &g_content_features[i];
-		f->description = (char*)"???";
+	for (u16 i=0; i <= MAX_CONTENT; i++)
+	{
+		ContentFeatures& f = g_content_features[i];
+		
+		f.description = (char*)"???";
 		if (i == CONTENT_IGNORE || i == CONTENT_AIR)
 			continue;
-		f->draw_type = CDT_CUBELIKE;
-		f->setAllTextures("unknown_block.png");
+		
+		f.draw_type = CDT_CUBELIKE;
+		f.setAllTextures("unknown_block.png");
 	}
 
 	// Make CONTENT_IGNORE to not block the view when occlusion culling
 	content_features(CONTENT_IGNORE).draw_type = CDT_AIRLIKE;
 	content_features(CONTENT_IGNORE).suffocation_per_second = 0;
@@ -357,11 +377,11 @@
 	}
 
 	return dir;
 }
 
-v3s16 MapNode::getRotation(v3s16 dir)
+v3s16 MapNode::getRotation(v3s16 dir) const
 {
 	if (
 		content_features(*this).param2_type == CPT_FACEDIR_SIMPLE
 		|| content_features(*this).param2_type == CPT_FACEDIR_WALLMOUNT
 	) {
@@ -373,228 +393,222 @@
 		dir = facedir_rotate(param1, dir);
 	}
 	return dir;
 }
 
-s16 MapNode::getRotationAngle()
+s16 MapNode::getRotationAngle() const
 {
 	int facedir = 0;
-	ContentFeatures &f = content_features(*this);
-	if (
-		f.param2_type == CPT_FACEDIR_SIMPLE
-		|| f.param2_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	const ContentFeatures& f = content_features(*this);
+	
+	if (f.param2_type == CPT_FACEDIR_SIMPLE
+			|| f.param2_type == CPT_FACEDIR_WALLMOUNT)
 		facedir = param2&0x0F;
-	}else if (
-		f.param_type == CPT_FACEDIR_SIMPLE
-		|| f.param_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	else if (f.param_type == CPT_FACEDIR_SIMPLE
+			|| f.param_type == CPT_FACEDIR_WALLMOUNT)
 		facedir = param1;
-	}
-	switch (facedir) {
-	case 1:
+
+	switch (facedir)
+	{
+	  case 1:
 		return -90;
 		break;
-	case 2:
+	  case 2:
 		return 180;
 		break;
-	case 3:
+	  case 3:
 		return 90;
 		break;
-	default:;
+	  default:;
 	}
+	
 	return 0;
 }
 
-v3s16 MapNode::getEffectedRotation()
+v3s16 MapNode::getEffectedRotation() const
 {
 	u8 facedir = 0;
-	ContentFeatures *f = &content_features(getContent());
-	if (f->onact_also_affects == v3s16(0,0,0))
+	const ContentFeatures& f = content_features(getContent());
+	
+	if (f.onact_also_affects == v3s16(0,0,0))
 		return v3s16(0,0,0);
 
-	if (
-		f->param2_type == CPT_FACEDIR_SIMPLE
-		|| f->param2_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	if (f.param2_type == CPT_FACEDIR_SIMPLE
+			|| f.param2_type == CPT_FACEDIR_WALLMOUNT)
 		facedir = (param2&0x0F);
-	}else if (
-		f->param_type == CPT_FACEDIR_SIMPLE
-		|| f->param_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	else if (f.param_type == CPT_FACEDIR_SIMPLE
+			|| f.param_type == CPT_FACEDIR_WALLMOUNT)
 		facedir = param1;
-	}
 
-	switch (facedir) {
-	case 0: // Same
-		return v3s16(-f->onact_also_affects.X, f->onact_also_affects.Y, -f->onact_also_affects.Z);
+	switch (facedir)
+	{
+	  case 0: // Same
+		return v3s16(-f.onact_also_affects.X, f.onact_also_affects.Y, -f.onact_also_affects.Z);
 		break;
-	case 1: // Face is taken from rotXZccv(-90)
-		return v3s16(-f->onact_also_affects.Z, f->onact_also_affects.Y, f->onact_also_affects.X);
+	  case 1: // Face is taken from rotXZccv(-90)
+		return v3s16(-f.onact_also_affects.Z, f.onact_also_affects.Y, f.onact_also_affects.X);
 		break;
-	case 2: // Face is taken from rotXZccv(180)
-		return v3s16(f->onact_also_affects.X, f->onact_also_affects.Y, f->onact_also_affects.Z);
+	  case 2: // Face is taken from rotXZccv(180)
+		return v3s16(f.onact_also_affects.X, f.onact_also_affects.Y, f.onact_also_affects.Z);
 		break;
-	case 3: // Face is taken from rotXZccv(90)
-		return v3s16(f->onact_also_affects.Z, f->onact_also_affects.Y, -f->onact_also_affects.X);
+	  case 3: // Face is taken from rotXZccv(90)
+		return v3s16(f.onact_also_affects.Z, f.onact_also_affects.Y, -f.onact_also_affects.X);
 		break;
-	default:;
+	  default:;
 	}
 
-	return f->onact_also_affects;
+	return f.onact_also_affects;
 }
 
 #ifndef SERVER
 TileSpec MapNode::getTileFrom(v3s16 dir, TileSpec raw_spec[6], bool rotate)
 {
 	TileSpec spec;
 	s32 dir_i = 0;
-	ContentFeatures &f = content_features(*this);
+	const ContentFeatures& f = content_features(*this);
 
-	if (
-		f.param2_type == CPT_FACEDIR_SIMPLE
-		|| f.param2_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	if (f.param2_type == CPT_FACEDIR_SIMPLE
+			|| f.param2_type == CPT_FACEDIR_WALLMOUNT)
 		dir = facedir_rotate(param2&0x0F, dir);
-	}else if (
-		f.param_type == CPT_FACEDIR_SIMPLE
-		|| f.param_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	else if (f.param_type == CPT_FACEDIR_SIMPLE
+			|| f.param_type == CPT_FACEDIR_WALLMOUNT)
 		dir = facedir_rotate(param1, dir);
-	}
-	if (dir == v3s16(0,-1,0)) {
+
+	if (dir == v3s16(0,-1,0))
 		dir_i = 1;
-	}else if(dir == v3s16(1,0,0)) {
+	else if(dir == v3s16(1,0,0))
 		dir_i = 2;
-	}else if(dir == v3s16(-1,0,0)) {
+	else if(dir == v3s16(-1,0,0))
 		dir_i = 3;
-	}else if(dir == v3s16(0,0,1)) {
+	else if(dir == v3s16(0,0,1))
 		dir_i = 4;
-	}else if(dir == v3s16(0,0,-1)) {
+	else if(dir == v3s16(0,0,-1))
 		dir_i = 5;
-	}
 
 	spec = raw_spec[dir_i];
 
 	/*
 		If it contains some mineral, change texture id
 	*/
-	if (f.param_type == CPT_MINERAL && g_texturesource) {
-		u8 mineral = getMineral();
-		std::string mineral_texture_name = mineral_features(mineral).texture;
-		if (mineral_texture_name != "") {
+	if (f.param_type == CPT_MINERAL && g_texturesource)
+	{
+		const u8 mineral = getMineral();
+		const std::string mineral_texture_name = mineral_features(mineral).texture;
+		
+		if (mineral_texture_name != "")
+		{
 			u32 orig_id = spec.texture.id;
 			std::string texture_name = g_texturesource->getTextureName(orig_id);
 			//texture_name += "^blit:";
 			texture_name += "^";
 			texture_name += mineral_texture_name;
 			u32 new_id = g_texturesource->getTextureId(texture_name);
 			spec.texture = g_texturesource->getTexture(new_id);
 		}
 	}
-	if (rotate && f.rotate_tile_with_nodebox) {
-		u32 orig_id = spec.texture.id;
+	if (rotate && f.rotate_tile_with_nodebox)
+	{
+		const u32 orig_id = spec.texture.id;
 		std::string texture_name = g_texturesource->getTextureName(orig_id);
+		
 		texture_name += getTileRotationString(dir);
-		u32 new_id = g_texturesource->getTextureId(texture_name);
+		
+		const u32 new_id = g_texturesource->getTextureId(texture_name);
+		
 		spec.texture = g_texturesource->getTexture(new_id);
 	}
 
 	return spec;
 }
+
 std::string MapNode::getTileRotationString(v3s16 dir)
 {
 	s32 dir_i = 0;
-	ContentFeatures &f = content_features(*this);
+	const ContentFeatures& f = content_features(*this);
+	
 	if (!f.rotate_tile_with_nodebox)
 		return "";
 
-	if (
-		f.param2_type == CPT_FACEDIR_SIMPLE
-		|| f.param2_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	if (f.param2_type == CPT_FACEDIR_SIMPLE
+			|| f.param2_type == CPT_FACEDIR_WALLMOUNT)
 		dir = facedir_rotate(param2&0x0F, dir);
-	}else if (
-		f.param_type == CPT_FACEDIR_SIMPLE
-		|| f.param_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	else if (f.param_type == CPT_FACEDIR_SIMPLE
+			|| f.param_type == CPT_FACEDIR_WALLMOUNT)
 		dir = facedir_rotate(param1, dir);
-	}
-	if (dir == v3s16(0,-1,0)) {
+
+	if (dir == v3s16(0,-1,0))
 		dir_i = 1;
-	}else if(dir == v3s16(1,0,0)) {
+	else if(dir == v3s16(1,0,0))
 		dir_i = 2;
-	}else if(dir == v3s16(-1,0,0)) {
+	else if(dir == v3s16(-1,0,0))
 		dir_i = 3;
-	}else if(dir == v3s16(0,0,1)) {
+	else if(dir == v3s16(0,0,1))
 		dir_i = 4;
-	}else if(dir == v3s16(0,0,-1)) {
+	else if(dir == v3s16(0,0,-1))
 		dir_i = 5;
-	}
+	
 	u8 facedir = 0;
-	if (f.param_type == CPT_FACEDIR_SIMPLE) {
+	if (f.param_type == CPT_FACEDIR_SIMPLE)
 		facedir = param1;
-	}else if (f.param2_type == CPT_FACEDIR_SIMPLE) {
+	else if (f.param2_type == CPT_FACEDIR_SIMPLE)
 		facedir = (param2&0x0F);
-	}
-	if (dir_i == 0) {
-		if (facedir == 1) { // -90
+
+	if (dir_i == 0)
+	{
+		if (facedir == 1) // -90
 			return "^[transformR270";
-		}else if (facedir == 2) { // 180
+		else if (facedir == 2) // 180
 			return "^[transformR180";
-		}else if (facedir == 3) { // 90
+		else if (facedir == 3) // 90
 			return "^[transformR90";
-		}
-	}else if (dir_i == 1) {
-		if (facedir == 1) { // -90
+		
+	}
+	else if (dir_i == 1)
+	{
+		if (facedir == 1) // -90
 			return "^[transformR90";
-		}else if (facedir == 2) { // 180
+		else if (facedir == 2) // 180
 			return "^[transformR180";
-		}else if (facedir == 3) { // 90
+		else if (facedir == 3) // 90
 			return "^[transformR270";
-		}
+		
 	}
 
 	return "";
 }
 #endif
 FaceText MapNode::getFaceText(v3s16 dir)
 {
 	s32 dir_i = 0;
-	ContentFeatures &f = content_features(*this);
-	if (
-		f.param2_type == CPT_FACEDIR_SIMPLE
-		|| f.param2_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	const ContentFeatures& f = content_features(*this);
+	
+	if (f.param2_type == CPT_FACEDIR_SIMPLE
+			|| f.param2_type == CPT_FACEDIR_WALLMOUNT)
 		dir = facedir_rotate(param2&0x0F, dir);
-	}else if (
-		f.param_type == CPT_FACEDIR_SIMPLE
-		|| f.param_type == CPT_FACEDIR_WALLMOUNT
-	) {
+	else if (f.param_type == CPT_FACEDIR_SIMPLE
+			|| f.param_type == CPT_FACEDIR_WALLMOUNT)
 		dir = facedir_rotate(param1, dir);
-	}
-	if (dir == v3s16(0,-1,0)) {
+	
+	if (dir == v3s16(0,-1,0))
 		dir_i = 1;
-	}else if(dir == v3s16(1,0,0)) {
+	else if(dir == v3s16(1,0,0))
 		dir_i = 2;
-	}else if(dir == v3s16(-1,0,0)) {
+	else if(dir == v3s16(-1,0,0))
 		dir_i = 3;
-	}else if(dir == v3s16(0,0,1)) {
+	else if(dir == v3s16(0,0,1))
 		dir_i = 4;
-	}else if(dir == v3s16(0,0,-1)) {
+	else if(dir == v3s16(0,0,-1))
 		dir_i = 5;
-	}
+       
 
 	return f.facetexts[dir_i];
 }
 
 u8 MapNode::getMineral()
 {
 	if(content_features(*this).param_type == CPT_MINERAL)
-	{
 		return param1 & 0x0f;
-	}
 
 	return MINERAL_NONE;
 }
 
 u32 MapNode::serializedLength(u8 version)
@@ -611,25 +625,30 @@
 {
 	if (!ser_ver_supported(version))
 		throw VersionMismatchException("ERROR: MapNode format not supported");
 
 	// Translate to wanted version
-	MapNode n_foreign = mapnode_translate_from_internal(*this, version);
+	const MapNode n_foreign = mapnode_translate_from_internal(*this, version);
 
-	if (version <= 20) {
+	if (version <= 20)
+	{
 		u8 p0 = 0;
 		dest[1] = n_foreign.param1;
 		dest[2] = n_foreign.param2;
-		if (content < 0x80) {
+		
+		if (content < 0x80)
 			p0 = content;
-		}else{
+		else
+		{
 			p0 = content>>4;
 			dest[2] &= ~(0xF0);
 			dest[2] |= (content&0x0F)<<4;
 		}
 		dest[0] = p0;
-	}else{
+	}
+	else
+	{
 		dest[0] = (n_foreign.content&0xFF00)>>8;
 		dest[1] = (n_foreign.content&0xFF);
 		dest[2] = n_foreign.param1;
 		dest[3] = n_foreign.param2;
 	}
@@ -637,20 +656,26 @@
 void MapNode::deSerialize(u8 *source, u8 version)
 {
 	if (!ser_ver_supported(version))
 		throw VersionMismatchException("ERROR: MapNode format not supported");
 
-	if (version <= 20) {
-		if (source[0] < 0x80) {
+	if (version <= 20)
+	{
+		if (source[0] < 0x80)
+		{
 			content = source[0];
 			param2 = source[2];
-		}else{
+		}
+		else
+		{
 			content = (source[0]<<4) + (source[2]>>4);
 			param2 = (source[2]&0x0F);
 		}
 		param1 = source[1];
-	}else{
+	}
+	else
+	{
 		content = (source[0]<<8) | source[1];
 		param1 = source[2];
 		param2 = source[3];
 	}
 
@@ -675,14 +700,16 @@
 	returns encoded light value.
 */
 u8 getFaceLight(u32 daynight_ratio, MapNode n, MapNode n2,
 		v3s16 face_dir)
 {
-	try{
+	try
+	{
 		u8 light;
-		u8 l1 = n.getLightBlend(daynight_ratio);
-		u8 l2 = n2.getLightBlend(daynight_ratio);
+		const u8 l1 = n.getLightBlend(daynight_ratio);
+		const u8 l2 = n2.getLightBlend(daynight_ratio);
+		
 		if(l1 > l2)
 			light = l1;
 		else
 			light = l2;
 
@@ -713,29 +740,33 @@
 	u8 ld = n.getLight(LIGHTBANK_DAY);
 	u8 ld2 = n2.getLight(LIGHTBANK_DAY);
 	u8 ln = n.getLight(LIGHTBANK_NIGHT);
 	u8 ln2 = n2.getLight(LIGHTBANK_NIGHT);
 
-	if (n2.getContent() == CONTENT_IGNORE) {
-		if (ld > 0) {
+	if (n2.getContent() == CONTENT_IGNORE)
+	{
+		if (ld > 0)
 			ld2 = ld;
-		}else{
+		else
 			ld2 = LIGHT_MAX;
-		}
+
 		ln2 = ln;
 	}
 
 	if (ld2 > ld)
 		ld = ld2;
 	if (ln2 > ln)
 		ln = ln2;
 
-	if (face_dir.X == 1 || face_dir.X == -1 || face_dir.Y == -1) {
+	if (face_dir.X == 1 || face_dir.X == -1 || face_dir.Y == -1)
+	{
 		ld = MYMAX(0,ld-2);
 		ln = MYMAX(0,ln-2);
-	}else if(face_dir.Z == 1 || face_dir.Z == -1) {
+	}
+	else if(face_dir.Z == 1 || face_dir.Z == -1)
+	{
 		ld = MYMAX(0,ld-1);
 		ln = MYMAX(0,ln-1);
 	}
 
-	return (ln<<4)|ld;
+	return (ln<<4) | ld;
 }
diff -rU5 voxelands-v1709.00old/src/mapnode.h voxelands-v1709.00good/src/mapnode.h
--- voxelands-v1709.00old/src/mapnode.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapnode.h	2024-09-22 18:41:01.712655805 +0200
@@ -277,17 +277,16 @@
 };
 
 class FaceText
 {
 public:
-	FaceText():
-		m_hastext(false)
+	FaceText() :
+			m_type(FTT_INFO),m_hastext(false)
 	{
 	}
-	FaceText(f32 tlx, f32 tly, f32 brx, f32 bry):
-		m_type(FTT_INFO),
-		m_hastext(true)
+	FaceText(f32 tlx, f32 tly, f32 brx, f32 bry) :
+			m_type(FTT_INFO),m_hastext(true)
 	{
 #ifndef SERVER
 		m_pos = core::rect<f32>(tlx,tly,brx,bry);
 #endif
 	}
@@ -548,18 +547,12 @@
 		rotate_tile_with_nodebox = false;
 		plantlike_tiled = false;
 		wield_nodebox = true;
 		description = (char*)"";
 		nodeboxes.clear();
-		nodeboxes.push_back(NodeBox(
-			-0.5*BS,
-			-0.5*BS,
-			-0.5*BS,
-			0.5*BS,
-			0.5*BS,
-			0.5*BS
-		));
+		nodeboxes.push_back(NodeBox(-0.5*BS,-0.5*BS,-0.5*BS,
+						0.5*BS,0.5*BS,0.5*BS));
 		wield_nodeboxes.clear();
 		setAllFaceTexts(FaceText());
 		param_type = CPT_NONE;
 		param2_type = CPT_NONE;
 		item_param_type = CPT_NONE;
@@ -822,27 +815,24 @@
 };
 
 /*
 	Call this to access the ContentFeature list
 */
-ContentFeatures & content_features(content_t i);
-ContentFeatures & content_features(MapNode &n);
+ContentFeatures& content_features(content_t i);
+ContentFeatures& content_features(const MapNode& n);
 
 struct SelectedNode
 {
 	v3s16 pos;
 	u16 crack;
 	bool has_crack;
 	bool is_coloured;
 	content_t content;
 
-	SelectedNode()
+	SelectedNode() : pos(0,0,0),crack(0),has_crack(false),is_coloured(false),
+			 content(CONTENT_IGNORE)	 
 	{
-		pos = v3s16(0,0,0);
-		has_crack = false;
-		is_coloured = false;
-		content = CONTENT_IGNORE;
 	}
 
 	SelectedNode(v3s16 p, u16 c, bool h, content_t cnt)
 	{
 		pos = p;
@@ -962,63 +952,70 @@
 	*/
 	u8 param2;
 
 	u32 envticks;
 
-	MapNode(const MapNode & n)
+	MapNode(const MapNode& n) :
+			content(n.content),param1(n.param1),param2(n.param2),
+			envticks(n.envticks)
 	{
-		*this = n;
 	}
 
-	MapNode(content_t a_content=CONTENT_AIR, u8 a_param1=0, u8 a_param2=0)
+	MapNode(content_t a_content=CONTENT_AIR, u8 a_param1=0, u8 a_param2=0) :
+			content(a_content),param1(a_param1),param2(a_param2),
+			envticks(0)
 	{
-		content = a_content;
-		param1 = a_param1;
-		param2 = a_param2;
-		envticks = 0;
 	}
 
-	bool operator==(const MapNode &other)
+	MapNode& operator=(const MapNode& n)
+	{
+		content = n.content;param1 = n.param1;param2 = n.param2;
+		envticks = n.envticks;
+		return *this;
+	}
+	
+	bool operator==(const MapNode &other) const
 	{
-		return (content == other.content
-				&& param1 == other.param1
-				&& param2 == other.param2);
+		return content == other.content && param1 == other.param1
+		    && param2 == other.param2;
 	}
 
 	// To be used everywhere
-	content_t getContent()
+	content_t getContent() const
 	{
 		return content;
 	}
 	void setContent(content_t c)
 	{
 		content = c;
 		envticks = 0;
 	}
 
-	u8 getLightBanksWithSource()
+	u8 getLightBanksWithSource() const
 	{
 		// Select the brightest of [light source, propagated light]
 		u8 lightday = 0;
 		u8 lightnight = 0;
-		ContentFeatures &f = content_features(content);
-		if (f.param_type == CPT_LIGHT) {
+		const ContentFeatures& f = content_features(content);
+		
+		if (f.param_type == CPT_LIGHT)
+		{
 			lightday = param1 & 0x0f;
 			lightnight = (param1>>4)&0x0f;
 		}
 		if (f.light_source > lightday)
 			lightday = f.light_source;
 		if (f.light_source > lightnight)
 			lightnight = f.light_source;
 		return (lightday&0x0f) | ((lightnight<<4)&0xf0);
 	}
 
-	u8 getLight(enum LightBank bank)
+	u8 getLight(enum LightBank bank) const
 	{
 		// Select the brightest of [light source, propagated light]
 		u8 light = 0;
-		ContentFeatures &f = content_features(content);
+		const ContentFeatures& f = content_features(content);
 		if (f.param_type == CPT_LIGHT) {
 			if (bank == LIGHTBANK_DAY) {
 				light = param1 & 0x0f;
 			}else if (bank == LIGHTBANK_NIGHT) {
 				light = (param1>>4)&0x0f;
@@ -1029,16 +1026,17 @@
 		return light;
 	}
 
 	// 0 <= daylight_factor <= 1000
 	// 0 <= return value <= LIGHT_SUN
-	u8 getLightBlend(u32 daylight_factor)
+	u8 getLightBlend(u32 daylight_factor) const
 	{
 		u8 l = ((daylight_factor * getLight(LIGHTBANK_DAY)
 			+ (1000-daylight_factor) * getLight(LIGHTBANK_NIGHT))
 			)/1000;
 		u8 max = LIGHT_MAX;
+		
 		if(getLight(LIGHTBANK_DAY) == LIGHT_SUN)
 			max = LIGHT_SUN;
 		if(l > max)
 			l = max;
 		return l;
@@ -1055,13 +1053,14 @@
 		}else if(bank == LIGHTBANK_NIGHT) {
 			param1 &= 0x0f;
 			param1 |= (a_light & 0x0f)<<4;
 		}
 	}
-	v3s16 getRotation(v3s16 dir = v3s16(1,1,1));
-	s16 getRotationAngle();
-	v3s16 getEffectedRotation();
+	
+	v3s16 getRotation(v3s16 dir = v3s16(1,1,1)) const;
+	s16 getRotationAngle() const;
+	v3s16 getEffectedRotation() const;
 
 	// In mapnode.cpp
 #ifndef SERVER
 	/*
 		Get tile of a face of the node.
@@ -1088,11 +1087,10 @@
 	*/
 
 	static u32 serializedLength(u8 version);
 	void serialize(u8 *dest, u8 version);
 	void deSerialize(u8 *source, u8 version);
-
 };
 
 /*
 	Gets lighting value at face of node
 
diff -rU5 voxelands-v1709.00old/src/mapsector.cpp voxelands-v1709.00good/src/mapsector.cpp
--- voxelands-v1709.00old/src/mapsector.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapsector.cpp	2024-09-22 18:41:01.712655805 +0200
@@ -27,14 +27,16 @@
 #include "jmutexautolock.h"
 #include "client.h"
 #include "exceptions.h"
 #include "mapblock.h"
 
-MapSector::MapSector(Map *parent, v2s16 pos):
+MapSector::MapSector(Map* const parent,const v2s16 pos):
+		m_blocks(),
 		m_parent(parent),
 		m_pos(pos),
-		m_block_cache(NULL)
+		m_block_cache(NULL),
+		m_block_cache_y(0)
 {
 }
 
 MapSector::~MapSector()
 {
@@ -46,13 +48,12 @@
 	// Clear cache
 	m_block_cache = NULL;
 
 	// Delete all
 	core::map<s16, MapBlock*>::Iterator i = m_blocks.getIterator();
-	for (; i.atEnd() == false; i++) {
+	for (; i.atEnd() == false; i++)
 		delete i.getNode()->getValue();
-	}
 
 	// Clear container
 	m_blocks.clear();
 }
 
@@ -83,44 +84,43 @@
 
 MapBlock * MapSector::createBlankBlockNoInsert(s16 y)
 {
 	assert(getBlockBuffered(y) == NULL);
 
-	v3s16 blockpos_map(m_pos.X, y, m_pos.Y);
+	const v3s16 blockpos_map(m_pos.X, y, m_pos.Y);
 
-	MapBlock *block = new MapBlock(m_parent, blockpos_map);
+	MapBlock* const block = new MapBlock(m_parent, blockpos_map);
 
 	return block;
 }
 
 MapBlock * MapSector::createBlankBlock(s16 y)
 {
-	MapBlock *block = createBlankBlockNoInsert(y);
+	MapBlock* const block = createBlankBlockNoInsert(y);
 
 	m_blocks.insert(y, block);
 
 	return block;
 }
 
 void MapSector::insertBlock(MapBlock *block)
 {
-	s16 block_y = block->getPos().Y;
-
-	MapBlock *block2 = getBlockBuffered(block_y);
+	const s16 block_y = block->getPos().Y;
+	MapBlock* const block2 = getBlockBuffered(block_y);
 	if (block2 != NULL)
 		throw AlreadyExistsException("Block already exists");
 
-	v2s16 p2d(block->getPos().X, block->getPos().Z);
+	const v2s16 p2d(block->getPos().X, block->getPos().Z);
 	assert(p2d == m_pos);
 
 	// Insert into container
 	m_blocks.insert(block_y, block);
 }
 
 void MapSector::deleteBlock(MapBlock *block)
 {
-	s16 block_y = block->getPos().Y;
+	const s16 block_y = block->getPos().Y;
 
 	// Clear from cache
 	m_block_cache = NULL;
 
 	// Remove from container
@@ -131,25 +131,24 @@
 }
 
 void MapSector::getBlocks(core::list<MapBlock*> &dest)
 {
 	core::list<MapBlock*> ref_list;
-
-	core::map<s16, MapBlock*>::Iterator bi;
-
-	bi = m_blocks.getIterator();
-	for (; bi.atEnd() == false; bi++) {
-		MapBlock *b = bi.getNode()->getValue();
+	core::map<s16, MapBlock*>::Iterator bi = m_blocks.getIterator();
+	
+	for (; bi.atEnd() == false; bi++)
+	{
+		MapBlock* const b = bi.getNode()->getValue();
 		dest.push_back(b);
 	}
 }
 
 /*
 	ServerMapSector
 */
 
-ServerMapSector::ServerMapSector(Map *parent, v2s16 pos):
+ServerMapSector::ServerMapSector(Map *parent, v2s16 pos) :
 		MapSector(parent, pos)
 {
 }
 
 ServerMapSector::~ServerMapSector()
@@ -208,12 +207,11 @@
 	/*
 		Get or create sector
 	*/
 
 	ServerMapSector *sector = NULL;
-
-	core::map<v2s16, MapSector*>::Node *n = sectors.find(p2d);
+	core::map<v2s16, MapSector*>::Node* const n = sectors.find(p2d);
 
 	if (n != NULL) {
 		dstream<<"WARNING: deSerializing existent sectors not supported "
 				"at the moment, because code hasn't been tested."
 				<<std::endl;
diff -rU5 voxelands-v1709.00old/src/mapsector.h voxelands-v1709.00good/src/mapsector.h
--- voxelands-v1709.00old/src/mapsector.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapsector.h	2024-09-22 18:41:01.712655805 +0200
@@ -41,11 +41,11 @@
 #define MAPSECTOR_SERVER 0
 #define MAPSECTOR_CLIENT 1
 
 class MapSector
 {
-public:
+    public:
 
 	MapSector(Map *parent, v2s16 pos);
 	virtual ~MapSector();
 
 	virtual u32 getId() const = 0;
@@ -65,11 +65,11 @@
 
 	void deleteBlock(MapBlock *block);
 
 	void getBlocks(core::list<MapBlock*> &dest);
 
-protected:
+    protected:
 
 	// The pile of MapBlocks
 	core::map<s16, MapBlock*> m_blocks;
 
 	Map *m_parent;
@@ -88,11 +88,11 @@
 
 };
 
 class ServerMapSector : public MapSector
 {
-public:
+    public:
 	ServerMapSector(Map *parent, v2s16 pos);
 	~ServerMapSector();
 
 	u32 getId() const
 	{
@@ -117,20 +117,20 @@
 };
 
 #ifndef SERVER
 class ClientMapSector : public MapSector
 {
-public:
+    public:
 	ClientMapSector(Map *parent, v2s16 pos);
 	~ClientMapSector();
 
 	u32 getId() const
 	{
 		return MAPSECTOR_CLIENT;
 	}
 
-private:
+    private:
 };
 #endif
 
 #endif
 
diff -rU5 voxelands-v1709.00old/src/mesh.cpp voxelands-v1709.00good/src/mesh.cpp
--- voxelands-v1709.00old/src/mesh.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mesh.cpp	2024-09-22 21:30:36.987072124 +0200
@@ -120,11 +120,12 @@
 			}
 		}
 
 		u16 indices[6] = {0,1,2,2,3,0};
 		for (u32 i=0; i<6; ++i) {
-			scene::IMeshBuffer *buf = new scene::SMeshBuffer();
+			scene::IMeshBuffer* const buf = new scene::SMeshBuffer();
+			
 			buf->append(vertices + 4 * i, 4, indices, 6);
 			// Set default material
 			buf->getMaterial().setFlag(video::EMF_LIGHTING, false);
 			buf->getMaterial().setFlag(video::EMF_BILINEAR_FILTER, false);
 			buf->getMaterial().MaterialType = video::EMT_TRANSPARENT_ALPHA_CHANNEL_REF;
@@ -132,11 +133,12 @@
 			mesh->addMeshBuffer(buf);
 			buf->drop();
 		}
 	}
 
-	scene::SAnimatedMesh *anim_mesh = new scene::SAnimatedMesh(mesh);
+	scene::SAnimatedMesh* const anim_mesh = new scene::SAnimatedMesh(mesh);
+	
 	mesh->drop();
 	scaleMesh(anim_mesh, scale);  // also recalculates bounding box
 	return anim_mesh;
 }
 
@@ -167,11 +169,12 @@
 		return mesh;
 #if (IRRLICHT_VERSION_MAJOR >= 1 && IRRLICHT_VERSION_MINOR >= 8) || IRRLICHT_VERSION_MAJOR >= 2
 	// irrlicht 1.8+ we just manually load the mesh
 	scene::IMeshLoader *loader;
 	u32 lc = smgr->getMeshLoaderCount();
-	io::IReadFile* file = smgr->getFileSystem()->createAndOpenFile(buff);
+	io::IReadFile* const file = smgr->getFileSystem()->createAndOpenFile(buff);
+	
 	if (!file)
 		return 0;
 	for (u32 i=0; i<lc; i++) {
 		loader = smgr->getMeshLoader(i);
 		file->seek(0);
@@ -344,22 +347,24 @@
 	}
 
 	delete[] solidity;
 
 	// Add to mesh
-	scene::SMesh *mesh = new scene::SMesh();
+	scene::SMesh* const mesh = new scene::SMesh();
 	mesh->addMeshBuffer(buf);
 	buf->drop();
-	scene::SAnimatedMesh *anim_mesh = new scene::SAnimatedMesh(mesh);
+	
+	scene::SAnimatedMesh* const anim_mesh = new scene::SAnimatedMesh(mesh);
 	mesh->drop();
+	
 	return anim_mesh;
 }
 
 scene::IAnimatedMesh* createExtrudedMesh(video::ITexture *texture,
 		video::IVideoDriver *driver, v3f scale)
 {
-	scene::IAnimatedMesh *mesh = NULL;
+	scene::IAnimatedMesh* mesh = NULL;
 	core::dimension2d<u32> size = texture->getSize();
 	video::ECOLOR_FORMAT format = texture->getColorFormat();
 	if (format == video::ECF_A8R8G8B8) {
 		// Texture is in the correct color format, we can pass it
 		// to extrudeARGB right away.
@@ -367,16 +372,16 @@
 		if (data == NULL)
 			return NULL;
 		mesh = extrudeARGB(size.Width, size.Height, (u8*) data);
 		texture->unlock();
 	}else{
-		video::IImage *img1 = driver->createImageFromData(format, size, texture->lock(MY_ETLM_READ_ONLY));
+		video::IImage* const img1 = driver->createImageFromData(format, size, texture->lock(MY_ETLM_READ_ONLY));
 		if (img1 == NULL)
 			return NULL;
 
 		// img1 is in the texture's color format, convert to 8-bit ARGB
-		video::IImage *img2 = driver->createImage(video::ECF_A8R8G8B8, size);
+		video::IImage* const img2 = driver->createImage(video::ECF_A8R8G8B8, size);
 		if (img2 != NULL) {
 			img1->copyTo(img2);
 
 			mesh = extrudeARGB(size.Width, size.Height, (u8*) img2->lock());
 			img2->unlock();
@@ -432,63 +437,70 @@
 		}
 	}
 	mesh->setBoundingBox(bbox);
 }
 
-void translateMesh(scene::IMesh *mesh, v3f vec)
+void translateMesh(scene::IMesh* const mesh,const v3f vec)
 {
 	if (mesh == NULL)
 		return;
 
 	core::aabbox3d<f32> bbox;
 	bbox.reset(0,0,0);
 
-	u16 mc = mesh->getMeshBufferCount();
-	for (u16 j=0; j<mc; j++) {
-		scene::IMeshBuffer *buf = mesh->getMeshBuffer(j);
+	const u16 mc = mesh->getMeshBufferCount();
+	for (u16 j=0; j<mc; j++)
+	{
+		scene::IMeshBuffer* const buf = mesh->getMeshBuffer(j);
 		if (!buf)
 			continue;
-		u16 vc = buf->getVertexCount();
+		
+		const u16 vc = buf->getVertexCount();
 		if (!vc)
 			continue;
-		video::S3DVertex *vertices = (video::S3DVertex*)buf->getVertices();
+		
+		video::S3DVertex* const vertices =
+		    (video::S3DVertex*)buf->getVertices();
 		if (!vertices)
 			continue;
+		
 		for (u16 i=0; i<vc; i++) {
 			vertices[i].Pos += vec;
 		}
 		buf->recalculateBoundingBox();
 
 		// calculate total bounding box
-		if (j == 0) {
+		if (j == 0)
 			bbox = buf->getBoundingBox();
-		}else{
+		else
 			bbox.addInternalBox(buf->getBoundingBox());
-		}
 	}
+	
 	mesh->setBoundingBox(bbox);
 }
 
 void setMeshColor(scene::IMesh *mesh, const video::SColor &color)
 {
 	if (mesh == NULL)
 		return;
 
-	u16 mc = mesh->getMeshBufferCount();
+	const u16 mc = mesh->getMeshBufferCount();
 	for (u16 j=0; j<mc; j++) {
-		scene::IMeshBuffer *buf = mesh->getMeshBuffer(j);
+		scene::IMeshBuffer* const buf = mesh->getMeshBuffer(j);
 		if (!buf)
 			continue;
+		
 		u16 vc = buf->getVertexCount();
 		if (!vc)
 			continue;
+		
 		video::S3DVertex *vertices = (video::S3DVertex*)buf->getVertices();
 		if (!vertices)
 			continue;
-		for (u16 i=0; i<vc; i++) {
+		
+		for (u16 i=0; i<vc; i++)
 			vertices[i].Color = color;
-		}
 	}
 }
 
 void setMeshColorByNormalXYZ(scene::IMesh *mesh,
 		const video::SColor &colorX,
@@ -496,21 +508,24 @@
 		const video::SColor &colorZ)
 {
 	if (mesh == NULL)
 		return;
 
-	u16 mc = mesh->getMeshBufferCount();
+	const u16 mc = mesh->getMeshBufferCount();
 	for (u16 j=0; j<mc; j++) {
-		scene::IMeshBuffer *buf = mesh->getMeshBuffer(j);
+		scene::IMeshBuffer* const buf = mesh->getMeshBuffer(j);
 		if (!buf)
 			continue;
-		u16 vc = buf->getVertexCount();
+		
+		const u16 vc = buf->getVertexCount();
 		if (!vc)
 			continue;
-		video::S3DVertex *vertices = (video::S3DVertex*)buf->getVertices();
+		
+		video::S3DVertex* const vertices = (video::S3DVertex*)buf->getVertices();
 		if (!vertices)
 			continue;
+		
 		for (u16 i=0; i<vc; i++) {
 			f32 x = fabs(vertices[i].Normal.X);
 			f32 y = fabs(vertices[i].Normal.Y);
 			f32 z = fabs(vertices[i].Normal.Z);
 			if (x >= y && x >= z) {
@@ -534,11 +549,11 @@
 		video::SColorf ambient_light,
 		v3f light_position,
 		video::SColorf light_color,
 		f32 light_radius)
 {
-	video::IVideoDriver *driver = device->getVideoDriver();
+	video::IVideoDriver* const driver = device->getVideoDriver();
 	if(driver->queryFeature(video::EVDF_RENDER_TO_TARGET) == false)
 	{
 		static bool warned = false;
 		if(!warned)
 		{
@@ -561,16 +576,17 @@
 
 	// Set render target
 	driver->setRenderTarget(rtt, false, true, video::SColor(0,0,0,0));
 
 	// Get a scene manager
-	scene::ISceneManager *smgr_main = device->getSceneManager();
+	scene::ISceneManager* const smgr_main = device->getSceneManager();
 	assert(smgr_main);
-	scene::ISceneManager *smgr = smgr_main->createNewSceneManager();
+	scene::ISceneManager* const smgr = smgr_main->createNewSceneManager();
 	assert(smgr);
 
-	scene::IMeshSceneNode* meshnode = smgr->addMeshSceneNode(mesh, NULL, -1, v3f(0,0,0), v3f(0,0,0), v3f(1,1,1), true);
+	scene::IMeshSceneNode* const meshnode =
+	    smgr->addMeshSceneNode(mesh, NULL, -1, v3f(0,0,0), v3f(0,0,0), v3f(1,1,1), true);
 	meshnode->setMaterialFlag(video::EMF_LIGHTING, true);
 	meshnode->setMaterialFlag(video::EMF_ANTI_ALIASING, true);
 	meshnode->setMaterialFlag(video::EMF_BILINEAR_FILTER, true);
 
 	scene::ICameraSceneNode* camera = smgr->addCameraSceneNode(0,
diff -rU5 voxelands-v1709.00old/src/mesh.h voxelands-v1709.00good/src/mesh.h
--- voxelands-v1709.00old/src/mesh.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mesh.h	2024-09-22 18:41:01.712655805 +0200
@@ -72,11 +72,11 @@
 void scaleMesh(scene::IMesh *mesh, v3f scale);
 
 /*
 	Translate each vertex coordinate by the specified vector.
 */
-void translateMesh(scene::IMesh *mesh, v3f vec);
+void translateMesh(scene::IMesh* const mesh,const v3f vec);
 
 /*
 	Set a constant color for all vertices in the mesh
 */
 void setMeshColor(scene::IMesh *mesh, const video::SColor &color);
@@ -118,11 +118,11 @@
 	content like stone and mud, which are shown as cubes), the option to
 	draw a textured cube instead is provided.
  */
 class ExtrudedSpriteSceneNode: public scene::ISceneNode
 {
-public:
+    public:
 	ExtrudedSpriteSceneNode(
 		scene::ISceneNode* parent,
 		scene::ISceneManager* mgr,
 		s32 id = -1,
 		const v3f& position = v3f(0,0,0),
@@ -144,11 +144,12 @@
 
 	virtual const core::aabbox3d<f32>& getBoundingBox() const;
 	virtual void OnRegisterSceneNode();
 	virtual void render();
 
-private:
+    private:
+	
 	scene::IMeshSceneNode* m_meshnode;
 	f32 m_thickness;
 	scene::IMesh* m_cubemesh;
 	bool m_is_cube;
 	u8 m_light;
diff -rU5 voxelands-v1709.00old/src/modalMenu.h voxelands-v1709.00good/src/modalMenu.h
--- voxelands-v1709.00old/src/modalMenu.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/modalMenu.h	2024-09-22 18:41:01.712655805 +0200
@@ -32,10 +32,11 @@
 
 class IMenuManager
 {
 public:
 	// A GUIModalMenu calls these when this class is passed as a parameter
+	virtual ~IMenuManager() {};
 	virtual void createdMenu(GUIModalMenu *menu) = 0;
 	virtual void deletingMenu(GUIModalMenu *menu) = 0;
 };
 
 /*
diff -rU5 voxelands-v1709.00old/src/nvp.c voxelands-v1709.00good/src/nvp.c
--- voxelands-v1709.00old/src/nvp.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/nvp.c	2024-09-22 18:41:01.713655806 +0200
@@ -55,11 +55,11 @@
 			free(n->data);
 	}
 }
 
 /* get a name/value pair */
-nvp_t *nvp_get(nvp_t **list, char* name)
+nvp_t *nvp_get(nvp_t **list,const char* name)
 {
 	nvp_t *c = *list;
 	unsigned int h = hash(name);
 	while (c) {
 		if (c->h > h)
@@ -70,56 +70,56 @@
 	}
 	return NULL;
 }
 
 /* get the value of a name/value pair */
-char* nvp_get_str(nvp_t **list, char* name)
+char* nvp_get_str(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return c->value;
 	return NULL;
 }
 
 /* get the value of a name/value pair as an int value */
-int nvp_get_int(nvp_t **list, char* name)
+int nvp_get_int(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return strtol(c->value,NULL,10);
 	return 0;
 }
 
 /* get the value of a name/value pair as a float value */
-float nvp_get_float(nvp_t **list, char* name)
+float nvp_get_float(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return strtof(c->value,NULL);
 	return 0.0;
 }
 
 /* get the value of a name/value pair as a boolean value */
-int nvp_get_bool(nvp_t **list, char* name)
+int nvp_get_bool(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c && (!strcmp(c->value,"1") || !strcmp(c->value,"true")))
 		return 1;
 	return 0;
 }
 
 /* get a name/value pair's data value */
-void *nvp_get_data(nvp_t **list, char* name)
+void *nvp_get_data(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return c->data;
 	return NULL;
 }
 
 /* set the value of a name/value pair */
-void nvp_set(nvp_t **list, char* name, char* value, void *data)
+void nvp_set(nvp_t **list,const char* name,const char* value, void *data)
 {
 	nvp_t *c = *list;
 	unsigned int h = hash(name);
 
 	while (c) {
@@ -154,35 +154,35 @@
 
 	*list = list_insert_cmp(list,c,nvp_insert_cmp);
 }
 
 /* set a name/value pair to an int value */
-void nvp_set_int(nvp_t **list, char* name, int value)
+void nvp_set_int(nvp_t **list,const char* name, int value)
 {
 	char str[20];
 	sprintf(str,"%d",value);
 	nvp_set(list,name,str,NULL);
 }
 
 /* set a name/value pair to a float value */
-void nvp_set_float(nvp_t **list, char* name, float value)
+void nvp_set_float(nvp_t **list,const char* name, float value)
 {
 	char str[20];
 	sprintf(str,"%f",value);
 	nvp_set(list,name,str,NULL);
 }
 
 /* set a name/value pair to a float value */
-void nvp_set_v3t(nvp_t **list, char* name, v3_t *value)
+void nvp_set_v3t(nvp_t **list,const char* name, v3_t *value)
 {
 	char str[128];
 	sprintf(str,"(%f,%f,%f)",value->x,value->y,value->z);
 	nvp_set(list,name,str,NULL);
 }
 
 /* parse a name=value string to an nvp list */
-void nvp_from_str(nvp_t **list, char* str)
+void nvp_from_str(nvp_t **list,const char* str)
 {
 	char name[512];
 	char value[512];
 	uint8_t is_str = 0;
 	uint8_t is_value = 0;
diff -rU5 voxelands-v1709.00old/src/nvp.h voxelands-v1709.00good/src/nvp.h
--- voxelands-v1709.00old/src/nvp.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/nvp.h	2024-09-22 18:41:01.713655806 +0200
@@ -21,21 +21,21 @@
 } nvp_t;
 #endif
 
 /* defined in nvp.c */
 void nvp_free(nvp_t **list, int data);
-nvp_t *nvp_get(nvp_t **list, char* name);
-char* nvp_get_str(nvp_t **list, char* name);
-int nvp_get_int(nvp_t **list, char* name);
-float nvp_get_float(nvp_t **list, char* name);
-int nvp_get_bool(nvp_t **list, char* name);
-void *nvp_get_data(nvp_t **list, char* name);
-void nvp_set(nvp_t **list, char* name, char* value, void *data);
-void nvp_set_int(nvp_t **list, char* name, int value);
-void nvp_set_float(nvp_t **list, char* name, float value);
-void nvp_set_v3t(nvp_t **list, char* name, struct v3_s *value);
-void nvp_from_str(nvp_t **list, char* str);
+nvp_t *nvp_get(nvp_t **list,const char* name);
+char* nvp_get_str(nvp_t **list,const char* name);
+int nvp_get_int(nvp_t **list,const char* name);
+float nvp_get_float(nvp_t **list,const char* name);
+int nvp_get_bool(nvp_t **list,const char* name);
+void *nvp_get_data(nvp_t **list,const char* name);
+void nvp_set(nvp_t **list,const char* name,const char* value, void *data);
+void nvp_set_int(nvp_t **list,const char* name, int value);
+void nvp_set_float(nvp_t **list,const char* name, float value);
+void nvp_set_v3t(nvp_t **list,const char* name, struct v3_s *value);
+void nvp_from_str(nvp_t **list,const char* str);
 int nvp_to_str(nvp_t **list, char* buff, int size);
 
 #ifdef __cplusplus
 }
 #endif
diff -rU5 voxelands-v1709.00old/src/path.c voxelands-v1709.00good/src/path.c
--- voxelands-v1709.00old/src/path.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/path.c	2024-09-22 18:41:01.713655806 +0200
@@ -59,11 +59,11 @@
 	NULL,
 	NULL,
 	NULL
 };
 
-int path_check(char* base, char* rel)
+static int path_check(char* base,const char* rel)
 {
 	int l;
 	char path[2048];
 #ifndef WIN32
 	struct stat st;
@@ -103,11 +103,11 @@
 #endif
 
 	return 0;
 }
 
-static char* path_set(char* base, char* rel, char* buff, int size)
+static char* path_set(char* base,const char* rel, char* buff, int size)
 {
 	int l;
 	char path[2048];
 
 	if (!base && !rel)
@@ -342,11 +342,11 @@
 		free(path.screenshot);
 	path.screenshot = NULL;
 }
 
 /* sets path.data_custom */
-int path_custom_setter(char* p)
+int path_custom_setter(const char* p)
 {
 	if (path.data_custom)
 		free(path.data_custom);
 	path.data_custom = NULL;
 
@@ -355,11 +355,11 @@
 
 	return 0;
 }
 
 /* sets path.screenshot */
-int path_screenshot_setter(char* p)
+int path_screenshot_setter(const char* p)
 {
 	if (path.screenshot)
 		free(path.screenshot);
 	path.screenshot = NULL;
 
@@ -368,11 +368,11 @@
 
 	return 0;
 }
 
 /* sets the world path to user_data + /worlds/ + p, creates the path if necessary */
-int path_world_setter(char* p)
+int path_world_setter(const char* p)
 {
 	int c;
 	char buff[2048];
 	char* base = path.data_user;
 
@@ -419,11 +419,11 @@
  *
  * returns the path or NULL if either:
  *	must_exist is non-zero and the path doesn't exist
  *	buff is not NULL and too small to hold the full path
  */
-char* path_get(char* type, char* file, int must_exist, char* buff, int size)
+char* path_get(const char* type,const char* file, int must_exist, char* buff, int size)
 {
 	char rel_path[1024];
 
 	if (!file && !type)
 		return NULL;
@@ -501,11 +501,11 @@
 	}else if (!strcmp(type,"sound")) {
 		snprintf(rel_path,1024,"sounds/%s",file);
 	}else if (!strcmp(type,"font")) {
 		snprintf(rel_path,1024,"fonts/%s",file);
 	}else if (!strncmp(type,"translation-",12)) {
-		char* lang = type+12;
+		const char* lang = type+12;
 		type = "translation";
 		snprintf(rel_path,1024,"locale/%s/%s",lang,file);
 	}else{
 		strcpy(rel_path,file);
 	}
diff -rU5 voxelands-v1709.00old/src/path.h voxelands-v1709.00good/src/path.h
--- voxelands-v1709.00old/src/path.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/path.h	2024-09-22 18:41:01.713655806 +0200
@@ -16,14 +16,14 @@
 #endif
 
 /* defined in path.c */
 int path_init(void);
 void path_exit(void);
-int path_custom_setter(char* p);
-int path_screenshot_setter(char* p);
-int path_world_setter(char* p);
-char* path_get(char* type, char* file, int must_exist, char* buff, int size);
+int path_custom_setter(const char* p);
+int path_screenshot_setter(const char* p);
+int path_world_setter(const char* p);
+char* path_get(const char* type,const char* file, int must_exist, char* buff, int size);
 int path_exists(char* path);
 int path_create(char* type, char* file);
 int path_remove(char* type, char* path);
 dirlist_t *path_dirlist(char* type, char* path);
 void path_dirlist_free(dirlist_t *l);
diff -rU5 voxelands-v1709.00old/src/player.cpp voxelands-v1709.00good/src/player.cpp
--- voxelands-v1709.00old/src/player.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/player.cpp	2024-09-22 18:41:01.713655806 +0200
@@ -213,11 +213,11 @@
 }
 
 void Player::serialize(std::ostream &os)
 {
 	// Utilize a Settings object for storing values
-	char* flags[8] = {
+	const char* flags[8] = {
 		"flag_white",
 		"flag_blue",
 		"flag_green",
 		"flag_orange",
 		"flag_purple",
@@ -279,13 +279,13 @@
 
 void Player::deSerialize(std::istream &is)
 {
 	nvp_t *list = NULL;
 	std::string conf;
-	char* val;
+	const char* val;
 	v3_t v;
-	char* flags[8] = {
+	const char* flags[8] = {
 		"flag_white",
 		"flag_blue",
 		"flag_green",
 		"flag_orange",
 		"flag_purple",
@@ -637,11 +637,11 @@
 		if (!m_text)
 			return;
 		m_text->setPosition(v3f(0, (f32)BS*2.1, 0));
 
 		// get a unique mesh so that the player model has it's own lighting
-		scene::IAnimatedMesh* mesh = createModelMesh(mgr,"character.b3d",true);
+		scene::IAnimatedMesh* const mesh = createModelMesh(mgr,"character.b3d",true);
 		if (!mesh)
 			return;
 
 		m_node = mgr->addAnimatedMeshSceneNode(mesh,this);
 
@@ -699,11 +699,11 @@
 void RemotePlayer::wieldItem(u16 item)
 {
 	m_selected_item = item;
 	if (!m_wield)
 		return;
-	const InventoryItem *i = getWieldItem();
+	const InventoryItem* const i = getWieldItem();
 	if (!i) {
 		m_wield->setVisible(false);
 		return;
 	}
 	bool haveWield = false;
@@ -764,17 +764,21 @@
 	m_showpos = m_oldpos + movevector * moveratio;
 
 	int frame = m_node->getFrameNr();
 	/* roughly sort of when a step sound should probably be heard, maybe */
 	if (frame == 218 || frame == 186 || frame == 209 || frame == 177) {
+#if USE_AUDIO == 1
 		sound_play_step(&map,m_showpos,m_next_foot,1.0);
+#endif
 		m_next_foot = !m_next_foot;
 	}
 	/* roughly sort of when a dig sound should probably be heard, maybe */
+#if USE_AUDIO == 1
 	if (frame == 214 || frame == 205 || frame == 193) {
 		sound_play_dig(m_pointed,m_showpos);
 	}
+#endif
 
 	if (m_anim_id == PLAYERANIM_DIE) {
 		if (m_node->getEndFrame() != 167)
 			m_node->setFrameLoop(162,167);
 	}else{
@@ -859,11 +863,11 @@
 	m_sneak_node_exists(false),
 	m_can_use_energy(true),
 	m_ignore_energy(false),
 	m_low_energy_effect(0)
 {
-	char* v;
+	const char* v;
 	m_energy = 10.0;
 
 	v = config_get("client.character");
 	if (!v)
 		v = PLAYER_DEFAULT_CHARDEF;
@@ -1237,11 +1241,10 @@
 				m_character = std::string(PLAYER_DEFAULT_CHARDEF);
 			Strfnd f(m_character);
 			std::string gender = f.next(":");
 			std::string snd("low-energy-");
 			snd += gender;
-
 			m_low_energy_effect = sound_play_effect((char*)snd.c_str(),1.0,1,NULL);
 		}
 #endif
 	}else if (m_energy > 9.8) {
 		m_can_use_energy = true;
diff -rU5 voxelands-v1709.00old/src/player.h voxelands-v1709.00good/src/player.h
--- voxelands-v1709.00old/src/player.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/player.h	2024-09-22 18:41:01.713655806 +0200
@@ -187,11 +187,11 @@
 	}
 
 	virtual void wieldItem(u16 item);
 	virtual const InventoryItem *getWieldItem() const
 	{
-		const InventoryList *list = inventory.getList("main");
+		const InventoryList* const list = inventory.getList("main");
 		if (list)
 			return list->getItem(m_selected_item);
 		return NULL;
 	}
 	virtual u16 getSelectedItem() {return m_selected_item;}
diff -rU5 voxelands-v1709.00old/src/profiler.h voxelands-v1709.00good/src/profiler.h
--- voxelands-v1709.00old/src/profiler.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/profiler.h	2024-09-22 18:41:01.713655806 +0200
@@ -37,11 +37,11 @@
 */
 
 class Profiler
 {
 public:
-	Profiler()
+	Profiler() : m_mutex(),m_data(),m_avgcounts()
 	{
 		m_mutex.Init();
 	}
 
 	void add(const std::string &name, float value)
diff -rU5 voxelands-v1709.00old/src/selection_mesh.cpp voxelands-v1709.00good/src/selection_mesh.cpp
--- voxelands-v1709.00old/src/selection_mesh.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/selection_mesh.cpp	2024-10-27 17:11:13.147007855 +0100
@@ -62,16 +62,18 @@
 	for (std::map<v3s16, std::map<v3s16,SelectedNode> >::iterator i = selected_blocks.begin(); i != selected_blocks.end(); i++) {
 		/* create selection meshes */
 		v3s16 bp = i->first;
 		std::map<v3s16,SelectedNode> bselected = i->second;
 		MeshMakeData data;
-		MapBlock *block = map.getBlockNoCreateNoEx(bp);
+		MapBlock* const block = map.getBlockNoCreateNoEx(bp);
 		data.m_selected = bselected;
 		data.m_env = &client.getEnv();
 		data.fill(dn_ratio,block);
 		SelectionMesh *mesh = new SelectionMesh(&data);
 		meshes.push_back(mesh);
+		if(block)
+		    block->ResetCurrent();
 	}
 }
 
 void selection_draw(video::IVideoDriver* driver, Client &client, v3s16 camera_offset, std::vector<SelectedNode> &select)
 {
@@ -120,14 +122,14 @@
 	bool render_bilinear = config_get_bool("client.video.bilinear");
 	bool render_anisotropic = config_get_bool("client.video.anisotropic");
 	bool anim_textures = config_get_bool("client.graphics.texture.animations");
 
 	for (std::vector<SelectionMesh*>::iterator i = meshes.begin(); i != meshes.end(); i++) {
-			SelectionMesh *mesh = *i;
+			SelectionMesh* const mesh = *i;
 		if (!mesh || !mesh->getMesh())
 			continue;
-		scene::SMesh *m = mesh->getMesh();
+		scene::SMesh* const m = mesh->getMesh();
 		if (!m)
 			continue;
 		if (cos_changed)
 			translateMesh(m, cos_diff);
 
@@ -302,11 +304,12 @@
 			break;
 		default:;
 		}
 	}
 
-	scene::SMesh *mesh = new scene::SMesh();
+	scene::SMesh* const mesh = new scene::SMesh();
+	
 	for (u32 i=0; i<data->m_meshdata.size(); i++) {
 		MeshData &d = data->m_meshdata[i];
 
 		// - Texture animation
 		if (d.tile.material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES) {
@@ -318,18 +321,18 @@
 		}
 
 		// Create meshbuffer
 		// This is a "Standard MeshBuffer",
 		// it's a typedeffed CMeshBuffer<video::S3DVertex>
-		scene::SMeshBuffer *buf = new scene::SMeshBuffer();
+		scene::SMeshBuffer* const buf = new scene::SMeshBuffer();
+		
 		// Set material
 		buf->Material = d.tile.getMaterial();
 		// Add to mesh
 		mesh->addMeshBuffer(buf);
 		// Mesh grabbed it
 		buf->drop();
-
 		buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
 	}
 
 	translateMesh(mesh, intToFloat(data->m_blockpos_nodes - o_camera_offset, BS));
 
diff -rU5 voxelands-v1709.00old/src/server.cpp voxelands-v1709.00good/src/server.cpp
--- voxelands-v1709.00old/src/server.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/server.cpp	2024-10-27 17:58:19.217620913 +0100
@@ -82,15 +82,16 @@
 
 private:
 	bool *m_flag;
 };
 
-void * ServerThread::Thread()
+void* ServerThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("ServerThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
@@ -122,12 +123,13 @@
 }
 
 void * EmergeThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("EmergeThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
@@ -137,11 +139,11 @@
 
 		After queue is empty, exit.
 	*/
 	while(getRun())
 	{
-		QueuedBlockEmerge *qptr = m_server->m_emerge_queue.pop();
+		QueuedBlockEmerge* const qptr = m_server->m_emerge_queue.pop();
 		if (qptr == NULL)
 			break;
 
 		SharedPtr<QueuedBlockEmerge> q(qptr);
 
@@ -192,50 +194,55 @@
 
 			}
 		}
 
 		//vlprintf(CN_DEBUG,"EmergeThread: p=(%d,%d,%d) only_from_disk = %d",p.X,p.Y,p.Z,only_from_disk);
-
-		ServerMap &map = ((ServerMap&)m_server->m_env.getMap());
+		
+		JMutexAutoLock envlock(m_server->m_env_mutex);
+		ServerMap& map = ((ServerMap&) m_server->m_env.getMap());
 
 		//core::map<v3s16, MapBlock*> changed_blocks;
 		//core::map<v3s16, MapBlock*> lighting_invalidated_blocks;
 
-		MapBlock *block = NULL;
+		MapBlock* block = NULL;
 		bool got_block = true;
 		core::map<v3s16, MapBlock*> modified_blocks;
 
 		/*
 			Fetch block from map or generate a single block
 		*/
 		{
-			JMutexAutoLock envlock(m_server->m_env_mutex);
-
 			// Load sector if it isn't loaded
 			map.getSectorNoGenerateNoEx(p2d);
-
 			block = map.getBlockNoCreateNoEx(p);
-			if (!block || block->isDummy() || !block->isGenerated()) {
+			    
+			if (!block || block->isDummy() || !block->isGenerated())
+			{
 				bool was_generated = false;
 				//vlprintf(CN_DEBUG,"EmergeThread: not in memory, loading");
 
 				// Load/generate block
+				if(block)
+				    block->ResetCurrent();
 				block = map.loadBlock(p);
 
-				if (only_from_disk == false) {
-					if (block == NULL || block->isGenerated() == false) {
+				if (only_from_disk == false)
+				{
+					if (!block || block->isGenerated() == false)
+					{
 						//vlprintf(CN_DEBUG,"EmergeThread: generating");
 						block = map.generateBlock(p, modified_blocks);
 						was_generated = true;
 					}
 				}
 
 				//vlprintf(CN_DEBUG,"EmergeThread: ended up with: %s",analyze_block(block).c_str());
 
-				if (block == NULL) {
+				if (!block)
 					got_block = false;
-				}else{
+				else
+				{
 					/*
 						Ignore map edit events, they will not need to be
 						sent to anybody because the block hasn't been sent
 						to anybody
 					*/
@@ -243,11 +250,12 @@
 
 					// Activate objects and stuff
 					m_server->m_env.activateBlock(block, 3600);
 				}
 
-				if (was_generated && myrand_range(0,27) == 0) {
+				if (was_generated && myrand_range(0,27) == 0)
+				{
 					bool has_spawn = false;
 					bool water_spawn = false;
 					v3s16 bsp(0,0,0);
 					v3s16 sp(0,0,0);
 					v3s16 wsp(0,0,0);
@@ -285,30 +293,36 @@
 						}
 					}
 					}
 					}
 
-					if (water_spawn) {
-						if (myrand_range(0,5) == 0) {
+					if (water_spawn)
+					{
+						if (myrand_range(0,5) == 0)
 							mob_spawn_hostile(wsp,true,&m_server->m_env);
-						}else{
+						else
 							mob_spawn_passive(wsp,true,&m_server->m_env);
-						}
-					}else if (has_spawn) {
+					}
+					else if (has_spawn)
+					{
 						MapNode n = block->getNodeNoEx(bsp);
 						u8 overlay = (n.param1&0x0F);
-						if (overlay == 0x01 || overlay == 0x02 || (overlay == 0x04 && myrand_range(0,5) == 0)) {
+						if (overlay == 0x01 || overlay == 0x02
+								|| (overlay == 0x04 && myrand_range(0,5) == 0)) {
 							mob_spawn_passive(sp,false,&m_server->m_env);
 						}else if (overlay == 0x00 && block->getPosRelative().Y < -16) {
 							mob_spawn(sp,CONTENT_MOB_RAT,&m_server->m_env);
 						}else if (overlay == 0x08) {
 							for (int i=0; i<4; i++) {
 								mob_spawn(sp,CONTENT_MOB_FIREFLY,&m_server->m_env);
 							}
 						}
 					}
 				}
+
+				if(block)
+				    block->ResetCurrent();
 			}
 
 			// TODO: Some additional checking and lighting updating,
 			//       see emergeBlock
 		}
@@ -328,18 +342,21 @@
 
 		/*
 			Set the modified blocks unsent for all the clients
 		*/
 
-		for (core::map<u16, RemoteClient*>::Iterator i = m_server->m_clients.getIterator(); i.atEnd() == false; i++) {
-			RemoteClient *client = i.getNode()->getValue();
+		for (core::map<u16, RemoteClient*>::Iterator i = m_server->m_clients.getIterator(); i.atEnd() == false; i++)
+		{
+			RemoteClient* const client = i.getNode()->getValue();
 
 			// Remove block from sent history
 			if (modified_blocks.size() > 0)
 				client->SetBlocksNotSent(modified_blocks);
 		}
 
+		if(block)
+		    block->ResetCurrent();
 	}
 
 	END_DEBUG_EXCEPTION_HANDLER(errorstream)
 
 	return NULL;
@@ -348,10 +365,12 @@
 void RemoteClient::GetNextBlocks(Server *server, float dtime,
 		core::array<PrioritySortedBlockTransfer> &dest)
 {
 	DSTACK(__FUNCTION_NAME);
 
+    // Protected by mutexs in the caller.
+	
 	/*u32 timer_result;
 	TimeTaker timer("RemoteClient::GetNextBlocks", &timer_result);*/
 
 	// Increment timers
 	m_nothing_to_send_pause_timer -= dtime;
@@ -364,11 +383,11 @@
 	if (m_blocks_sending.size() >= (uint32_t)config_get_int("server.net.client.queue.size"))
 		return;
 
 	//TimeTaker timer("RemoteClient::GetNextBlocks");
 
-	Player *player = server->m_env.getPlayer(peer_id);
+	Player* const player = server->m_env.getPlayer(peer_id);
 
 	assert(player != NULL);
 
 	v3f playerpos = player->getPosition();
 	v3f playerspeed = player->getSpeed();
@@ -580,15 +599,14 @@
 				Don't generate or send if not in sight
 				FIXME This only works if the client uses a small enough
 				FOV setting. The default of 72 degrees is fine.
 			*/
 
-			float camera_fov = (72.0*PI/180) * 4./3.;
+			const float camera_fov = (72.0*PI/180) * 4./3.;
+			
 			if(isBlockInSight(p, camera_pos, camera_dir, camera_fov, 10000*BS) == false)
-			{
 				continue;
-			}
 #endif
 			/*
 				Don't send already sent blocks
 			*/
 			{
@@ -599,15 +617,15 @@
 			}
 
 			/*
 				Check if map has this block
 			*/
-			MapBlock *block = server->m_env.getMap().getBlockNoCreateNoEx(p);
-
+			MapBlock* const block = server->m_env.getMap().getBlockNoCreateNoEx(p);
 			bool surely_not_found_on_disk = false;
 			bool block_is_invalid = false;
-			if(block != NULL)
+			
+			if(block)
 			{
 				// Reset usage timer, this block will be of use in the future.
 				block->resetUsageTimer();
 
 				// Block is dummy if data doesn't exist.
@@ -649,10 +667,11 @@
 				{
 					if(block->dayNightDiffed() == false)
 						continue;
 				}
 #endif
+				block->ResetCurrent();
 			}
 
 			/*
 				If block has been marked to not exist on disk (dummy)
 				and generating new ones is not wanted, skip block.
@@ -1442,10 +1461,12 @@
 		Send queued-for-sending map edit events.
 	*/
 	{
 		// Don't send too many at a time
 		//u32 count = 0;
+		JMutexAutoLock envlock(m_env_mutex);
+		JMutexAutoLock conlock(m_con_mutex);
 
 		// Single change sending is disabled if queue size is not small
 		bool disable_single_change_sending = false;
 		if(m_unsent_map_edit_queue.size() >= 4)
 			disable_single_change_sending = true;
@@ -1523,12 +1544,17 @@
 				for(core::map<v3s16, bool>::Iterator
 						i = event->modified_blocks.getIterator();
 						i.atEnd()==false; i++)
 				{
 					v3s16 p = i.getNode()->getKey();
-					modified_blocks2.insert(p,
-							m_env.getMap().getBlockNoCreateNoEx(p));
+					MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(p);
+
+					if(block)
+					{
+					    modified_blocks2.insert(p,block);
+					    block->ResetCurrent();
+					}
 				}
 				// Set blocks not sent
 				for(core::list<u16>::Iterator
 						i = far_players.begin();
 						i != far_players.end(); i++)
@@ -1561,17 +1587,13 @@
 	*/
 	{
 		float &counter = m_objectdata_timer;
 		counter += dtime;
 		if (counter >= config_get_float("server.net.client.object.interval")) {
-			JMutexAutoLock lock1(m_env_mutex);
-			JMutexAutoLock lock2(m_con_mutex);
-
 			//ScopeProfiler sp(g_profiler, "Server: sending player positions");
 
 			SendPlayerInfo(counter);
-
 			counter = 0.0;
 		}
 	}
 
 	/*
@@ -1819,11 +1841,11 @@
 		char checkpwd[64];
 		if (auth_exists(playername)) {
 			if (auth_getpwd(playername,checkpwd))
 				checkpwd[0] = 0;
 		}else{
-			char* default_pwd = config_get("world.server.client.default.password");
+			const char* default_pwd = config_get("world.server.client.default.password");
 			if (default_pwd && default_pwd[0]) {
 				std::string defaultpwd = translatePassword(playername,narrow_to_wide(defaultpwd));
 				strcpy(checkpwd,defaultpwd.c_str());
 			}else{
 				strcpy(checkpwd,password);
@@ -1843,11 +1865,11 @@
 
 		// Add player to auth manager
 		if (!auth_exists(playername)) {
 			infostream<<"Server: adding player "<<playername<<" to auth manager"<<std::endl;
 			uint64_t privs = 0;
-			char* priv = config_get("world.server.client.default.privs");
+			const char* priv = config_get("world.server.client.default.privs");
 			if (priv)
 				privs = auth_str2privs(priv);
 
 			auth_add(playername);
 			auth_setpwd(playername,checkpwd);
@@ -1855,11 +1877,11 @@
 			auth_save();
 		}
 
 		// Enforce user limit.
 		// Don't enforce for users that have some admin right
-		char* admin_name = config_get("world.server.admin");
+		const char* admin_name = config_get("world.server.admin");
 		if (
 			m_clients.size() >= (uint16_t)config_get_int("world.server.client.max")
 			&& (auth_getprivs(playername) & (PRIV_SERVER|PRIV_BAN|PRIV_PRIVS)) == 0
 			&& (!admin_name || strcmp(admin_name,playername))
 		) {
@@ -2037,11 +2059,11 @@
 
 		if ((getPlayerPrivs(player) & PRIV_BUILD) == 0)
 			return;
 
 		ToolItem *titem = NULL;
-		InventoryList *ilist = player->inventory.getList("main");
+		InventoryList* const ilist = player->inventory.getList("main");
 		if (ilist == NULL)
 			return;
 
 		// Get item
 		InventoryItem *item = ilist->getItem(item_i);
@@ -2088,11 +2110,11 @@
 		}
 
 		v3f pf((f32)ps.X/100., (f32)ps.Y/100., (f32)ps.Z/100.);
 		v3f sf((f32)ss.X/100., (f32)ss.Y/100., (f32)ss.Z/100.);
 
-		ServerActiveObject *obj = new MobSAO(&m_env, 0, pf, sf*content_mob_features(thrown).static_thrown_speed*BS, thrown);
+		ServerActiveObject* const obj = new MobSAO(&m_env, 0, pf, sf*content_mob_features(thrown).static_thrown_speed*BS, thrown);
 
 		if (obj == NULL) {
 			infostream<<"WARNING: item resulted in NULL object, "
 							<<"not throwing into map"
 							<<std::endl;
@@ -2109,11 +2131,11 @@
 			if (item->getCount() <= 1) {
 				if (item->getCount() < 1)
 					infostream<<"WARNING: Server: dropped more items"
 							<<" than the slot contains"<<std::endl;
 
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (ilist)
 					// Remove from inventory and send inventory
 					ilist->deleteItem(item_i);
 			}else{
 				item->remove(1);
@@ -2125,18 +2147,18 @@
 		}
 	}
 	break;
 	case TOSERVER_USEITEM:
 	{
-		InventoryList *ilist = player->inventory.getList("main");
+		InventoryList* const ilist = player->inventory.getList("main");
 		if (ilist == NULL)
 			return;
 
-		u16 item_i = player->getSelectedItem();
+		const u16 item_i = player->getSelectedItem();
 
 		// Get item
-		InventoryItem *item = ilist->getItem(item_i);
+		InventoryItem* const item = ilist->getItem(item_i);
 		if (item == NULL)
 			return;
 
 		// Track changes super-crappily
 		u16 oldhp = player->health;
@@ -2276,29 +2298,29 @@
 		// Left click, pick object up (usually)
 		if (button == 0) {
 			content_t wield_item = CONTENT_IGNORE;
 			ToolItem *titem = NULL;
 
-			InventoryList *mlist = player->inventory.getList("main");
+			InventoryList* const mlist = player->inventory.getList("main");
 			if (mlist != NULL) {
-				InventoryItem *item = mlist->getItem(item_i);
+				InventoryItem* const item = mlist->getItem(item_i);
 				if (item) {
 					wield_item = item->getContent();
 					if ((wield_item&CONTENT_TOOLITEM_MASK) == CONTENT_TOOLITEM_MASK)
 						titem = (ToolItem*)item;
 				}
 			}
 			/*
 				Try creating inventory item
 			*/
-			InventoryItem *item = obj->createPickedUpItem(wield_item);
+			InventoryItem* item = obj->createPickedUpItem(wield_item);
 
 			if (item) {
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (ilist != NULL) {
-					actionstream<<player->getName()<<" picked up "
-							<<item->getName()<<std::endl;
+					actionstream << player->getName() << " picked up "
+							<< item->getName() << std::endl;
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Skip if inventory has no free space
 						if (ilist->roomForItem(item) == false) {
 							infostream<<"Player inventory has no free space"<<std::endl;
 							return;
@@ -2335,11 +2357,11 @@
 						&& obj->getType() == ACTIVEOBJECT_TYPE_MOB
 					) {
 						InventoryList *mlist = player->inventory.getList("main");
 						if (mlist != NULL) {
 							for (u32 i=0; i<(8*4); i++) {
-								InventoryItem *item = mlist->getItem(i);
+								InventoryItem* const item = mlist->getItem(i);
 								if (item && item->getContent() == CONTENT_TOOLITEM_MOB_SPAWNER && item->getData() == 0) {
 									MobSAO *mob = (MobSAO*)obj;
 									item->setData(mob->getContent());
 									obj->m_removed = true;
 									if (config_get_bool("world.player.tool.wear")) {
@@ -2360,14 +2382,14 @@
 
 				u16 wear = obj->punch(wield_item, dir, player->getName());
 				item = obj->createPickedUpItem(wield_item);
 				/* killing something might have caused a drop */
 				if (item) {
-					InventoryList *ilist = player->inventory.getList("main");
+					InventoryList* const ilist = player->inventory.getList("main");
 					if (ilist != NULL) {
 						actionstream<<player->getName()<<" picked up "
-								<<item->getName()<<std::endl;
+								<< item->getName() << std::endl;
 						if (!config_get_bool("world.player.inventory.creative")) {
 							// Skip if inventory has no free space
 							if (ilist->roomForItem(item) == false) {
 								infostream<<"Player inventory has no free space"<<std::endl;
 								return;
@@ -2471,14 +2493,12 @@
 				if (pp.getDistanceFrom(spf) <= sg)
 					return;
 			}
 		}
 
-		InventoryItem *wielditem = (InventoryItem*)player->getWieldItem();
-		content_t wieldcontent = CONTENT_IGNORE;
-		if (wielditem)
-			wieldcontent = wielditem->getContent();
+		InventoryItem* const wielditem = (InventoryItem*) player->getWieldItem();
+		const content_t wieldcontent = wielditem ? wielditem->getContent() : CONTENT_IGNORE;
 		ToolItemFeatures wielded_tool_features = content_toolitem_features(wieldcontent);
 		CraftItemFeatures *wielded_craft_features = content_craftitem_features(wieldcontent);
 		ContentFeatures &wielded_material_features = content_features(wieldcontent);
 
 		bool selected_node_exists = false;
@@ -2554,18 +2574,18 @@
 					}
 					selected_node.setContent(c);
 					// send the node
 					sendAddNode(p_under, selected_node, 0, &far_players, 30);
 					// wear out the key - admin's key doesn't wear
-					ToolItem *titem = (ToolItem*)wielditem;
+					ToolItem* const titem = (ToolItem*)wielditem;
 					if (
 						!wielded_tool_features.has_super_unlock_effect
 						&& (getPlayerPrivs(player) & PRIV_SERVER) == 0
 						&& config_get_bool("world.player.tool.wear")
 					) {
 						bool weared_out = titem->addWear(1);
-						InventoryList *mlist = player->inventory.getList("main");
+						InventoryList* const mlist = player->inventory.getList("main");
 						if (weared_out) {
 							mlist->deleteItem(item_i);
 						}else{
 							mlist->addDiff(item_i,titem);
 						}
@@ -2577,46 +2597,54 @@
 					MapEditEventIgnorer ign(&m_ignore_map_edit_events);
 
 					std::string p_name = std::string(player->getName());
 					m_env.getMap().addNodeAndUpdate(p_under, selected_node, modified_blocks, p_name);
 				}
-				if (ometa) {
+				
+				if (ometa)
+				{
 					//m_env.getMap().setNodeMetadata(p_under,ometa);
 					meta = m_env.getMap().getNodeMetadata(p_under);
-					if (meta) {
+					if (meta)
+					{
 						meta->import(ometa);
 						meta->setOwner(player->getName());
 						delete ometa;
 					}
 				}
+				
 				v3s16 blockpos = getNodeBlockPos(p_under);
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 				if (block)
+				{
 					block->setChangedFlag();
-
+					block->ResetCurrent();
+				}
+				
 				for(core::map<u16, RemoteClient*>::Iterator
 					i = m_clients.getIterator();
 					i.atEnd()==false; i++)
 				{
 					RemoteClient *client = i.getNode()->getValue();
 					client->SetBlocksNotSent(modified_blocks);
 					client->SetBlockNotSent(blockpos);
 				}
-			}else if (
-				selected_node_features.onpunch_gives_inventory
-				&& (meta = m_env.getMap().getNodeMetadata(p_under))
-				&& (meta->getInventory())
-				&& (meta->getInventory()->getList("main"))
-				&& (meta->getInventory()->getList("main")->getUsedSlots() > 0)
-			) {
-				Inventory *inv = meta->getInventory();
-				if (inv) {
+			}
+			else if (selected_node_features.onpunch_gives_inventory
+					&& (meta = m_env.getMap().getNodeMetadata(p_under))
+					&& (meta->getInventory())
+					&& (meta->getInventory()->getList("main"))
+					&& (meta->getInventory()->getList("main")->getUsedSlots() > 0))
+			{
+				Inventory* const inv = meta->getInventory();
+				if (inv)
+				{
 					InventoryList *list = inv->getList("main");
 					if (list) {
 						u16 max = list->getSize();
 						for (u16 i=0; i<max; i++) {
-							InventoryItem *itm = list->changeItem(i,NULL);
+							InventoryItem* const itm = list->changeItem(i,NULL);
 							if (!itm)
 								continue;
 							player->inventory.addItem("main", itm);
 						}
 						// Send inventory
@@ -2693,14 +2721,17 @@
 						delete ometa;
 					}
 				}
 
 				v3s16 blockpos = getNodeBlockPos(p_under);
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 				if (block)
+				{
 					block->setChangedFlag();
-
+					block->ResetCurrent();
+				}
+				
 				for(core::map<u16, RemoteClient*>::Iterator
 					i = m_clients.getIterator();
 					i.atEnd()==false; i++)
 				{
 					RemoteClient *client = i.getNode()->getValue();
@@ -2748,11 +2779,11 @@
 						if (client == NULL)
 							continue;
 						client->SetBlocksNotSent(modified_blocks);
 					}
 				}
-				ToolItem *titem = (ToolItem*)wielditem;
+				ToolItem* const titem = (ToolItem*)wielditem;
 				if (config_get_bool("world.player.tool.wear")) {
 					bool weared_out = titem->addWear(1);
 					InventoryList *mlist = player->inventory.getList("main");
 					if (weared_out) {
 						mlist->deleteItem(item_i);
@@ -2768,11 +2799,11 @@
 					meta = m_env.getMap().getNodeMetadata(p_under);
 					if (meta && !meta->getEnergy()) {
 						v3s16 pp = floatToInt(player->getPosition(),BS);
 						meta->energise(ENERGY_MAX,pp,pp,p_under);
 					}
-					ToolItem *titem = (ToolItem*)wielditem;
+					ToolItem* const titem = (ToolItem*) wielditem;
 					if (config_get_bool("world.player.tool.wear")) {
 						bool weared_out = titem->addWear(1);
 						InventoryList *mlist = player->inventory.getList("main");
 						if (weared_out) {
 							mlist->deleteItem(item_i);
@@ -2797,12 +2828,13 @@
 				|| selected_content == CONTENT_PINE_BARREL
 			) {
 				BarrelNodeMetadata *bmeta = (BarrelNodeMetadata*)m_env.getMap().getNodeMetadata(p_under);
 				if (!bmeta)
 					return;
-				if (wielded_tool_features.type == TT_BUCKET) {
-					content_t c = wielditem->getData();
+				if (wielded_tool_features.type == TT_BUCKET)
+				{
+					const content_t c = wielditem->getData();
 					if (!c) {
 						if (bmeta->m_water_level < 4)
 							return;
 						wielditem->setData(CONTENT_WATERSOURCE);
 						InventoryList *mlist = player->inventory.getList("main");
@@ -2823,13 +2855,14 @@
 						bmeta->m_water_level += 4;
 					}else if (c == CONTENT_LAVASOURCE) {
 						return;
 					}
 					v3s16 blockpos = getNodeBlockPos(p_under);
-					MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+					MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 					if (!block)
 						return;
+					
 					block->setChangedFlag();
 					core::map<v3s16, MapBlock*> modified_blocks;
 					modified_blocks.insert(block->getPos(),block);
 
 					for(core::map<u16, RemoteClient*>::Iterator
@@ -2838,11 +2871,14 @@
 					{
 						RemoteClient *client = i.getNode()->getValue();
 						client->SetBlocksNotSent(modified_blocks);
 						client->SetBlockNotSent(blockpos);
 					}
-				}else if (wielded_tool_features.type == TT_NONE) {
+					block->ResetCurrent();
+				}
+				else if (wielded_tool_features.type == TT_NONE)
+				{
 					core::list<u16> far_players;
 					core::map<v3s16, MapBlock*> modified_blocks;
 
 					meta = m_env.getMap().getNodeMetadata(p_under);
 					NodeMetadata *ometa = NULL;
@@ -2868,29 +2904,32 @@
 
 						delete ometa;
 					}
 
 					v3s16 blockpos = getNodeBlockPos(p_under);
-					MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+					MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 					if (block)
+					{
 						block->setChangedFlag();
-
+						block->ResetCurrent();
+					}
+					
 					for(core::map<u16, RemoteClient*>::Iterator
 						i = m_clients.getIterator();
 						i.atEnd()==false; i++)
 					{
 						RemoteClient *client = i.getNode()->getValue();
 						client->SetBlocksNotSent(modified_blocks);
 						client->SetBlockNotSent(blockpos);
 					}
 				}
-			}else if (
-				selected_content == CONTENT_WOOD_BARREL_SEALED
-				|| selected_content == CONTENT_APPLEWOOD_BARREL_SEALED
-				|| selected_content == CONTENT_JUNGLEWOOD_BARREL_SEALED
-				|| selected_content == CONTENT_PINE_BARREL_SEALED
-			) {
+			}
+			else if (selected_content == CONTENT_WOOD_BARREL_SEALED
+					|| selected_content == CONTENT_APPLEWOOD_BARREL_SEALED
+					|| selected_content == CONTENT_JUNGLEWOOD_BARREL_SEALED
+					|| selected_content == CONTENT_PINE_BARREL_SEALED)
+			{
 				if (wielded_tool_features.type == TT_NONE) {
 					core::list<u16> far_players;
 					core::map<v3s16, MapBlock*> modified_blocks;
 
 					meta = m_env.getMap().getNodeMetadata(p_under);
@@ -2917,29 +2956,34 @@
 
 						delete ometa;
 					}
 
 					v3s16 blockpos = getNodeBlockPos(p_under);
-					MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+					MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 					if (block)
+					{
 						block->setChangedFlag();
-
+						block->ResetCurrent();
+					}
+					
 					for(core::map<u16, RemoteClient*>::Iterator
 						i = m_clients.getIterator();
 						i.atEnd()==false; i++)
 					{
 						RemoteClient *client = i.getNode()->getValue();
 						client->SetBlocksNotSent(modified_blocks);
 						client->SetBlockNotSent(blockpos);
 					}
 				}
-			}else if (selected_content == CONTENT_CAULDRON) {
+			}
+			else if (selected_content == CONTENT_CAULDRON)
+			{
 				CauldronNodeMetadata *cmeta = (CauldronNodeMetadata*)m_env.getMap().getNodeMetadata(p_under);
 				if (!cmeta)
 					return;
 				if (wielded_tool_features.type == TT_BUCKET) {
-					content_t c = wielditem->getData();
+					const content_t c = wielditem->getData();
 					if (!c) {
 						if (cmeta->m_water_level != 4)
 							return;
 						wielditem->setData(CONTENT_WATERSOURCE);
 						InventoryList *mlist = player->inventory.getList("main");
@@ -2960,11 +3004,11 @@
 						cmeta->m_water_level = 4;
 					}else if (c == CONTENT_LAVASOURCE) {
 						return;
 					}
 					v3s16 blockpos = getNodeBlockPos(p_under);
-					MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+					MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 					if (!block)
 						return;
 					block->setChangedFlag();
 					core::map<v3s16, MapBlock*> modified_blocks;
 					modified_blocks.insert(block->getPos(),block);
@@ -2975,21 +3019,25 @@
 					{
 						RemoteClient *client = i.getNode()->getValue();
 						client->SetBlocksNotSent(modified_blocks);
 						client->SetBlockNotSent(blockpos);
 					}
-				}else if (wieldcontent == CONTENT_CRAFTITEM_IRON_BOTTLE) {
-					if (cmeta->m_water_level && cmeta->m_water_hot && wielditem->getCount() == 1) {
-						InventoryItem *itm = InventoryItem::create(CONTENT_CRAFTITEM_IRON_BOTTLE_WATER,1,0);
-						InventoryList *mlist = player->inventory.getList("main");
-						InventoryItem *old = mlist->changeItem(item_i,itm);
+					block->ResetCurrent();
+				}
+				else if (wieldcontent == CONTENT_CRAFTITEM_IRON_BOTTLE)
+				{
+					if (cmeta->m_water_level && cmeta->m_water_hot && wielditem->getCount() == 1)
+					{
+						InventoryItem* const itm = InventoryItem::create(CONTENT_CRAFTITEM_IRON_BOTTLE_WATER,1,0);
+						InventoryList* const mlist = player->inventory.getList("main");
+						InventoryItem* const old = mlist->changeItem(item_i,itm);
 						if (old)
 							delete old;
 						cmeta->m_water_level--;
 						SendInventory(player->peer_id);
 						v3s16 blockpos = getNodeBlockPos(p_under);
-						MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+						MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 						if (!block)
 							return;
 						block->setChangedFlag();
 						core::map<v3s16, MapBlock*> modified_blocks;
 						modified_blocks.insert(block->getPos(),block);
@@ -3000,22 +3048,27 @@
 						{
 							RemoteClient *client = i.getNode()->getValue();
 							client->SetBlocksNotSent(modified_blocks);
 							client->SetBlockNotSent(blockpos);
 						}
+						block->ResetCurrent();
 					}
-				}else if (wieldcontent == CONTENT_CRAFTITEM_GLASS_BOTTLE) {
-					if (cmeta->m_water_level && cmeta->m_water_heated && !cmeta->m_water_hot && wielditem->getCount() == 1) {
-						InventoryItem *itm = InventoryItem::create(CONTENT_CRAFTITEM_GLASS_BOTTLE_WATER,1,0);
-						InventoryList *mlist = player->inventory.getList("main");
-						InventoryItem *old = mlist->changeItem(item_i,itm);
+				}
+				else if (wieldcontent == CONTENT_CRAFTITEM_GLASS_BOTTLE)
+				{
+					if (cmeta->m_water_level && cmeta->m_water_heated
+							&& !cmeta->m_water_hot && wielditem->getCount() == 1)
+					{
+						InventoryItem* const itm = InventoryItem::create(CONTENT_CRAFTITEM_GLASS_BOTTLE_WATER,1,0);
+						InventoryList* const mlist = player->inventory.getList("main");
+						InventoryItem* const old = mlist->changeItem(item_i,itm);
 						if (old)
 							delete old;
 						cmeta->m_water_level--;
 						SendInventory(player->peer_id);
 						v3s16 blockpos = getNodeBlockPos(p_under);
-						MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+						MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 						if (!block)
 							return;
 						block->setChangedFlag();
 						core::map<v3s16, MapBlock*> modified_blocks;
 						modified_blocks.insert(block->getPos(),block);
@@ -3026,22 +3079,25 @@
 						{
 							RemoteClient *client = i.getNode()->getValue();
 							client->SetBlocksNotSent(modified_blocks);
 							client->SetBlockNotSent(blockpos);
 						}
+						block->ResetCurrent();
 					}
 				}
-			}else if (selected_content == CONTENT_INCINERATOR) {
+			}
+			else if (selected_content == CONTENT_INCINERATOR)
+			{
 				meta = m_env.getMap().getNodeMetadata(p_under);
 				if (!meta)
 					return;
 				InventoryList *ilist = meta->getInventory()->getList("fuel");
 				InventoryList *plist = player->inventory.getList("main");
 				if (plist == NULL || ilist == NULL)
 					return;
 				if (((IncineratorNodeMetadata*)meta)->m_fuel_totaltime <= ((IncineratorNodeMetadata*)meta)->m_fuel_time) {
-					InventoryItem *fitem = ilist->getItem(0);
+					InventoryItem* const fitem = ilist->getItem(0);
 					if (!fitem || !fitem->getCount() || !fitem->isFuel())
 						return;
 					((IncineratorNodeMetadata*)meta)->m_should_fire = true;
 				}
 				plist->deleteItem(item_i);
@@ -3101,11 +3157,11 @@
 					// send the node
 					core::list<u16> far_players;
 					core::map<v3s16, MapBlock*> modified_blocks;
 					sendAddNode(p_under, selected_node, 0, &far_players, 30);
 					// wear out the crowbar
-					ToolItem *titem = (ToolItem*)wielditem;
+					ToolItem* const titem = (ToolItem*)wielditem;
 					if (config_get_bool("world.player.tool.wear")) {
 						bool weared_out = titem->addWear(1);
 						InventoryList *mlist = player->inventory.getList("main");
 						if (weared_out) {
 							mlist->deleteItem(item_i);
@@ -3126,33 +3182,39 @@
 						meta = m_env.getMap().getNodeMetadata(p_under);
 						if (meta)
 							meta->setOwner(owner);
 					}
 					v3s16 blockpos = getNodeBlockPos(p_under);
-					MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+					MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 					if (block)
+					{
 						block->setChangedFlag();
-
+						block->ResetCurrent();
+					}
+					
 					for(core::map<u16, RemoteClient*>::Iterator
 						i = m_clients.getIterator();
 						i.atEnd()==false; i++)
 					{
 						RemoteClient *client = i.getNode()->getValue();
 						client->SetBlocksNotSent(modified_blocks);
 						client->SetBlockNotSent(blockpos);
 					}
 				}
-			}else if (wieldcontent == CONTENT_CRAFTITEM_FERTILIZER && selected_node_features.fertilizer_affects) {
+			}
+			else if (wieldcontent == CONTENT_CRAFTITEM_FERTILIZER
+					&& selected_node_features.fertilizer_affects)
+			{
 				selected_node.envticks = 1024;
 				// send the node
 				core::list<u16> far_players;
 				core::map<v3s16, MapBlock*> modified_blocks;
 				sendAddNode(p_under, selected_node, 0, &far_players, 30);
 				/*
 					Handle inventory
 				*/
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (!config_get_bool("world.player.inventory.creative") && ilist) {
 					// Remove from inventory and send inventory
 					if (wielditem->getCount() == 1) {
 						ilist->deleteItem(item_i);
 					}else{
@@ -3169,14 +3231,17 @@
 
 					std::string p_name = std::string(player->getName());
 					m_env.getMap().addNodeAndUpdate(p_under, selected_node, modified_blocks, p_name);
 				}
 				v3s16 blockpos = getNodeBlockPos(p_under);
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 				if (block)
+				{
 					block->setChangedFlag();
-
+					block->ResetCurrent();
+				}
+				
 				for(core::map<u16, RemoteClient*>::Iterator
 					i = m_clients.getIterator();
 					i.atEnd()==false; i++)
 				{
 					RemoteClient *client = i.getNode()->getValue();
@@ -3455,13 +3520,13 @@
 				/*
 					Wear out tool
 				*/
 				InventoryList *mlist = player->inventory.getList("main");
 				if (mlist != NULL && config_get_bool("world.player.tool.wear")) {
-					InventoryItem *item = mlist->getItem(item_i);
+					InventoryItem* const item = mlist->getItem(item_i);
 					if (item && (item->getContent()&CONTENT_TOOLITEM_MASK) == CONTENT_TOOLITEM_MASK) {
-						ToolItem *titem = (ToolItem*)item;
+						ToolItem* const titem = (ToolItem*) item;
 						// Get digging properties for material and tool
 						tooluse_t usage;
 						if (get_tool_use(&usage,selected_content,mineral,titem->getContent(),titem->getData())) {
 							infostream<<"Server: WARNING: Player digged"
 								<<" with impossible material + tool"
@@ -3495,11 +3560,11 @@
 						Inventory *inv = meta->getInventory();
 						if (inv) {
 							InventoryList *l = inv->getList("0");
 							if (l) {
 								for (u32 i=0; i<32; i++) {
-									InventoryItem *itm = l->changeItem(i,NULL);
+									InventoryItem* const itm = l->changeItem(i,NULL);
 									if (!itm)
 										continue;
 									player->inventory.addItem("main", itm);
 								}
 								// Send inventory
@@ -3531,14 +3596,16 @@
 							SendInventory(player->peer_id);
 						}
 					}
 				}else if (selected_node_features.liquid_type == LIQUID_NONE) {
 					std::string &dug_s = selected_node_features.dug_item;
-					if (wielded_tool_features.type != TT_NONE && enchantment_have(wielditem->getData(),ENCHANTMENT_DONTBREAK)) {
+					if (wielded_tool_features.type != TT_NONE
+							&& enchantment_have(wielditem->getData(),ENCHANTMENT_DONTBREAK)) {
 						u16 data = 0;
-						if (selected_node_features.param_type == CPT_MINERAL || selected_node_features.param_type == CPT_BLOCKDATA)
-							data = selected_node.param1;
+						if (selected_node_features.param_type == CPT_MINERAL
+								|| selected_node_features.param_type == CPT_BLOCKDATA)
+						    data = selected_node.param1;
 						item = InventoryItem::create(selected_content,1,0,data);
 					}else if (
 						wielded_tool_features.type != TT_NONE
 						&& enchantment_have(wielditem->getData(),ENCHANTMENT_FLAME)
 						&& selected_node_features.cook_result != ""
@@ -3562,16 +3629,16 @@
 							}
 							if (extra == CONTENT_IGNORE) {
 								if ((selected_node.param1&0x20) == 0x20)
 									mineral = MINERAL_SALT;
 							}else if (myrand_range(0,5) == 0) {
-								InventoryItem *eitem = InventoryItem::create(extra,1,0);
+								InventoryItem* const eitem = InventoryItem::create(extra,1,0);
 								player->inventory.addItem("main", eitem);
 							}
 						}
 						if (item && selected_node_features.item_param_type == CPT_METADATA) {
-							NodeMetadata *meta = m_env.getMap().getNodeMetadata(p_under);
+							NodeMetadata* const meta = m_env.getMap().getNodeMetadata(p_under);
 							if (meta) {
 								uint16_t v = meta->getData();
 								item->setData(v);
 							}
 						}
@@ -3584,13 +3651,11 @@
 								if (selected_node_features.plantgrowth_small_dug_node != CONTENT_IGNORE) {
 									u16 count = 1;
 									if (p2 > 3)
 										count = 2;
 									item = InventoryItem::create(
-										selected_node_features.plantgrowth_small_dug_node,
-										count
-									);
+										selected_node_features.plantgrowth_small_dug_node,count);
 								}
 							}else{
 								if (selected_node_features.plantgrowth_large_gives_small) {
 									item = InventoryItem::create(
 										selected_node_features.plantgrowth_small_dug_node,
@@ -3607,13 +3672,11 @@
 									}
 								}
 								if (!count)
 									count = 1;
 								item = InventoryItem::create(
-									selected_node_features.plantgrowth_large_dug_node,
-									count
-								);
+									selected_node_features.plantgrowth_large_dug_node,count);
 							}
 						}else if (selected_node_features.draw_type == CDT_MELONLIKE) {
 							if (p2) {
 								if (p2 > 4) {
 									u16 count = 1;
@@ -3625,25 +3688,20 @@
 									item = InventoryItem::create(CONTENT_CRAFTITEM_MUSH,count,0);
 									player->inventory.addItem("main", item);
 								}
 								if (selected_node_features.plantgrowth_small_dug_node != CONTENT_IGNORE)
 									item = InventoryItem::create(
-										selected_node_features.plantgrowth_small_dug_node,
-										1
-									);
+										selected_node_features.plantgrowth_small_dug_node,1);
 							}else{
 								if (selected_node_features.plantgrowth_large_gives_small) {
 									item = InventoryItem::create(
-										selected_node_features.plantgrowth_small_dug_node,
-										1
-									);
+										selected_node_features.plantgrowth_small_dug_node,1);
 									player->inventory.addItem("main", item);
 								}
 								item = InventoryItem::create(
 									selected_node_features.plantgrowth_large_dug_node,
-									selected_node_features.plantgrowth_large_count
-								);
+									selected_node_features.plantgrowth_large_count);
 							}
 						}
 					}
 				}
 
@@ -3715,16 +3773,16 @@
 			1: place block
 		*/
 		else if(action == 1)
 		{
 			v3s16 p_dir = p_under - p_over;
-			InventoryList *ilist = player->inventory.getList("main");
+			InventoryList* const ilist = player->inventory.getList("main");
 			if (ilist == NULL)
 				return;
 
 			// Get item
-			InventoryItem *item = ilist->getItem(item_i);
+			InventoryItem* const item = ilist->getItem(item_i);
 
 			// If there is no item, it is not possible to add it anywhere
 			if (item == NULL)
 				return;
 
@@ -3988,14 +4046,14 @@
 				uint16_t idata = item->getData();
 
 				/*
 					Handle inventory
 				*/
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (!config_get_bool("world.player.inventory.creative") && ilist) {
 					if ((wieldcontent&CONTENT_TOOLITEM_MASK) == CONTENT_TOOLITEM_MASK) {
-						ToolItem *titem = (ToolItem*)wielditem;
+						ToolItem* const titem = (ToolItem*)wielditem;
 						if (titem->addWear(1)) {
 							ilist->deleteItem(item_i);
 						}else{
 							wielditem->setData(0);
 							ilist->addDiff(item_i,wielditem);
@@ -4085,16 +4143,13 @@
 				}
 
 				if (!config_get_bool("world.player.inventory.creative")) {
 					if (wielded_tool_features.onplace_replace_item != CONTENT_IGNORE) {
 						u16 wear = ((ToolItem*)wielditem)->getWear();
-						InventoryItem *item = InventoryItem::create(
-							wielded_tool_features.onplace_replace_item,
-							1,
-							wear
-						);
-						InventoryItem *citem = ilist->changeItem(item_i,item);
+						InventoryItem* const item = InventoryItem::create(
+							wielded_tool_features.onplace_replace_item,1,wear);
+						InventoryItem* const citem = ilist->changeItem(item_i,item);
 						if (citem)
 							delete citem;
 					}else{
 						ilist->deleteItem(item_i);
 					}
@@ -4139,19 +4194,19 @@
 					infostream<<"Not allowing player to drop item: "
 							"no build privs"<<std::endl;
 					return;
 				}
 				MapNode n = m_env.getMap().getNodeNoEx(p_over);
-				if (n.getContent() != CONTENT_AIR)
+				if (n.getContent() != CONTENT_AIR || !item)
 					return;
 				n.setContent(content_craftitem_features(item->getContent())->drop_item);
 				core::list<u16> far_players;
 				sendAddNode(p_over, n, 0, &far_players, 30);
 				if (!config_get_bool("world.player.inventory.creative")) {
 					// Delete the right amount of items from the slot
 					u16 dropcount = item->getDropCount();
-					InventoryList *ilist = player->inventory.getList("main");
+					InventoryList* const ilist = player->inventory.getList("main");
 					// Delete item if all gone
 					if (item->getCount() <= dropcount) {
 						if (item->getCount() < dropcount)
 							infostream<<"WARNING: Server: dropped more items"
 								<<" than the slot contains"<<std::endl;
@@ -4189,34 +4244,36 @@
 					RemoteClient *client = getClient(peer_id);
 					if(client==NULL)
 						continue;
 					client->SetBlocksNotSent(modified_blocks);
 				}
-			}else if (
-				(
-					wielded_tool_features.param_type == CPT_DROP
-					|| wielded_craft_features->param_type == CPT_DROP
-				)
-				&& wielditem->getData() != 0
-			) {
+			}
+			else if ((wielded_tool_features.param_type == CPT_DROP
+					|| wielded_craft_features->param_type == CPT_DROP)
+				&& wielditem->getData() != 0)
+			{
 				v3s16 blockpos = getNodeBlockPos(p_over);
 
 				/*
 					Check that the block is loaded so that the item
 					can properly be added to the static list too
 				*/
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
-				if (block==NULL) {
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				if (!block)
+				{
 					infostream<<"Error while placing object: "
 							"block not found"<<std::endl;
 					return;
 				}
 
-				if (!config_get_bool("world.player.inventory.droppable")) {
-					InventoryList *mlist = player->inventory.getList("main");
+				if (!config_get_bool("world.player.inventory.droppable"))
+				{
+					InventoryList* const mlist = player->inventory.getList("main");
 					mlist->deleteItem(item_i);
-				}else if ((getPlayerPrivs(player) & PRIV_BUILD) == 0) {
+				}
+				else if ((getPlayerPrivs(player) & PRIV_BUILD) == 0)
+				{
 					infostream<<"Not allowing player to drop item: no build privs"<<std::endl;
 					return;
 				}
 
 				// Calculate a position for it
@@ -4228,47 +4285,54 @@
 				pos.Z += BS*0.2*(float)myrand_range(-1000,1000)/1000.0;
 
 				/*
 					Create the object
 				*/
-				ServerActiveObject *obj = wielditem->createSAO(&m_env, 0, pos);
+				ServerActiveObject* const obj = wielditem->createSAO(&m_env, 0, pos);
 
-				if (obj == NULL) {
+				if (obj == NULL)
+				{
 					InventoryItem *nitem;
-					if (!config_get_bool("world.player.inventory.creative")) {
+					if (!config_get_bool("world.player.inventory.creative"))
+					{
 						// Delete the right amount of items from the slot
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 						nitem = ilist->changeItem(item_i,NULL);
 						// Send inventory
 						UpdateCrafting(peer_id);
 						SendInventory(peer_id);
-					}else{
-						nitem = wielditem->clone();
 					}
+					else
+						nitem = wielditem->clone();
 					m_env.dropToParcel(p_over,nitem);
-				}else{
+				}
+				else
+				{
 					actionstream<<player->getName()<<" places "<<item->getName()
 							<<" at "<<PP(p_over)<<std::endl;
 
 					// Add the object to the environment
 					m_env.addActiveObject(obj);
 
 					infostream<<"Placed object"<<std::endl;
 
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Delete the right amount of items from the slot
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 
 						wielditem->setData(0);
 						ilist->addDiff(item_i,wielditem);
 
 						// Send inventory
 						UpdateCrafting(peer_id);
 						SendInventory(peer_id);
 					}
 				}
-			}else if (wielded_craft_features->teleports > -2) {
+				block->ResetCurrent();
+			}
+			else if (wielded_craft_features->teleports > -2)
+			{
 				s8 dest = wielded_craft_features->teleports;
 				/*
 					If in creative mode, item dropping is disabled unless
 					player has build privileges
 				*/
@@ -4278,14 +4342,15 @@
 					return;
 				}
 				if (!config_get_bool("world.player.inventory.creative")) {
 					// Delete the right amount of items from the slot
 					u16 dropcount = item->getDropCount();
-					InventoryList *ilist = player->inventory.getList("main");
+					InventoryList* const ilist = player->inventory.getList("main");
 
 					// Delete item if all gone
-					if (item->getCount() <= dropcount) {
+					if (item->getCount() <= dropcount)
+					{
 						if (item->getCount() < dropcount)
 							infostream<<"WARNING: Server: dropped more items"
 									<<" than the slot contains"<<std::endl;
 
 						if (ilist)
@@ -4307,28 +4372,33 @@
 				SendMovePlayer(player);
 			}
 			/*
 				Place other item (not a block)
 			*/
-			else{
+			else
+			{
 				v3s16 blockpos = getNodeBlockPos(p_over);
 
 				/*
 					Check that the block is loaded so that the item
 					can properly be added to the static list too
 				*/
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
-				if (block==NULL) {
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				if (!block)
+				{
 					infostream<<"Error while placing object: "
 							"block not found"<<std::endl;
 					return;
 				}
 
-				if (!config_get_bool("world.player.inventory.droppable")) {
+				if (!config_get_bool("world.player.inventory.droppable"))
+				{
 					InventoryList *mlist = player->inventory.getList("main");
 					mlist->deleteItem(item_i);
-				}else if ((getPlayerPrivs(player) & PRIV_BUILD) == 0) {
+				}
+				else if ((getPlayerPrivs(player) & PRIV_BUILD) == 0)
+				{
 					infostream<<"Not allowing player to drop item: no build privs"<<std::endl;
 					return;
 				}
 
 				// Calculate a position for it
@@ -4342,47 +4412,64 @@
 				/*
 					Create the object
 				*/
 				ServerActiveObject *obj = NULL;
 				/* createSAO will drop all craft items, we may not want that */
-				if (
-					wielded_craft_features->content == wieldcontent
-					&& wielded_craft_features->drop_item == CONTENT_IGNORE
-				) {
-					InventoryItem *ditem = InventoryItem::create(wieldcontent,item->getDropCount());
+				if (wielded_craft_features->content == wieldcontent
+						&& wielded_craft_features->drop_item == CONTENT_IGNORE)
+				{
+				    InventoryItem* const ditem = InventoryItem::create(wieldcontent,item->getDropCount());
+				    obj = ditem->createSAO(&m_env, 0, pos);
+				    delete ditem;
+				}
+				else
+				{
+				    InventoryItem* const ditem = ilist->getItem(item_i);
+
+				    if(ditem)
 					obj = ditem->createSAO(&m_env, 0, pos);
-					delete ditem;
-				}else{
-					obj = item->createSAO(&m_env, 0, pos);
 				}
 
-				if (obj == NULL) {
-					InventoryItem *nitem;
-					if (!config_get_bool("world.player.inventory.creative")) {
+				if (obj == NULL)
+				{
+					InventoryItem* nitem = NULL;
+					if (!config_get_bool("world.player.inventory.creative"))
+					{
 						// Delete the right amount of items from the slot
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 						nitem = ilist->changeItem(item_i,NULL);
 						// Send inventory
 						UpdateCrafting(peer_id);
 						SendInventory(peer_id);
-					}else{
+					}
+					else
+					{
+					/* BUG PB : Get again, it can have disapperead. */
+					    InventoryItem* const wielditem = (InventoryItem*) player->getWieldItem();
+
+					    if(wielditem)
 						nitem = wielditem->clone();
 					}
-					m_env.dropToParcel(p_over,nitem);
-				}else{
+					if(nitem)
+					    m_env.dropToParcel(p_over,nitem);
+					block->ResetCurrent();
+				}
+				else
+				{
 					actionstream<<player->getName()<<" places "<<item->getName()
 							<<" at "<<PP(p_over)<<std::endl;
 
 					// Add the object to the environment
 					m_env.addActiveObject(obj);
 
 					infostream<<"Placed object"<<std::endl;
 
-					if (!config_get_bool("world.player.inventory.creative")) {
+					if (!config_get_bool("world.player.inventory.creative"))
+					{
 						// Delete the right amount of items from the slot
 						u16 dropcount = item->getDropCount();
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 
 						// Delete item if all gone
 						if (item->getCount() <= dropcount) {
 							if(item->getCount() < dropcount)
 								infostream<<"WARNING: Server: dropped more items"
@@ -4409,12 +4496,11 @@
 
 		/*
 			Catch invalid actions
 		*/
 		else{
-			infostream<<"WARNING: Server: Invalid action "
-					<<action<<std::endl;
+			infostream<<"WARNING: Server: Invalid action " << action << std::endl;
 		}
 	}
 	break;
 	case TOSERVER_PLAYERDAMAGE:
 	{
@@ -4661,12 +4747,12 @@
 					if (
 						ma->to_inv == "current_player"
 						&& ma->from_inv == "current_player"
 						&& ma->to_list == "discard"
 					) {
-						InventoryList *list = player->inventory.getList("discard");
-						InventoryItem *item = list->getItem(0);
+						InventoryList* const list = player->inventory.getList("discard");
+						InventoryItem* item = list->getItem(0);
 						if (item) {
 							if (config_get_bool("world.player.inventory.droppable")) {
 								v3f pos = player->getPosition();
 								pos.Y += BS;
 								v3f dir = v3f(0,0,BS);
@@ -4916,16 +5002,20 @@
 
 		NodeMetadata *meta = m_env.getMap().getNodeMetadata(p);
 		if (!meta)
 			return;
 
-		if (meta->receiveFields(formname,fields,player)) {
+		if (meta->receiveFields(formname,fields,player))
+		{
 			v3s16 blockpos = getNodeBlockPos(p);
-			MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+			MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 			if (block)
+			{
 				block->setChangedFlag();
-
+				block->ResetCurrent();
+			}
+			
 			for(core::map<u16, RemoteClient*>::Iterator
 				i = m_clients.getIterator();
 				i.atEnd()==false; i++)
 			{
 				RemoteClient *client = i.getNode()->getValue();
@@ -4983,38 +5073,44 @@
 	}
 
 	infostream<<__FUNCTION_NAME<<": unknown id "<<id<<std::endl;
 	return NULL;
 }
+
 void Server::inventoryModified(InventoryContext *c, std::string id)
 {
-	if (id == "current_player") {
+	if (id == "current_player")
+	{
 		assert(c->current_player);
 		// Send inventory
 		UpdateCrafting(c->current_player->peer_id);
 		SendInventory(c->current_player->peer_id);
 		return;
 	}
 
 	Strfnd fn(id);
 	std::string id0 = fn.next(":");
 
-	if (id0 == "nodemeta") {
+	if (id0 == "nodemeta")
+	{
 		v3s16 p;
 		p.X = mystoi(fn.next(","));
 		p.Y = mystoi(fn.next(","));
 		p.Z = mystoi(fn.next(","));
 		v3s16 blockpos = getNodeBlockPos(p);
 
-		NodeMetadata *meta = m_env.getMap().getNodeMetadata(p);
+		NodeMetadata* const meta = m_env.getMap().getNodeMetadata(p);
 		if (meta)
 			meta->inventoryModified();
 
-		MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+		MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 		if (block)
+		{
 			block->raiseModified(MOD_STATE_WRITE_NEEDED);
-
+			block->ResetCurrent();
+		}
+		
 		setBlockNotSent(blockpos);
 		return;
 	}
 
 	infostream<<__FUNCTION_NAME<<": unknown id "<<id<<std::endl;
@@ -5164,10 +5260,13 @@
 
 void Server::SendPlayerInfo(float dtime)
 {
 	DSTACK(__FUNCTION_NAME);
 
+	JMutexAutoLock lock1(m_env_mutex);
+	JMutexAutoLock lock2(m_con_mutex);
+
 	std::ostringstream os(std::ios_base::binary);
 	u8 buf[12];
 
 	// Write command
 	writeU16(buf, TOCLIENT_PLAYERINFO);
@@ -5321,22 +5420,22 @@
 		player = (Player*)array_get_ptr(players,i);
 		if (!player)
 			continue;
 
 		writeU16(os, player->peer_id);
-		InventoryItem *item = (InventoryItem*)player->getWieldItem();
+		InventoryItem* const item = (InventoryItem*)player->getWieldItem();
 		if (item == NULL) {
 			writeU16(os,CONTENT_IGNORE);
 		}else{
 			writeU16(os,item->getContent());
 		}
 		const char* list[7] = {"hat","shirt","pants","boots","decorative","jacket","belt"};
 		for (int j=0; j<7; j++) {
-			InventoryList *l = player->inventory.getList(list[j]);
+			InventoryList* const l = player->inventory.getList(list[j]);
 			if (l == NULL)
 				continue;
-			InventoryItem *itm = l->getItem(0);
+			InventoryItem* const itm = l->getItem(0);
 			if (itm == NULL) {
 				writeU16(os,CONTENT_IGNORE);
 				continue;
 			}
 			writeU16(os,itm->getContent());
@@ -5360,22 +5459,22 @@
 
 	writeU16(os, TOCLIENT_PLAYERITEMS);
 	writeU16(os, 1);
 	writeU16(os, 8);
 	writeU16(os, player->peer_id);
-	InventoryItem *item = (InventoryItem*)player->getWieldItem();
+	InventoryItem* const item = (InventoryItem*)player->getWieldItem();
 	if (item == NULL) {
 		writeU16(os,CONTENT_IGNORE);
 	}else{
 		writeU16(os,item->getContent());
 	}
 	const char* list[7] = {"hat","shirt","pants","boots","decorative","jacket","belt"};
 	for (int j=0; j<7; j++) {
-		InventoryList *l = player->inventory.getList(list[j]);
+		InventoryList* const l = player->inventory.getList(list[j]);
 		if (l == NULL)
 			continue;
-		InventoryItem *itm = l->getItem(0);
+		InventoryItem* const itm = l->getItem(0);
 		if (itm == NULL) {
 			writeU16(os,CONTENT_IGNORE);
 			continue;
 		}
 		writeU16(os,itm->getContent());
@@ -5708,28 +5807,35 @@
 	// Sort.
 	// Lowest priority number comes first.
 	// Lowest is most important.
 	queue.sort();
 
-	for (u32 i=0; i<queue.size(); i++) {
+	for (u32 i=0; i<queue.size(); i++)
+	{
 		//TODO: Calculate limit dynamically
 		if (total_sending >= max)
 			break;
 
 		PrioritySortedBlockTransfer q = queue[i];
 
-		MapBlock *block = NULL;
-		try{
+		MapBlock* block = NULL;
+		try
+		{
 			block = m_env.getMap().getBlockNoCreate(q.pos);
-		}catch (InvalidPositionException &e) {
+		}
+		catch (InvalidPositionException &e)
+		{
 			continue;
 		}
 
-		RemoteClient *client = getClient(q.peer_id);
+		RemoteClient* const client = getClient(q.peer_id);
 
 		SendBlockNoLock(q.peer_id, block, client->serialization_version);
 
+		if(block)
+		    block->ResetCurrent();
+
 		client->SentBlock(q.pos);
 
 		total_sending++;
 	}
 }
@@ -5950,11 +6056,11 @@
 			name = narrow_to_wide(player->getName());
 		// Add name to information string
 		os<<name<<L",";
 	}
 	os<<L"}";
-	char* motd = config_get("world.game.motd");
+	const char* motd = config_get("world.game.motd");
 	if (motd && motd[0])
 		os<<std::endl<<L"# Server: "<<narrow_to_wide(motd);
 	return os.str();
 }
 
@@ -6048,13 +6154,11 @@
 	/*
 		Create a new player
 	*/
 	{
 		uint64_t privs = 0;
-		char* priv;
-
-		priv = config_get("world.server.client.default.privs");
+		const char* priv = config_get("world.server.client.default.privs");
 
 		if (priv && priv[0])
 			privs = auth_str2privs(priv);
 
 		player = new ServerRemotePlayer();
@@ -6238,17 +6342,16 @@
 	auth_save();
 }
 
 uint64_t Server::getPlayerPrivs(Player *player)
 {
-	const char* playername;
-	char* admin_name;
+
 	if (!player)
 		return 0;
 
-	playername = player->getName();
-	admin_name = config_get("world.server.admin");
+	const char* playername = player->getName();
+	const char* admin_name = config_get("world.server.admin");
 
 	if (admin_name && !strcmp(admin_name,playername))
 		return PRIV_ALL;
 
 	return getPlayerAuthPrivs(playername);
diff -rU5 voxelands-v1709.00old/src/server.h voxelands-v1709.00good/src/server.h
--- voxelands-v1709.00old/src/server.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/server.h	2024-09-22 18:41:01.714655808 +0200
@@ -57,11 +57,11 @@
 	This is a thread-safe class.
 */
 class BlockEmergeQueue
 {
 public:
-	BlockEmergeQueue()
+	BlockEmergeQueue() : m_queue(),m_mutex()
 	{
 		m_mutex.Init();
 	}
 
 	~BlockEmergeQueue()
diff -rU5 voxelands-v1709.00old/src/servermain.cpp voxelands-v1709.00good/src/servermain.cpp
--- voxelands-v1709.00old/src/servermain.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/servermain.cpp	2024-09-22 18:41:01.714655808 +0200
@@ -47,11 +47,11 @@
 #endif
 
 #include <iostream>
 #include <fstream>
 #include <time.h>
-#include <jmutexautolock.h>
+#include "jmutexautolock.h"
 #include <locale.h>
 #include "common_irrlicht.h"
 #include "debug.h"
 #include "map.h"
 #include "player.h"
@@ -135,14 +135,13 @@
 int main(int argc, char *argv[])
 {
 	/*
 		Initialization
 	*/
-
+	log_mutex.Init();
 	log_add_output_maxlev(&main_stderr_log_out, LMT_ACTION);
 	log_add_output_all_levs(&main_dstream_no_stderr_log_out);
-
 	log_register_thread("main");
 
 	// Set locale. This is for forcing '.' as the decimal point.
 	std::locale::global(std::locale("C"));
 	// This enables printing all characters in bitmap font
diff -rU5 voxelands-v1709.00old/src/sound.c voxelands-v1709.00good/src/sound.c
--- voxelands-v1709.00old/src/sound.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/sound.c	2024-09-22 18:41:01.715655809 +0200
@@ -466,11 +466,11 @@
 	free(e->token);
 	free(e);
 }
 
 /* play sound effect */
-uint32_t sound_play_effect(char* token, float volume, uint8_t loop, v3_t *pos)
+uint32_t sound_play_effect(const char* token, float volume, uint8_t loop, v3_t *pos)
 {
 	sound_instance_t *i;
 	sound_t *e = sound_data.effects.sounds;
 	if (!sound_data.init || !e)
 		return 0;
@@ -522,11 +522,11 @@
 
 	return i->id;
 }
 
 /* play music */
-uint32_t sound_play_music(char* token, float volume, uint8_t loop)
+uint32_t sound_play_music(const char* token, float volume, uint8_t loop)
 {
 	sound_t *e = sound_data.music.sounds;
 	if (!sound_data.init || !e)
 		return 0;
 
@@ -635,33 +635,33 @@
 	sound_stop_music(fade);
 	sound_stop_effects(fade);
 }
 
 /* command setter for sound effects volume */
-int sound_effects_setter(char* value)
+int sound_effects_setter(const char* value)
 {
 	float vf;
 	int v = strtol(value,NULL,10);
 	vf = (float)v/100.0;
 	sound_volume_effects(vf);
 
 	return 0;
 }
 
 /* command setter for music volume */
-int sound_music_setter(char* value)
+int sound_music_setter(const char* value)
 {
 	float vf;
 	int v = strtol(value,NULL,10);
 	vf = (float)v/100.0;
 	sound_volume_music(vf);
 
 	return 0;
 }
 
 /* command setter for master volume */
-int sound_master_setter(char* value)
+int sound_master_setter(const char* value)
 {
 	int v = strtol(value,NULL,10);
 	if (v < 0)
 		v = 0;
 	if (v > 100)
diff -rU5 voxelands-v1709.00old/src/sound.h voxelands-v1709.00good/src/sound.h
--- voxelands-v1709.00old/src/sound.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/sound.h	2024-09-22 18:41:01.715655809 +0200
@@ -38,20 +38,20 @@
 void sound_step(float dtime, v3_t *pos, v3_t *at, v3_t *up);
 int sound_load_effect(char* file, char* token);
 int sound_load_music(char* file, char* token);
 void sound_free_effect(char* token);
 void sound_free_music(char* token);
-uint32_t sound_play_effect(char* token, float volume, uint8_t loop, v3_t *pos);
-uint32_t sound_play_music(char* token, float volume, uint8_t loop);
+uint32_t sound_play_effect(const char* token, float volume, uint8_t loop, v3_t *pos);
+uint32_t sound_play_music(const char* token, float volume, uint8_t loop);
 void sound_stop_effects(int fade);
 void sound_stop_music(int fade);
 void sound_stop_single(uint32_t id);
 int sound_exists(uint32_t id);
 void sound_stop(int fade);
-int sound_master_setter(char* value);
-int sound_effects_setter(char* value);
-int sound_music_setter(char* value);
+int sound_master_setter(const char* value);
+int sound_effects_setter(const char* value);
+int sound_music_setter(const char* value);
 
 #ifdef _VL_SOUND_EXPOSE_INTERNAL
 /* defined in sound.c */
 void sound_process(float dtime);
 float sound_volume_master(float v);
diff -rU5 voxelands-v1709.00old/src/string.c voxelands-v1709.00good/src/string.c
--- voxelands-v1709.00old/src/string.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/string.c	2024-09-22 18:41:01.715655809 +0200
@@ -81,11 +81,11 @@
 
 	return l;
 }
 
 /* makes a string safe for use as a file or directory name */
-int str_sanitise(char* dest, int size, char* str)
+int str_sanitise(char* dest, int size,const char* str)
 {
 	int o = 0;
 	int i = 0;
 	int lws = 0;
 
@@ -105,11 +105,11 @@
 
 	return -1;
 }
 
 /* parse a string into a bool true/false 1/0 */
-int parse_bool(char* str)
+int parse_bool(const char* str)
 {
 	if (str) {
 		if (!strcmp(str,"true"))
 			return 1;
 		if (!strcmp(str,"yes"))
@@ -126,22 +126,22 @@
 
 	return 0;
 }
 
 /* parse a string to a v3_t */
-int str_tov3t(char* str, v3_t *v)
+int str_tov3t(const char* str, v3_t *v)
 {
-	char buff[256];
+	char buff[257];
 	char* b;
 	char* s1;
 	char* s2;
 	char *e;
 
 	if (!str)
 		return 1;
 
-	strncpy(buff,str,256);
+	strncpy(buff,str,256);buff[256] = '\0';
 
 	b = strchr(buff,'(');
 	if (!b)
 		return 1;
 	b++;
diff -rU5 voxelands-v1709.00old/src/tile.cpp voxelands-v1709.00good/src/tile.cpp
--- voxelands-v1709.00old/src/tile.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/tile.cpp	2024-09-22 18:41:01.715655809 +0200
@@ -549,11 +549,11 @@
 				driver->createImage(video::ECF_A8R8G8B8, dim);
 		img->copyTo(img2);
 		img->drop();*/
 
 		// Generate image by name
-		video::IImage *img2 = generate_image_from_scratch(name, m_device);
+		video::IImage* const img2 = generate_image_from_scratch(name, m_device);
 		if(img2 == NULL)
 		{
 			infostream<<"TextureSource::buildMainAtlas(): Couldn't generate texture atlas: Couldn't generate image \""<<name<<"\""<<std::endl;
 			continue;
 		}
@@ -1157,11 +1157,10 @@
 
 				float dst[4] = {0.,0.,1.,1.};
 				float src[4] = {0.,(s*progression),1.,(s*progression)+s};
 
 				alpha_blit(device,baseimg,img_crack,dst,src,part_of_name);
-
 				img_crack->drop();
 			}
 		}
 		/*
 			[combine:WxH:X,Y=filename:X,Y=filename2
@@ -1184,17 +1183,17 @@
 				infostream<<"Adding \""<<filename
 						<<"\" to combined ("<<x<<","<<y<<")"
 						<<std::endl;
 
 				if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
-					video::IImage *img = driver->createImageFromFile(buff);
+					video::IImage* const img = driver->createImageFromFile(buff);
 					if (img) {
 						core::dimension2d<u32> dim = img->getDimension();
 						infostream<<"Size "<<dim.Width
 								<<"x"<<dim.Height<<std::endl;
 						core::position2d<s32> pos_base(x, y);
-						video::IImage *img2 =
+						video::IImage* const img2 =
 								driver->createImage(video::ECF_A8R8G8B8, dim);
 						img->copyTo(img2);
 						img->drop();
 						img2->copyToWithAlpha(baseimg, pos_base,
 								core::rect<s32>(v2s32(0,0), dim),
@@ -1246,11 +1245,11 @@
 			if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
 
 				infostream<<"generate_image(): Loading path \""<<buff
 						<<"\""<<std::endl;
 
-				video::IImage *image = driver->createImageFromFile(buff);
+				video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (image == NULL) {
 					infostream<<"generate_image(): Loading path \""
 							<<buff<<"\" failed"<<std::endl;
 				}else{
@@ -1265,11 +1264,10 @@
 						c.setAlpha(255);
 						image->setPixel(x,y,c);
 					}
 					// Blit
 					image->copyTo(baseimg);
-
 					image->drop();
 				}
 			}
 		}
 		/*
@@ -1294,22 +1292,21 @@
 
 			if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
 
 				infostream<<"generate_image(): Loading path \""<<buff<<"\""<<std::endl;
 
-				video::IImage *image = driver->createImageFromFile(buff);
+				video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (image == NULL) {
 					infostream<<"generate_image(): Loading path \""
 							<<buff<<"\" failed"<<std::endl;
 				}else{
 					core::dimension2d<u32> dim = image->getDimension();
 					baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 					// Blit
 					image->copyTo(baseimg);
-
 					image->drop();
 
 					for(u32 y=0; y<dim.Height; y++)
 					for(u32 x=0; x<dim.Width; x++)
 					{
@@ -1350,22 +1347,21 @@
 
 			if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
 
 				infostream<<"generate_image(): Loading path \""<<buff<<"\""<<std::endl;
 
-				video::IImage *image = driver->createImageFromFile(buff);
+				video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (image == NULL) {
 					infostream<<"generate_image(): Loading path \""
 							<<buff<<"\" failed"<<std::endl;
 				}else{
 					core::dimension2d<u32> dim = image->getDimension();
 					baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 					// Blit
 					image->copyTo(baseimg);
-
 					image->drop();
 
 					for(u32 y=0; y<dim.Height; y++)
 					for(u32 x=0; x<dim.Width; x++)
 					{
@@ -1413,11 +1409,11 @@
 			}
 
 			u32 transform = parseImageTransform(part_of_name.substr(10));
 			core::dimension2d<u32> dim = imageTransformDimension(
 					transform, baseimg->getDimension());
-			video::IImage *image = driver->createImage(
+			video::IImage* const image = driver->createImage(
 					baseimg->getColorFormat(), dim);
 			assert(image);
 			imageTransform(transform, baseimg, image);
 			baseimg->drop();
 			baseimg = image;
@@ -1522,11 +1518,11 @@
 						imagename_top, device);
 				return true;
 			}
 
 			// Create image of render target
-			video::IImage *image = driver->createImage(rtt, v2s32(0,0), dim);
+			video::IImage* const image = driver->createImage(rtt, v2s32(0,0), dim);
 			assert(image);
 
 			baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 			if(image)
@@ -1642,11 +1638,11 @@
 						imagename_top, device);
 				return true;
 			}
 
 			// Create image of render target
-			video::IImage *image = driver->createImage(rtt, v2s32(0,0), dim);
+			video::IImage* const image = driver->createImage(rtt, v2s32(0,0), dim);
 			assert(image);
 
 			baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 			if(image)
@@ -1675,11 +1671,11 @@
 			video::SColor color;
 			if (!parseColorString(color_str, color, false))
 				return false;
 
 			core::dimension2d<u32> dim = baseimg->getDimension();
-			video::IImage *img = driver->createImage(video::ECF_A8R8G8B8, dim);
+			video::IImage* const img = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 			if (!img) {
 				errorstream << "generateImagePart(): Could not create image "
 						<< "for part_of_name=\"" << part_of_name
 						<< "\", cancelling." << std::endl;
@@ -1711,11 +1707,11 @@
 			}
 
 			v2u32 frame_size = baseimg->getDimension();
 			frame_size.Y /= frame_count;
 
-			video::IImage *img = driver->createImage(video::ECF_A8R8G8B8,
+			video::IImage* const img = driver->createImage(video::ECF_A8R8G8B8,
 					frame_size);
 			if (!img) {
 				errorstream <<"generate_image(): Could not create image "
 						<< "for part_of_name=\"" << part_of_name
 						<< "\", cancelling." << std::endl;
@@ -1846,14 +1842,15 @@
 			driver->setRenderTarget(0, false, true, 0);
 
 			skin->setFont(std_font);
 
 			// Create image of render target
-			video::IImage *image = driver->createImage(rtt, v2s32(0,0), rtt_dim);
+			video::IImage* const image = driver->createImage(rtt, v2s32(0,0), rtt_dim);
 			assert(image);
 
-			video::IImage *new_baseimg = driver->createImage(video::ECF_A8R8G8B8, rtt_dim);
+			video::IImage* const new_baseimg =
+			    driver->createImage(video::ECF_A8R8G8B8, rtt_dim);
 			if (new_baseimg) {
 				baseimg->copyToScaling(new_baseimg);
 				baseimg->drop();
 				baseimg = new_baseimg;
 			}
@@ -1876,11 +1873,11 @@
 			float y = mystof(sf.next(","));
 			float X = mystof(sf.next(","));
 			float Y = mystof(sf.next(","));
 			std::string path = sf.end();
 			if (path_get((char*)"texture",const_cast<char*>(path.c_str()),1,buff,1024)) {
-				video::IImage *image = driver->createImageFromFile(buff);
+			    video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (baseimg == NULL) {
 					errorstream << "generateImagePart(): baseimg == NULL "
 							<< "for part_of_name=\"" << part_of_name
 							<< "\", cancelling." << std::endl;
diff -rU5 voxelands-v1709.00old/src/utility.cpp voxelands-v1709.00good/src/utility.cpp
--- voxelands-v1709.00old/src/utility.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/utility.cpp	2024-09-22 18:58:31.625345819 +0200
@@ -143,11 +143,11 @@
 	v3s16( 1,-1,-1), // bottom front-right
 	// 26
 	v3s16(0,0,0),
 };
 
-static unsigned long next = 1;
+static __thread unsigned long next = 1;
 
 /* RAND_MAX assumed to be 32767 */
 int myrand(void)
 {
 	next = next * 1103515245 + 12345;
diff -rU5 voxelands-v1709.00old/src/utility.h voxelands-v1709.00good/src/utility.h
--- voxelands-v1709.00old/src/utility.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/utility.h	2024-09-23 20:34:09.812338834 +0200
@@ -40,10 +40,11 @@
 #include "common_irrlicht.h"
 #include "debug.h"
 #include "strfnd.h"
 #include "exceptions.h"
 #include "porting.h"
+#include "xsync.h"
 
 using namespace jthread;
 
 extern const v3s16 g_6dirs[6];
 
@@ -306,23 +307,23 @@
 */
 
 template <typename T>
 class SharedPtr
 {
-public:
+    public:
 	SharedPtr(T *t=NULL)
 	{
 		refcount = new int;
 		*refcount = 1;
 		ptr = t;
 	}
 	SharedPtr(SharedPtr<T> &t)
 	{
 		//*this = t;
-		drop();
+		//drop();
 		refcount = t.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 		ptr = t.ptr;
 	}
 	~SharedPtr()
 	{
 		drop();
@@ -335,13 +336,15 @@
 		ptr = t;
 		return *this;
 	}
 	SharedPtr<T> & operator=(SharedPtr<T> &t)
 	{
+		if(this == &t)
+		    return *this;
 		drop();
 		refcount = t.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 		ptr = t.ptr;
 		return *this;
 	}
 	T* operator->()
 	{
@@ -361,30 +364,31 @@
 	}
 	T & operator[](unsigned int i)
 	{
 		return ptr[i];
 	}
-private:
+    private:
 	void drop()
 	{
-		assert((*refcount) > 0);
-		(*refcount)--;
-		if(*refcount == 0)
+		assert(refcount && X1SyncGet(refcount) > 0);
+		
+		if (X1SyncDec(refcount) == 1)
 		{
-			delete refcount;
-			if(ptr != NULL)
-				delete ptr;
+		    delete refcount;refcount = NULL;
+		    if(ptr != NULL)
+			delete ptr;
+		    ptr = NULL;
 		}
 	}
 	T *ptr;
-	int *refcount;
+	volatile int *refcount;
 };
 
 template <typename T>
 class Buffer
 {
-public:
+    public:
 	Buffer()
 	{
 		m_size = 0;
 		data = NULL;
 	}
@@ -447,97 +451,98 @@
 	}
 	unsigned int getSize() const
 	{
 		return m_size;
 	}
-private:
+    private:
 	void drop()
 	{
 		if(data)
 			delete[] data;
+		data = NULL;m_size = 0;
 	}
 	T *data;
 	unsigned int m_size;
 };
 
 template <typename T>
 class SharedBuffer
 {
-public:
-	SharedBuffer()
-	{
-		m_size = 0;
-		data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
-	}
-	SharedBuffer(unsigned int size)
-	{
-		m_size = size;
-		if(m_size != 0)
-			data = new T[m_size];
-		else
-			data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
-	}
-	SharedBuffer(const SharedBuffer &buffer)
+    public:
+	SharedBuffer() :
+			data(NULL),m_size(0),refcount(0)
+	{
+		refcount = new int;*refcount = 1;
+	}
+	SharedBuffer(unsigned int size) :
+			data(NULL),m_size(size),refcount(0)
+	{
+		if(m_size)
+		    data = new T[m_size];
+		refcount = new int;*refcount = 1;
+	}
+	SharedBuffer(const SharedBuffer& buffer) :
+			data(buffer.data),m_size(buffer.m_size),
+			refcount(buffer.refcount)
 	{
 		//std::cout<<"SharedBuffer(const SharedBuffer &buffer)"<<std::endl;
-		m_size = buffer.m_size;
-		data = buffer.data;
-		refcount = buffer.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 	}
-	SharedBuffer & operator=(const SharedBuffer & buffer)
+	
+	SharedBuffer& operator=(const SharedBuffer& buffer)
 	{
 		//std::cout<<"SharedBuffer & operator=(const SharedBuffer & buffer)"<<std::endl;
 		if(this == &buffer)
-			return *this;
+		    return *this;
+		
 		drop();
-		m_size = buffer.m_size;
 		data = buffer.data;
+		m_size = buffer.m_size;
 		refcount = buffer.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 		return *this;
 	}
 	/*
 		Copies whole buffer
 	*/
-	SharedBuffer(T *t, unsigned int size)
+	SharedBuffer(T* const t,const unsigned int size)
 	{
-		m_size = size;
-		if(m_size != 0)
+		
+		if(size)
 		{
-			data = new T[m_size];
-			memcpy(data, t, m_size);
+		    data = new T[size];
+		    memcpy(data,t,size);
 		}
 		else
-			data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
+		    data = NULL;
+		
+		m_size = size;
+		refcount = new int;
+		*refcount = 1;
 	}
 	/*
 		Copies whole buffer
 	*/
 	SharedBuffer(const Buffer<T> &buffer)
 	{
 		m_size = buffer.getSize();
-		if(m_size != 0)
+		if(m_size)
 		{
-			data = new T[m_size];
-			memcpy(data, *buffer, buffer.getSize());
+		    data = new T[m_size];
+		    memcpy(data, *buffer, buffer.getSize());
 		}
 		else
-			data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
+		    data = NULL;
+
+		refcount = new int;
+		*refcount = 1;
 	}
 	~SharedBuffer()
 	{
 		drop();
 	}
+	
 	T & operator[](unsigned int i) const
 	{
 		//assert(i < m_size)
 		return data[i];
 	}
@@ -551,25 +556,27 @@
 	}
 	operator Buffer<T>() const
 	{
 		return Buffer<T>(data, m_size);
 	}
-private:
+    private:
 	void drop()
 	{
-		assert((*refcount) > 0);
-		(*refcount)--;
-		if(*refcount == 0)
+		assert(refcount && X1SyncGet(refcount) > 0);
+
+		if (X1SyncDec(refcount) == 1)
 		{
-			if(data)
-				delete[] data;
-			delete refcount;
+		    delete refcount;refcount = NULL;
+		    if(data)
+			delete[] data;
+		    data = NULL;m_size = 0;
 		}
 	}
-	T *data;
+	
+	T* data;
 	unsigned int m_size;
-	unsigned int *refcount;
+	volatile int* refcount;
 };
 
 inline SharedBuffer<u8> SharedBufferFromString(const char *string)
 {
 	SharedBuffer<u8> b((u8*)string, strlen(string)+1);
@@ -579,11 +586,11 @@
 template<typename T>
 class MutexedVariable
 {
 public:
 	MutexedVariable(T value):
-		m_value(value)
+			m_value(value),m_mutex()
 	{
 		m_mutex.Init();
 	}
 
 	T get()
@@ -615,11 +622,11 @@
 	TimeTaker
 */
 
 class TimeTaker
 {
-public:
+    public:
 	TimeTaker(const char *name, u32 *result=NULL);
 
 	~TimeTaker()
 	{
 		stop();
@@ -627,11 +634,11 @@
 
 	u32 stop(bool quiet=false);
 
 	u32 getTime();
 
-private:
+    private:
 	const char *m_name;
 	u32 m_time1;
 	bool m_running;
 	u32 *m_result;
 };
@@ -723,21 +730,21 @@
 	}
 }
 
 class IndentationRaiser
 {
-public:
+    public:
 	IndentationRaiser(u16 *indentation)
 	{
 		m_indentation = indentation;
 		(*m_indentation)++;
 	}
 	~IndentationRaiser()
 	{
 		(*m_indentation)--;
 	}
-private:
+    private:
 	u16 *m_indentation;
 };
 
 inline s16 getContainerPos(s16 p, s16 d)
 {
@@ -1042,12 +1049,12 @@
 */
 
 template<typename T>
 class MutexedQueue
 {
-public:
-	MutexedQueue()
+    public:
+	MutexedQueue() : m_mutex(),m_list()
 	{
 		m_mutex.Init();
 	}
 	u32 size()
 	{
@@ -1120,11 +1127,11 @@
 	core::list<T> & getList()
 	{
 		return m_list;
 	}
 
-protected:
+    protected:
 	JMutex m_mutex;
 	core::list<T> m_list;
 };
 
 /*
@@ -1132,19 +1139,19 @@
 */
 
 template<typename Caller, typename Data>
 class CallerInfo
 {
-public:
+    public:
 	Caller caller;
 	Data data;
 };
 
 template<typename Key, typename T, typename Caller, typename CallerData>
 class GetResult
 {
-public:
+    public:
 	Key key;
 	T item;
 	core::list<CallerInfo<Caller, CallerData> > callers;
 };
 
@@ -1154,11 +1161,11 @@
 };
 
 template<typename Key, typename T, typename Caller, typename CallerData>
 class GetRequest
 {
-public:
+    public:
 	GetRequest()
 	{
 		dest = NULL;
 	}
 	GetRequest(ResultQueue<Key,T, Caller, CallerData> *a_dest)
@@ -1181,11 +1188,11 @@
 };
 
 template<typename Key, typename T, typename Caller, typename CallerData>
 class RequestQueue
 {
-public:
+    public:
 	u32 size()
 	{
 		return m_queue.size();
 	}
 
@@ -1242,11 +1249,11 @@
 	GetRequest<Key, T, Caller, CallerData> pop(bool wait_if_empty=false)
 	{
 		return m_queue.pop_front(wait_if_empty);
 	}
 
-private:
+    private:
 	MutexedQueue< GetRequest<Key, T, Caller, CallerData> > m_queue;
 };
 
 /*
 	Pseudo-random (VC++ rand() sucks)
@@ -1269,11 +1276,11 @@
 */
 
 template<typename Value>
 class UniqueQueue
 {
-public:
+    public:
 
 	/*
 		Does nothing if value is already queued.
 		Return value:
 			true: value added
@@ -1305,20 +1312,20 @@
 	{
 		assert(m_list.size() == m_map.size());
 		return m_list.size();
 	}
 
-private:
+    private:
 	core::map<Value, u8> m_map;
 	core::list<Value> m_list;
 };
 
 #if 1
 template<typename Key, typename Value>
 class MutexedMap
 {
-public:
+    public:
 	MutexedMap()
 	{
 		m_mutex.Init();
 		assert(m_mutex.IsInitialized());
 	}
@@ -1344,11 +1351,11 @@
 			*result = n->getValue();
 
 		return true;
 	}
 
-private:
+    private:
 	core::map<Key, Value> m_values;
 	JMutex m_mutex;
 };
 #endif
 
@@ -1365,11 +1372,11 @@
 	- Remove an id/value pair (is possible to implement but slow)
 */
 template<typename T>
 class MutexedIdGenerator
 {
-public:
+    public:
 	MutexedIdGenerator()
 	{
 		m_mutex.Init();
 		assert(m_mutex.IsInitialized());
 	}
@@ -1399,11 +1406,11 @@
 		u32 new_id = m_id_to_value.size();
 		m_value_to_id.insert(value, new_id);
 		return new_id;
 	}
 
-private:
+    private:
 	JMutex m_mutex;
 	// Values are stored here at id-1 position (id 1 = [0])
 	core::array<T> m_id_to_value;
 	core::map<T, u32> m_value_to_id;
 };
@@ -1667,11 +1674,11 @@
 	);
 }
 
 class IntervalLimiter
 {
-public:
+    public:
 	IntervalLimiter():
 		m_accumulator(0)
 	{
 	}
 	/*
@@ -1687,11 +1694,11 @@
 		if(m_accumulator < wanted_interval)
 			return false;
 		m_accumulator -= wanted_interval;
 		return true;
 	}
-protected:
+    protected:
 	float m_accumulator;
 };
 
 /*
 	Splits a list into "pages". For example, the list [1,2,3,4,5] split
diff -rU5 voxelands-v1709.00old/src/voxel.cpp voxelands-v1709.00good/src/voxel.cpp
--- voxelands-v1709.00old/src/voxel.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/voxel.cpp	2024-09-22 18:41:01.716655811 +0200
@@ -27,55 +27,48 @@
 #include "map.h"
 #include "utility.h" // For TimeTaker
 #include "gettime.h"
 #include "content_mapnode.h"
 #include "environment.h"
+#include "log.h"
 
 /*
 	Debug stuff
 */
 u32 addarea_time = 0;
 u32 emerge_time = 0;
 u32 emerge_load_time = 0;
 u32 clearflag_time = 0;
-//u32 getwaterpressure_time = 0;
-//u32 spreadwaterpressure_time = 0;
 u32 updateareawaterpressure_time = 0;
 u32 flowwater_pre_time = 0;
 
 
-VoxelManipulator::VoxelManipulator():
-	m_data(NULL),
-	m_flags(NULL),
-	m_env(NULL)
+VoxelManipulator::VoxelManipulator() : m_area(),m_data(NULL),
+				       m_flags(NULL),m_env(NULL)
 {
 }
 
 VoxelManipulator::~VoxelManipulator()
 {
 	clear();
-	if(m_data)
-		delete[] m_data;
-	if(m_flags)
-		delete[] m_flags;
 }
 
 MapNode VoxelManipulator::getNodeRO(v3s16 p)
 {
 #ifdef SERVER
 	return getNodeNoEx(p);
 #else
-	if (
-		m_area.contains(p) == false
-		|| (m_flags[m_area.index(p)] & VOXELFLAG_INEXISTENT)
-		|| (m_flags[m_area.index(p)] & VOXELFLAG_NOT_LOADED)
-		|| m_data[m_area.index(p)].getContent() == CONTENT_IGNORE
-	) {
+	if (m_area.contains(p) == false
+			|| (m_flags[m_area.index(p)] & VOXELFLAG_INEXISTENT)
+			|| (m_flags[m_area.index(p)] & VOXELFLAG_NOT_LOADED)
+			|| m_data[m_area.index(p)].getContent() == CONTENT_IGNORE)
+	{
 		if (m_env)
 			return m_env->getMap().getNodeNoEx(p);
 		return MapNode(CONTENT_IGNORE);
 	}
+	
 	return m_data[m_area.index(p)];
 #endif
 }
 
 void VoxelManipulator::clear()
@@ -118,12 +111,13 @@
 				else if(f & VOXELFLAG_INEXISTENT)
 					c = 'I';
 				else
 				{
 					c = 'X';
-					content_t m = m_data[m_area.index(x,y,z)].getContent();
-					u8 pr = m_data[m_area.index(x,y,z)].param2;
+					const content_t m = m_data[m_area.index(x,y,z)].getContent();
+					const u8 pr = m_data[m_area.index(x,y,z)].param2;
+					
 					if(mode == VOXELPRINT_MATERIAL)
 					{
 						if(m <= 9)
 							c = m + '0';
 					}
@@ -151,11 +145,11 @@
 		}
 		o<<std::endl;
 	}
 }
 
-void VoxelManipulator::addArea(VoxelArea area)
+void VoxelManipulator::addArea(const VoxelArea area)
 {
 	// Cancel if requested area has zero volume
 	if(area.getExtent() == v3s16(0,0,0))
 		return;
 
@@ -177,11 +171,11 @@
 	{
 		new_area = m_area;
 		new_area.addArea(area);
 	}
 
-	s32 new_size = new_area.getVolume();
+	const s32 new_size = new_area.getVolume();
 
 	/*dstream<<"adding area ";
 	area.print(dstream);
 	dstream<<", old area ";
 	m_area.print(dstream);
@@ -189,37 +183,42 @@
 	new_area.print(dstream);
 	dstream<<", new_size="<<new_size;
 	dstream<<std::endl;*/
 
 	// Allocate and clear new data
-	MapNode *new_data = new MapNode[new_size];
+	MapNode* const new_data = new MapNode[new_size];
+	
 	assert(new_data);
-	u8 *new_flags = new u8[new_size];
+	
+	u8* const new_flags = new u8[new_size];
+	
 	assert(new_flags);
 	memset(new_flags, VOXELFLAG_INEXISTENT, new_size);
 
 	// Copy old data
 
 	for(s32 z=m_area.MinEdge.Z; z<=m_area.MaxEdge.Z; z++)
 	for(s32 y=m_area.MinEdge.Y; y<=m_area.MaxEdge.Y; y++)
 	for(s32 x=m_area.MinEdge.X; x<=m_area.MaxEdge.X; x++)
 	{
-		unsigned int old_index = m_area.index(x,y,z);
+		const unsigned int old_index = m_area.index(x,y,z);
+		
 		// If loaded, copy data and flags
 		if((m_flags[old_index] & VOXELFLAG_NOT_LOADED) == false) {
-			unsigned int new_index = new_area.index(x,y,z);
+			const unsigned int new_index = new_area.index(x,y,z);
+			
 			new_data[new_index] = m_data[old_index];
 			new_flags[new_index] = m_flags[old_index];
 		}
 	}
 
 	// Replace area, data and flags
 
 	m_area = new_area;
 
-	MapNode *old_data = m_data;
-	u8 *old_flags = m_flags;
+	MapNode* const old_data = m_data;
+	u8* const old_flags = m_flags;
 
 	/*dstream<<"old_data="<<(int)old_data<<", new_data="<<(int)new_data
 	<<", old_flags="<<(int)m_flags<<", new_flags="<<(int)new_flags<<std::endl;*/
 
 	m_data = new_data;
@@ -231,32 +230,40 @@
 		delete[] old_flags;
 
 	//dstream<<"addArea done"<<std::endl;
 }
 
-void VoxelManipulator::copyFrom(MapNode *src, VoxelArea src_area,
-		v3s16 from_pos, v3s16 to_pos, v3s16 size)
+// OK valeurs seulement, pas de pointeurs.
+
+void VoxelManipulator::copyFrom(const MapNode* const src,const VoxelArea src_area,
+		const v3s16 from_pos,const v3s16 to_pos,const v3s16 size)
 {
 	for(s16 z=0; z<size.Z; z++)
 	for(s16 y=0; y<size.Y; y++)
 	{
-		s32 i_src = src_area.index(from_pos.X, from_pos.Y+y, from_pos.Z+z);
-		s32 i_local = m_area.index(to_pos.X, to_pos.Y+y, to_pos.Z+z);
-		memcpy(&m_data[i_local], &src[i_src], size.X*sizeof(MapNode));
+		const s32 i_src = src_area.index(from_pos.X, from_pos.Y+y, from_pos.Z+z);
+		const s32 i_local = m_area.index(to_pos.X, to_pos.Y+y, to_pos.Z+z);
+
+		assert(i_src < MAP_BLOCKSIZE3);
+		assert(i_local < m_area.getVolume());
+		memcpy(&m_data[i_local], &src[i_src], size.X * sizeof(MapNode));
 		memset(&m_flags[i_local], 0, size.X);
 	}
 }
 
-void VoxelManipulator::copyTo(MapNode *dst, VoxelArea dst_area,
-		v3s16 dst_pos, v3s16 from_pos, v3s16 size)
+void VoxelManipulator::copyTo(MapNode* const dst,const VoxelArea dst_area,
+		const v3s16 dst_pos,const v3s16 from_pos,const v3s16 size)
 {
 	for(s16 z=0; z<size.Z; z++)
 	for(s16 y=0; y<size.Y; y++)
 	{
-		s32 i_dst = dst_area.index(dst_pos.X, dst_pos.Y+y, dst_pos.Z+z);
-		s32 i_local = m_area.index(from_pos.X, from_pos.Y+y, from_pos.Z+z);
-		memcpy(&dst[i_dst], &m_data[i_local], size.X*sizeof(MapNode));
+		const s32 i_dst = dst_area.index(dst_pos.X, dst_pos.Y+y, dst_pos.Z+z);
+		const s32 i_local = m_area.index(from_pos.X, from_pos.Y+y, from_pos.Z+z);
+
+	    	assert(i_dst < MAP_BLOCKSIZE3);
+		assert(i_local < m_area.getVolume());
+		memcpy(&dst[i_dst], &m_data[i_local], size.X * sizeof(MapNode));
 	}
 }
 
 /*
 	Algorithms
@@ -282,15 +289,14 @@
 		m_flags[m_area.index(x,y,z)] &= ~flags;
 		if(m_flags[m_area.index(x,y,z)] != f)
 			count++;
 	}*/
 
-	s32 volume = m_area.getVolume();
+	const s32 volume = m_area.getVolume();
+	
 	for(s32 i=0; i<volume; i++)
-	{
 		m_flags[i] &= ~flags;
-	}
 
 	/*s32 volume = m_area.getVolume();
 	for(s32 i=0; i<volume; i++)
 	{
 		u8 f = m_flags[i];
@@ -316,27 +322,28 @@
 	};
 
 	emerge(VoxelArea(p - v3s16(1,1,1), p + v3s16(1,1,1)));
 
 	// Loop through 6 neighbors
-	for (u16 i=0; i<6; i++) {
+	for (u16 i=0; i<6; i++)
+	{
 		// Get the position of the neighbor node
-		v3s16 n2pos = p + dirs[i];
-
-		u32 n2i = m_area.index(n2pos);
+		const v3s16 n2pos = p + dirs[i];
+		const u32 n2i = m_area.index(n2pos);
 
 		if (m_flags[n2i] & VOXELFLAG_INEXISTENT)
 			continue;
 
-		MapNode &n2 = m_data[n2i];
+		MapNode& n2 = m_data[n2i];
 
 		/*
 			If the neighbor is dimmer than what was specified
 			as oldlight (the light of the previous node)
 		*/
-		u8 light2 = n2.getLight(bank);
-		if (light2 < oldlight) {
+		const u8 light2 = n2.getLight(bank);
+		if (light2 < oldlight)
+		{
 			/*
 				And the neighbor is transparent and it has some light
 			*/
 			if (content_features(n2).light_propagates && light2 != 0) {
 				/*
@@ -355,13 +362,13 @@
 				{
 					std::cout<<"Removed from light_sources"<<std::endl;
 					light_sources.remove(n2pos);
 				}*/
 			}
-		}else{
-			light_sources.insert(n2pos, true);
 		}
+		else
+			light_sources.insert(n2pos, true);
 	}
 }
 
 #if 1
 /*
@@ -386,20 +393,17 @@
 		core::map<v3s16, bool> & light_sources)
 {
 	if(from_nodes.size() == 0)
 		return;
 
-	core::map<v3s16, u8>::Iterator j;
-	j = from_nodes.getIterator();
+	core::map<v3s16, u8>::Iterator j = from_nodes.getIterator();
 
 	for(; j.atEnd() == false; j++)
 	{
-		v3s16 pos = j.getNode()->getKey();
-
+		const v3s16 pos = j.getNode()->getKey();
 		//MapNode &n = m_data[m_area.index(pos)];
-
-		u8 oldlight = j.getNode()->getValue();
+		const u8 oldlight = j.getNode()->getValue();
 
 		unspreadLight(bank, pos, oldlight, light_sources);
 	}
 }
 #endif
@@ -437,35 +441,33 @@
 
 	if(from_nodes.size() == 0)
 		return;
 
 	core::map<v3s16, u8> unlighted_nodes;
-	core::map<v3s16, u8>::Iterator j;
-	j = from_nodes.getIterator();
+	core::map<v3s16, u8>::Iterator j = from_nodes.getIterator();
 
 	for(; j.atEnd() == false; j++)
 	{
-		v3s16 pos = j.getNode()->getKey();
+		const v3s16 pos = j.getNode()->getKey();
 
 		emerge(VoxelArea(pos - v3s16(1,1,1), pos + v3s16(1,1,1)));
 
 		//MapNode &n = m_data[m_area.index(pos)];
 
-		u8 oldlight = j.getNode()->getValue();
+		const u8 oldlight = j.getNode()->getValue();
 
 		// Loop through 6 neighbors
 		for(u16 i=0; i<6; i++)
 		{
 			// Get the position of the neighbor node
-			v3s16 n2pos = pos + dirs[i];
-
-			u32 n2i = m_area.index(n2pos);
+			const v3s16 n2pos = pos + dirs[i];
+			const u32 n2i = m_area.index(n2pos);
 
 			if(m_flags[n2i] & VOXELFLAG_INEXISTENT)
 				continue;
 
-			MapNode &n2 = m_data[n2i];
+			MapNode& n2 = m_data[n2i];
 
 			/*
 				If the neighbor is dimmer than what was specified
 				as oldlight (the light of the previous node)
 			*/
@@ -477,14 +479,13 @@
 				if(n2.light_propagates() && n2.getLight(bank) != 0)
 				{
 					/*
 						Set light to 0 and add to queue
 					*/
-
-					u8 current_light = n2.getLight(bank);
+					const u8 current_light = n2.getLight(bank);
+					
 					n2.setLight(bank, 0);
-
 					unlighted_nodes.insert(n2pos, current_light);
 
 					/*
 						Remove from light_sources if it is there
 						NOTE: This doesn't happen nearly at all
@@ -494,13 +495,13 @@
 						std::cout<<"Removed from light_sources"<<std::endl;
 						light_sources.remove(n2pos);
 					}*/
 				}
 			}
-			else{
+			else
 				light_sources.insert(n2pos, true);
-			}
+
 		}
 	}
 
 	/*dstream<<"unspreadLight(): Changed block "
 			<<blockchangecount<<" times"
@@ -528,27 +529,26 @@
 	u32 i = m_area.index(p);
 
 	if (m_flags[i] & VOXELFLAG_INEXISTENT)
 		return;
 
-	MapNode &n = m_data[i];
-
-	u8 oldlight = n.getLight(bank);
-	u8 newlight = diminish_light(oldlight);
+	const MapNode& n = m_data[i];
+	const u8 oldlight = n.getLight(bank);
+	const u8 newlight = diminish_light(oldlight);
 
 	// Loop through 6 neighbors
-	for (u16 i=0; i<6; i++) {
+	for (u16 i=0; i<6; i++)
+	{
 		// Get the position of the neighbor node
-		v3s16 n2pos = p + dirs[i];
-
-		u32 n2i = m_area.index(n2pos);
+		const v3s16 n2pos = p + dirs[i];
+		const u32 n2i = m_area.index(n2pos);
 
 		if (m_flags[n2i] & VOXELFLAG_INEXISTENT)
 			continue;
 
-		MapNode &n2 = m_data[n2i];
-		u8 light2 = n2.getLight(bank);
+		MapNode& n2 = m_data[n2i];
+		const u8 light2 = n2.getLight(bank);
 
 		/*
 			If the neighbor is brighter than the current node,
 			add to list (it will light up this node on its turn)
 		*/
@@ -556,11 +556,12 @@
 			spreadLight(bank, n2pos);
 		/*
 			If the neighbor is dimmer than how much light this node
 			would spread on it, add to list
 		*/
-		if (light2 < newlight && content_features(n2).light_propagates) {
+		if (light2 < newlight && content_features(n2).light_propagates)
+		{
 			n2.setLight(bank, newlight);
 			spreadLight(bank, n2pos);
 		}
 	}
 }
@@ -578,14 +579,14 @@
 {
 	if (from_nodes.size() == 0)
 		return;
 
 	core::map<v3s16, bool> lighted_nodes;
-	core::map<v3s16, bool>::Iterator j;
-	j = from_nodes.getIterator();
+	core::map<v3s16, bool>::Iterator j = from_nodes.getIterator();
 
-	for (; j.atEnd() == false; j++) {
+	for (; j.atEnd() == false; j++)
+	{
 		v3s16 pos = j.getNode()->getKey();
 		spreadLight(bank, pos);
 	}
 }
 #endif
@@ -609,41 +610,41 @@
 
 	if (from_nodes.size() == 0)
 		return;
 
 	core::map<v3s16, bool> lighted_nodes;
-	core::map<v3s16, bool>::Iterator j;
-	j = from_nodes.getIterator();
+	core::map<v3s16, bool>::Iterator j = from_nodes.getIterator();
 
-	for (; j.atEnd() == false; j++) {
-		v3s16 pos = j.getNode()->getKey();
+	for (; j.atEnd() == false; j++)
+	{
+		const v3s16 pos = j.getNode()->getKey();
 
 		emerge(VoxelArea(pos - v3s16(1,1,1), pos + v3s16(1,1,1)));
 
-		u32 i = m_area.index(pos);
+		const u32 i = m_area.index(pos);
 
 		if (m_flags[i] & VOXELFLAG_INEXISTENT)
 			continue;
 
-		MapNode &n = m_data[i];
-
-		u8 oldlight = n.getLight(bank);
-		u8 newlight = diminish_light(oldlight);
+		const MapNode& n = m_data[i];
+		const u8 oldlight = n.getLight(bank);
+		const u8 newlight = diminish_light(oldlight);
 
 		// Loop through 6 neighbors
-		for (u16 i=0; i<6; i++) {
+		for (u16 i=0; i<6; i++)
+		{
 			// Get the position of the neighbor node
-			v3s16 n2pos = pos + dirs[i];
+			const v3s16 n2pos = pos + dirs[i];
 
 			try{
-				u32 n2i = m_area.index(n2pos);
+				const u32 n2i = m_area.index(n2pos);
 
 				if (m_flags[n2i] & VOXELFLAG_INEXISTENT)
 					continue;
 
-				MapNode &n2 = m_data[n2i];
-				u8 light2 = n2.getLight(bank);
+				MapNode& n2 = m_data[n2i];
+				const u8 light2 = n2.getLight(bank);
 
 				/*
 					If the neighbor is brighter than the current node,
 					add to list (it will light up this node on its turn)
 				*/
@@ -670,7 +671,5 @@
 
 	if (lighted_nodes.size() > 0)
 		spreadLight(bank, lighted_nodes);
 }
 #endif
-
-//END
diff -rU5 voxelands-v1709.00old/src/voxel.h voxelands-v1709.00good/src/voxel.h
--- voxelands-v1709.00old/src/voxel.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/voxel.h	2024-09-22 18:41:01.716655811 +0200
@@ -77,11 +77,11 @@
 
 	/*
 		Modifying methods
 	*/
 
-	void addArea(VoxelArea &a)
+	void addArea(const VoxelArea& a)
 	{
 		if(getExtent() == v3s16(0,0,0))
 		{
 			*this = a;
 			return;
@@ -341,11 +341,12 @@
 
 class Environment;
 
 class VoxelManipulator /*: public NodeContainer*/
 {
-public:
+    public:
+	
 	VoxelManipulator();
 	virtual ~VoxelManipulator();
 
 	/*
 		Virtuals from NodeContainer
@@ -391,11 +392,11 @@
 			return MapNode(CONTENT_IGNORE);
 		}
 
 		return m_data[m_area.index(p)];
 	}
-	MapNode getNodeNoExNoEmerge(v3s16 p)
+	MapNode getNodeNoExNoEmerge(v3s16 p) const
 	{
 		if(m_area.contains(p) == false)
 			return MapNode(CONTENT_IGNORE);
 		if(m_flags[m_area.index(p)] & VOXELFLAG_INEXISTENT)
 			return MapNode(CONTENT_IGNORE);
@@ -480,26 +481,30 @@
 
 	/*
 		Control
 	*/
 
+	void setEnv(Environment* const env) {
+		m_env = env;
+	}
+			
 	virtual void clear();
 
 	void print(std::ostream &o, VoxelPrintMode mode=VOXELPRINT_MATERIAL);
 
-	void addArea(VoxelArea area);
+	void addArea(const VoxelArea area);
 
 	/*
 		Copy data and set flags to 0
 		dst_area.getExtent() <= src_area.getExtent()
 	*/
-	void copyFrom(MapNode *src, VoxelArea src_area,
-			v3s16 from_pos, v3s16 to_pos, v3s16 size);
+	void copyFrom(const MapNode* const src,const VoxelArea src_area,
+			const v3s16 from_pos,const v3s16 to_pos,const v3s16 size);
 
 	// Copy data
-	void copyTo(MapNode *dst, VoxelArea dst_area,
-			v3s16 dst_pos, v3s16 from_pos, v3s16 size);
+	void copyTo(MapNode* const dst,const VoxelArea dst_area,
+			const v3s16 dst_pos,const v3s16 from_pos,const v3s16 size);
 
 	/*
 		Algorithms
 	*/
 
@@ -530,14 +535,15 @@
 	{
 		//dstream<<"emerge p=("<<p.X<<","<<p.Y<<","<<p.Z<<")"<<std::endl;
 		addArea(a);
 	}
 
-	/*
+    /********************************************
 		Member variables
-	*/
-
+    *********************************************/
+    public:
+	
 	/*
 		The area that is stored in m_data.
 		addInternalBox should not be used if getExtent() == v3s16(0,0,0)
 		MaxEdge is 1 higher than maximum allowed position
 	*/
@@ -550,12 +556,15 @@
 	MapNode *m_data;
 
 	/*
 		Flags of all nodes
 	*/
+
 	u8 *m_flags;
 
+    private:
+	
 	Environment *m_env;
 
 	//TODO: Use these or remove them
 	//TODO: Would these make any speed improvement?
 	//bool m_pressure_route_valid;
@@ -563,11 +572,9 @@
 
 	/*
 		Some settings
 	*/
 	//bool m_disable_water_climb;
-
-private:
 };
 
 #endif
 
diff -rU5 voxelands-v1709.00old/src/world.c voxelands-v1709.00good/src/world.c
--- voxelands-v1709.00old/src/world.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/world.c	2024-09-22 18:41:01.716655811 +0200
@@ -21,11 +21,11 @@
 #include "path.h"
 #include "list.h"
 
 #include <string.h>
 
-static int world_exists(char* name)
+static int world_exists(const char* name)
 {
 	char buff[2048];
 	char nbuff[256];
 
 	if (!name)
@@ -38,15 +38,15 @@
 		return 0;
 
 	return 1;
 }
 
-int world_create(char* name)
+int world_create(const char* name)
 {
 	char buff[2048];
 	char nbuff[256];
-	char nbuff1[256];
+	char nbuff1[512];
 	int i;
 
 	if (!name || !name[0])
 		name = "New World";
 
@@ -63,11 +63,11 @@
 
 		return path_create("world","players");
 	}
 
 	for (i=1; i<100; i++) {
-		snprintf(nbuff1,256,"%s_%d",nbuff,i);
+		snprintf(nbuff1,512,"%s_%d",nbuff,i);
 		if (!path_get("worlds",nbuff1,1,buff,2048)) {
 			if (!path_get("worlds",nbuff1,0,buff,2048))
 				return 1;
 
 			config_set("world.path",nbuff1);
@@ -80,16 +80,16 @@
 	}
 
 	return 1;
 }
 
-int world_load(char* name)
+int world_load(const char* name)
 {
 	char buff[2048];
 	char buff1[2048];
 	char nbuff[256];
-	char* v;
+	const char* v;
 
 	config_clear("world");
 
 	if (!name) {
 #ifdef SERVER
@@ -130,11 +130,11 @@
 {
 	char buff[2048];
 	char pbuff[2048];
 	char newp[256];
 	char id[256];
-	char* v;
+	const char* v;
 
 	if (!path_exists(path))
 		return 1;
 
 	if (snprintf(buff,2048,"%s",path) >= 2048)
@@ -142,16 +142,14 @@
 
 	v = strrchr(buff,'/');
 	if (!v)
 		return 1;
 
-	*v = 0;
-
 	config_set("world.path",buff);
 	config_load("world","world.cfg");
-
 	v = config_get("world.path");
+	
 	if (!v || !strcmp(v,buff) || !config_get("world.name")) {
 		config_clear("world");
 		return 1;
 	}
 
@@ -187,13 +185,13 @@
 	config_save("world","world","world.cfg");
 	config_clear("world");
 }
 
 /* initialise and/or create a world */
-int world_init(char* name)
+int world_init(const char* name)
 {
-	char *v;
+	const char *v;
 
 	if (!name) {
 #ifdef SERVER
 		name = config_get("server.world");
 #else
@@ -244,13 +242,13 @@
 {
 	dirlist_t *d;
 	dirlist_t *e;
 	worldlist_t *l = NULL;
 	worldlist_t *w;
-	char* n;
-	char* v;
-	char* m;
+	const char* n;
+	const char* v;
+	const char* m;
 
 	d = path_dirlist("worlds",NULL);
 
 	if (!d)
 		return NULL;
Seulement dans voxelands-v1709.00good/src: xsync.h
