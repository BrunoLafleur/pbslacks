diff -rU5 voxelands-v1709.00old/src/activeobject.h voxelands-v1709.00good/src/activeobject.h
--- voxelands-v1709.00old/src/activeobject.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/activeobject.h	2024-06-09 13:17:14.655157790 +0200
@@ -55,10 +55,12 @@
 	ActiveObject(u16 id):
 		m_id(id)
 	{
 	}
 
+	virtual ~ActiveObject() {};
+	
 	u16 getId()
 	{
 		return m_id;
 	}
 
diff -rU5 voxelands-v1709.00old/src/array.c voxelands-v1709.00good/src/array.c
--- voxelands-v1709.00old/src/array.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/array.c	2024-06-09 13:17:14.655157790 +0200
@@ -59,11 +59,11 @@
 array_t *array_copy(array_t *a)
 {
 	array_t *r = array_create(ARRAY_TYPE_STRING);
 
 	if (a) {
-		int i;
+		uint32_t i;
 		r->type = a->type;
 		switch (a->type) {
 		case ARRAY_TYPE_STRING:
 			for (i=0; i<a->length; i++) {
 				array_push_string(r,((char**)(a->data))[i]);
@@ -92,11 +92,11 @@
 }
 
 /* compare two arrays */
 int array_cmp(array_t *a1, array_t *a2)
 {
-	int i;
+	uint32_t i;
 	char** c1;
 	char** c2;
 	int *i1;
 	int *i2;
 	float *f1;
@@ -182,11 +182,11 @@
 }
 
 /* destroy an array */
 void array_free(array_t *a, int freestruct)
 {
-	int i;
+	uint32_t i;
 	if (!a)
 		return;
 	if (a->type == ARRAY_TYPE_STRING) {
 		char** p = a->data;
 		for (i=0; i<a->length; i++ ) {
@@ -366,10 +366,14 @@
 }
 
 * set the value of array index i to an int value */
 int array_set_int(array_t *a, uint32_t v, int i)
 {
+
+	if(i < 0)
+	    return 1;
+	
 	uint32_t *p = a->data;
 	if (a->type == ARRAY_TYPE_STRING) {
 		char sv[20];
 		sprintf(sv,"%u",v);
 		return array_set_string(a,sv,i);
@@ -377,11 +381,11 @@
 		return array_set_float(a,(float)v,i);
 	}else if (a->type != ARRAY_TYPE_INT) {
 		return 1;
 	}
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(uint32_t)*l);
 		if (!p)
@@ -391,21 +395,25 @@
 		}
 		a->data = p;
 		a->size = l;
 	}
 
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	p[i] = v;
 
 	return 0;
 }
 
 /* set the value of array index i to a float value */
 int array_set_float(array_t *a, float v, int i)
 {
+	
+	if(i < 0)
+	    return 1;
+	
 	float *p = a->data;
 	if (a->type == ARRAY_TYPE_STRING) {
 		char sv[20];
 		sprintf(sv,"%f",v);
 		return array_set_string(a,sv,i);
@@ -413,11 +421,11 @@
 		return array_set_float(a,(uint32_t)v,i);
 	}else if (a->type != ARRAY_TYPE_FLOAT) {
 		return 1;
 	}
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(float)*l);
 		if (!p)
@@ -426,26 +434,30 @@
 			p[k] = 0.0;
 		}
 		a->data = p;
 		a->size = l;
 	}
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	p[i] = v;
 
 	return 0;
 }
 
 /* set the value of array index i to a string value */
 int array_set_string(array_t *a, char* v, int i)
 {
+	
+	if(i < 0)
+	    return 1;
+	
 	char** p = a->data;
 	if (a->type != ARRAY_TYPE_STRING)
 		return 1;
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(char*)*l);
 		if (!p)
@@ -454,11 +466,11 @@
 			p[k] = NULL;
 		}
 		a->data = p;
 		a->size = l;
 	}
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	if (p[i])
 		free(p[i]);
 
@@ -472,15 +484,19 @@
 }
 
 /* set the value of array index i to a ponter value */
 int array_set_ptr(array_t *a, void* v, int i)
 {
+		
+	if(i < 0)
+	    return 1;
+
 	char** p = a->data;
 	if (a->type != ARRAY_TYPE_PTR)
 		return 1;
 
-	if (a->size <= i) {
+	if ((int) a->size <= i) {
 		int k;
 		int l = array_next_size(i+1);
 
 		p = realloc(a->data,sizeof(char*)*l);
 		if (!p)
@@ -489,22 +505,22 @@
 			p[k] = NULL;
 		}
 		a->data = p;
 		a->size = l;
 	}
-	if (a->length <= i)
+	if ((int) a->length <= i)
 		a->length = i+1;
 
 	p[i] = v;
 
 	return 0;
 }
 
 /* insert a pointer onto the first NULL index of an array */
 int array_insert_ptr(array_t *a, void *v)
 {
-	int i;
+	uint32_t i;
 	uint8_t** p;
 
 	if (a->type != ARRAY_TYPE_PTR)
 		return 1;
 
@@ -599,12 +615,16 @@
 }
 
 /* get an int value from an array */
 uint32_t array_get_int(array_t *a, int i)
 {
+
+	if(i < 0)
+	    return 0;
+	
 	if (a->type == ARRAY_TYPE_INT) {
-		if (a->length <= i)
+	    if ((int) a->length <= i)
 			return 0;
 		return ((uint32_t*)(a->data))[i];
 	}else if (a->type == ARRAY_TYPE_FLOAT) {
 		float v = array_get_float(a,i);
 		return (uint32_t)v;
@@ -619,12 +639,16 @@
 }
 
 /* get a float value from an array */
 float array_get_float(array_t *a, int i)
 {
+	
+	if(i < 0)
+	    return 0.0;
+	
 	if (a->type == ARRAY_TYPE_FLOAT) {
-		if (a->length <= i)
+	    if ((int) a->length <= i)
 			return 0.0;
 		return ((float*)(a->data))[i];
 	}else if (a->type == ARRAY_TYPE_INT) {
 		uint32_t v = array_get_int(a,i);
 		return (float)v;
@@ -639,10 +663,14 @@
 }
 
 /* get a string value from an array */
 char* array_get_string(array_t *a, int i)
 {
+
+	if(i < 0)
+	    return NULL;
+	
 	if (a->type == ARRAY_TYPE_FLOAT) {
 		float v = array_get_float(a,i);
 		char sv[20];
 		sprintf(sv,"%f",v);
 		return strdup(sv);
@@ -650,31 +678,35 @@
 		uint32_t v = array_get_int(a,i);
 		char sv[20];
 		sprintf(sv,"%u",v);
 		return strdup(sv);
 	}else if (a->type == ARRAY_TYPE_STRING) {
-		if (a->length <= i)
+	    if ((int) a->length <= i)
 			return NULL;
 		return ((char**)(a->data))[i];
 	}
 	return NULL;
 }
 
 /* get a pointer from an array */
 void *array_get_ptr(array_t *a, int i)
 {
-	if (a->type == ARRAY_TYPE_PTR && a->length > i) {
+
+	if(i < 0)
+	    return NULL;
+	
+	if (a->type == ARRAY_TYPE_PTR && (int) a->length > i) {
 		return ((char**)(a->data))[i];
 	}
 	return NULL;
 }
 
 /* find the index of an int value in an array */
 int array_find_int(array_t *a, uint32_t v)
 {
 	if (a->type == ARRAY_TYPE_INT) {
-		int i;
+		uint32_t i;
 		uint32_t *p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (p[i] == v)
 				return i;
 		}
@@ -684,11 +716,11 @@
 
 /* find the index of a float value in an array */
 int array_find_float(array_t *a, float v)
 {
 	if (a->type == ARRAY_TYPE_FLOAT) {
-		int i;
+		uint32_t i;
 		float *p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (p[i] == v)
 				return i;
 		}
@@ -698,11 +730,11 @@
 
 /* find the index of a string value in an array */
 int array_find_string(array_t *a, char* v)
 {
 	if (a->type == ARRAY_TYPE_STRING) {
-		int i;
+		uint32_t i;
 		char** p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (!strcmp(p[i],v))
 				return i;
 		}
@@ -712,11 +744,11 @@
 
 /* find the index of a pointer in an array */
 int array_find_ptr(array_t *a, void *v)
 {
 	if (a->type == ARRAY_TYPE_PTR) {
-		int i;
+		uint32_t i;
 		uint8_t* cv = v;
 		uint8_t** p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (p[i] == cv)
 				return i;
@@ -727,11 +759,11 @@
 
 /* remove a string value from an array */
 int array_remove_string(array_t *a, char* v)
 {
 	if (a->type == ARRAY_TYPE_STRING) {
-		int i;
+		uint32_t i;
 		char** p = a->data;
 		for (i=0; i<a->length; i++) {
 			if (!strcmp(p[i],v)) {
 				free(p[i]);
 				break;
@@ -749,22 +781,19 @@
 /* split a string into an array, at a separator character */
 /* TODO: if strings is non-zero, then don't split within "" or '' */
 /* TODO: utf8 support */
 array_t *array_split(char* str, char* s, int strings)
 {
+	
+	if (!str || !s)
+	    return NULL;
+
 	char buff[1024];
 	int i;
 	int o = 0;
-	int l;
-	array_t *r;
-
-	if (!str)
-		return NULL;
-
-	r = array_create(ARRAY_TYPE_STRING);
-
-	l = strlen(s);
+	array_t* const r = array_create(ARRAY_TYPE_STRING);
+	const int l = strlen(s);
 
 	for (i=0; str[i]; i++) {
 		if (!strncmp(str+i,s,l)) {
 			buff[o] = 0;
 			array_push_string(r,buff);
@@ -781,27 +810,30 @@
 }
 
 /* join an array into a string, using a glue character */
 char* array_join(array_t *a, char* glue, int start)
 {
+	const uint32_t ustart = start < 0 ? 0 : start;	
 	char* str = NULL;
 	int l = 0;
+	
 	if (!glue)
 		glue = " ";
+	
 	if (a->type == ARRAY_TYPE_STRING) {
-		int i;
-		int gl = strlen(glue);
-		for (i=start; i<a->length; i++) {
-			l += strlen(((char**)(a->data))[i])+gl;
+		uint32_t i;
+		const int gl = strlen(glue);
+		for (i=ustart; i<a->length; i++) {
+		    l += strlen(((char**)(a->data))[i]) + gl;
 		}
 		if (l) {
-			str = malloc(l+1);
+			str = malloc(l + 1);
 			str[0] = 0;
-			for (i=start; i<a->length; i++) {
-				if (i > start)
-					strcat(str,glue);
-				strcat(str,((char**)(a->data))[i]);
+			for (i=ustart; i<a->length; i++) {
+			    if (i > ustart)
+				strcat(str,glue);
+			    strcat(str,((char**)(a->data))[i]);
 			}
 		}
 	}
 
 	return str;
diff -rU5 voxelands-v1709.00old/src/auth.c voxelands-v1709.00good/src/auth.c
--- voxelands-v1709.00old/src/auth.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/auth.c	2024-06-09 13:17:14.655157790 +0200
@@ -82,11 +82,11 @@
 
 	return r;
 }
 
 /* convert a string to privs */
-uint64_t auth_str2privs(char* str)
+uint64_t auth_str2privs(const char* str)
 {
 	uint64_t privs = 0;
 	char buff[256];
 	int i;
 	int j;
@@ -118,11 +118,11 @@
 
 	return privs;
 }
 
 /* init auth system for the given file */
-int auth_init(char* file)
+int auth_init(const char* file)
 {
 	char* path;
 	if (!auth.mutex) {
 		auth.mutex = mutex_create();
 		if (!auth.mutex)
diff -rU5 voxelands-v1709.00old/src/auth.h voxelands-v1709.00good/src/auth.h
--- voxelands-v1709.00old/src/auth.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/auth.h	2024-06-09 13:17:14.655157790 +0200
@@ -31,12 +31,12 @@
 } authdata_t;
 #endif
 
 /* defined in auth.c */
 int auth_privs2str(uint64_t privs, char* buff, int size);
-uint64_t auth_str2privs(char* str);
-int auth_init(char* file);
+uint64_t auth_str2privs(const char* str);
+int auth_init(const char* file);
 void auth_exit(void);
 void auth_load(void);
 void auth_save(void);
 int auth_exists(char* name);
 void auth_set(char* name, authdata_t data);
diff -rU5 voxelands-v1709.00old/src/ban.c voxelands-v1709.00good/src/ban.c
--- voxelands-v1709.00old/src/ban.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/ban.c	2024-06-09 13:17:14.655157790 +0200
@@ -41,11 +41,11 @@
 	NULL,
 	0
 };
 
 /* init ban system for the given file */
-int ban_init(char* file)
+int ban_init(const char* file)
 {
 	char* path;
 	if (!ban.mutex) {
 		ban.mutex = mutex_create();
 		if (!ban.mutex)
diff -rU5 voxelands-v1709.00old/src/ban.h voxelands-v1709.00good/src/ban.h
--- voxelands-v1709.00old/src/ban.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/ban.h	2024-06-09 13:17:14.655157790 +0200
@@ -4,11 +4,11 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* defined in ban.c */
-int ban_init(char* file);
+int ban_init(const char* file);
 void ban_exit(void);
 void ban_load(void);
 void ban_save(void);
 int ban_ipbanned(char* ip);
 int ban_description(char* ip_or_name, char* buff, int size);
diff -rU5 voxelands-v1709.00old/src/bridge_temp.cpp voxelands-v1709.00good/src/bridge_temp.cpp
--- voxelands-v1709.00old/src/bridge_temp.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/bridge_temp.cpp	2024-06-15 19:25:41.507978321 +0200
@@ -124,11 +124,11 @@
 		Address address = server->getPeerAddress(player->peer_id);
 		std::string ip_string = address.serializeString();
 		if (ip_string.size() >= (uint32_t)size)
 			return -1;
 		strcpy(buff,ip_string.c_str());
-	} catch(con::PeerNotFoundException) {
+	} catch(con::PeerNotFoundException&) {
 		std::string ip_string = ((ServerRemotePlayer*)player)->getAddress();
 		if (ip_string == "")
 			return -1;
 		if (ip_string.size() >= (uint32_t)size)
 			return -1;
@@ -248,13 +248,13 @@
 	SHA1 sha1;
 	sha1.addBytes(str, l);
 	return sha1.getDigest();
 }
 
-std::string bridge_config_get(char* name)
+std::string bridge_config_get(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (!v)
 		return "";
 
 	return std::string(v);
 }
diff -rU5 voxelands-v1709.00old/src/character_creator.cpp voxelands-v1709.00good/src/character_creator.cpp
--- voxelands-v1709.00old/src/character_creator.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/character_creator.cpp	2024-06-09 13:17:14.656158083 +0200
@@ -118,11 +118,11 @@
 	m_cameranode->setPosition(v3f(20,0,0));
 	// *100.0 helps in large map coordinates
 	m_cameranode->setTarget(v3f(0,0,0));
 
 	// get a unique mesh so that the player model has it's own lighting
-	scene::IAnimatedMesh* mesh = createModelMesh(smgr,"character.b3d",true);
+	scene::IAnimatedMesh* const mesh = createModelMesh(smgr,"character.b3d",true);
 	if (!mesh)
 		return;
 
 	m_model = smgr->addAnimatedMeshSceneNode(mesh,smgr->getRootSceneNode());
 
@@ -809,11 +809,11 @@
 //M:10:10:fair:blue:brown:medium:normal:green:blue:leather
 void GUICharDefMenu::fetchPlayerSkin()
 {
 	char buff[1024];
 	char buf[256];
-	char* v;
+	const char* v;
 	std::string chardef = std::string(PLAYER_DEFAULT_CHARDEF);
 	v = config_get("client.character");
 	if (v)
 		chardef = v;
 	Strfnd f(chardef);
diff -rU5 voxelands-v1709.00old/src/client.cpp voxelands-v1709.00good/src/client.cpp
--- voxelands-v1709.00old/src/client.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/client.cpp	2024-06-12 21:27:13.467436246 +0200
@@ -143,47 +143,48 @@
 */
 
 void * MeshUpdateThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("MeshUpdateThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
 	while (getRun()) {
-		QueuedMeshUpdate *q = m_queue_in.pop();
+		QueuedMeshUpdate* const q = m_queue_in.pop();
 		if (q == NULL) {
 			sleep_ms(3);
 			continue;
 		}
 
 		ScopeProfiler sp(g_profiler, "Client: Mesh making");
 
 		if (q->data && q->data->m_refresh_only) {
-			MapBlock *block = m_env->getMap().getBlockNoCreateNoEx(q->p);
+			MapBlock* const block = m_env->getMap().getBlockNoCreateNoEx(q->p);
 			if (block && block->mesh) {
 				{
 					JMutexAutoLock lock(block->mesh_mutex);
 					block->mesh->refresh(q->data->m_daynight_ratio);
 				}
 			}
 		}else{
-			MapBlock *block = m_env->getMap().getBlockNoCreateNoEx(q->p);
+			MapBlock* const block = m_env->getMap().getBlockNoCreateNoEx(q->p);
 			if (block && block->mesh) {
 				block->mesh->generate(q->data, m_camera_offset, &block->mesh_mutex);
 				if (q->ack_block_to_server) {
 					MeshUpdateResult r;
 					r.p = q->p;
 					r.mesh = NULL;
 					r.ack_block_to_server = true;
 					m_queue_out.push_back(r);
 				}
 			}else if (block) {
-				MapBlockMesh *mesh_new = new MapBlockMesh(q->data, m_camera_offset);
+				MapBlockMesh* const mesh_new = new MapBlockMesh(q->data, m_camera_offset);
 				MeshUpdateResult r;
 				r.p = q->p;
 				r.mesh = mesh_new;
 				r.ack_block_to_server = q->ack_block_to_server;
 
@@ -250,13 +251,13 @@
 		Add local player
 	*/
 	{
 		//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
 
-		Player *player = new LocalPlayer();
+		Player* const player = new LocalPlayer();
 
-		char* v = config_get("client.name");
+		const char* v = config_get("client.name");
 		if (v) {
 			player->updateName(v);
 		}else{
 			player->updateName(porting::getUser().c_str());
 		}
@@ -371,11 +372,11 @@
 		if (counter <= 0.0) {
 			counter = 2.0;
 
 			//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
 
-			Player *myplayer = m_env.getLocalPlayer();
+			Player* const myplayer = m_env.getLocalPlayer();
 			assert(myplayer != NULL);
 
 			// Send TOSERVER_INIT
 			// [0] u16 TOSERVER_INIT
 			// [2] u8 SER_FMT_VER_HIGHEST
@@ -473,11 +474,11 @@
 	{
 		// 0ms
 		//JMutexAutoLock lock(m_env_mutex); //bulk comment-out
 
 		// Control local player (0ms)
-		LocalPlayer *player = m_env.getLocalPlayer();
+		LocalPlayer* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		player->applyControl(dtime);
 
 		//TimeTaker envtimer("env step", m_device);
 		// Step environment
@@ -581,11 +582,11 @@
 				<<m_mesh_update_thread.m_queue_out.size()
 				<<std::endl;*/
 
 		while (m_mesh_update_thread.m_queue_out.size() > 0) {
 			MeshUpdateResult r = m_mesh_update_thread.m_queue_out.pop_front();
-			MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(r.p);
+			MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(r.p);
 			if (block) {
 				if (r.mesh != NULL) {
 					JMutexAutoLock lock(block->mesh_mutex);
 
 					MapBlockMesh *mesh_old = block->mesh;
@@ -732,11 +733,11 @@
 
 		{ //envlock
 			//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
 
 			// Set player position
-			Player *player = m_env.getLocalPlayer();
+			Player* const player = m_env.getLocalPlayer();
 			assert(player != NULL);
 			player->setPosition(playerpos_f);
 		}
 
 		if (datasize >= 2+1+6+8) {
@@ -752,11 +753,11 @@
 			infostream<<"Client: received map type: "<<m_map_type<<std::endl;
 		}
 
 		{
 			// Reply to server
-			char *v;
+			const char *v;
 			std::string chardef = std::string(PLAYER_DEFAULT_CHARDEF);
 			v = config_get("client.character");
 			if (v)
 				chardef = v;
 
@@ -947,11 +948,11 @@
 
 				// Don't update the info of the local player
 				if (peer_id == our_peer_id)
 					continue;
 
-				Player *player = m_env.getPlayer(peer_id);
+				Player* player = m_env.getPlayer(peer_id);
 
 				// Create a player if it doesn't exist
 				if (player == NULL) {
 					player = new RemotePlayer(
 						m_device->getSceneManager()->getRootSceneNode(),
@@ -969,11 +970,11 @@
 
 			/*
 				Remove those players from the environment that
 				weren't listed by the server.
 			*/
-			array_t *players = m_env.getPlayers();
+			array_t* const players = m_env.getPlayers();
 			Player *player;
 			uint32_t i;
 			for (i=0; i<players->length; i++) {
 				player = (Player*)array_get_ptr(players,i);
 				if (!player)
@@ -996,11 +997,11 @@
 	break;
 	case TOCLIENT_PLAYERSTATE:
 	{
 		std::string datastring((char*)&data[2], datasize-2);
 		std::istringstream is(datastring, std::ios_base::binary);
-		LocalPlayer *player = m_env.getLocalPlayer();
+		LocalPlayer* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		u8 hp = readU8(is);
 		u8 air = readU8(is);
 		u8 hunger = readU8(is);
 		player->dirt = readU8(is);
@@ -1027,11 +1028,11 @@
 			return;
 		{
 			std::string datastring((char*)&data[2], datasize-2);
 			std::istringstream is(datastring, std::ios_base::binary);
 
-			Player *player = m_env.getLocalPlayer();
+			Player* const player = m_env.getLocalPlayer();
 			assert(player != NULL);
 
 			player->inventory.deSerialize(is);
 
 			m_inventory_updated = true;
@@ -1044,11 +1045,11 @@
 			return;
 		{
 			std::string datastring((char*)&data[2], datasize-2);
 			std::istringstream is(datastring, std::ios_base::binary);
 
-			Player *player = m_env.getLocalPlayer();
+			Player* const player = m_env.getLocalPlayer();
 			assert(player != NULL);
 
 			u16 list_count = readU16(is);
 			for (int i=0; i<list_count; i++) {
 				std::string name = deSerializeString(is);
@@ -1088,11 +1089,11 @@
 			f32 pitch = readF1000(is);
 			f32 yaw = readF1000(is);
 			u8 anim_id = readU8(is);
 			content_t pointed = readU16(is);
 
-			Player *player = m_env.getPlayer(peer_id);
+			Player* const player = m_env.getPlayer(peer_id);
 
 			// Skip if player doesn't exist
 			if (player == NULL)
 				continue;
 
@@ -1134,11 +1135,11 @@
 			is.read((char*)buf, 4);
 			s32 pitch_i = readS32(buf);
 			is.read((char*)buf, 4);
 			s32 yaw_i = readS32(buf);
 
-			Player *player = m_env.getPlayer(peer_id);
+			Player* const player = m_env.getPlayer(peer_id);
 
 			// Skip if player doesn't exist
 			if (player == NULL)
 				continue;
 
@@ -1327,11 +1328,11 @@
 	break;
 	case TOCLIENT_MOVE_PLAYER:
 	{
 		std::string datastring((char*)&data[2], datasize-2);
 		std::istringstream is(datastring, std::ios_base::binary);
-		Player *player = m_env.getLocalPlayer();
+		Player* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		v3f pos = readV3F1000(is);
 		f32 pitch = readF1000(is);
 		f32 yaw = readF1000(is);
 		player->setPosition(pos);
@@ -1370,11 +1371,11 @@
 		u16 icount = readU16(is);
 		u16 itm;
 
 		for (u16 i = 0; i < count; ++i) {
 			u16 peer_id = readU16(is);
-			Player *player = m_env.getPlayer(peer_id);
+			Player* const player = m_env.getPlayer(peer_id);
 
 			if (player == NULL) {
 				for (int j=0; j<icount; j++) {
 					itm = readU16(is);
 				}
@@ -1430,35 +1431,35 @@
 					}
 				}
 				// for 1409 servers, this stops players appearing naked
 				if (icount == 5) {
 					{
-						InventoryList *inv = player->inventory.getList("shirt");
+						InventoryList* const inv = player->inventory.getList("shirt");
 						if (!inv->getItem(0)) {
-							InventoryItem *item = inv->changeItem(
+							InventoryItem* const item = inv->changeItem(
 								0,
 								InventoryItem::create(CONTENT_CLOTHESITEM_COTTON_TSHIRT_GREEN,1)
 							);
 							if (item)
 								delete item;
 						}
 					}
 					{
-						InventoryList *inv = player->inventory.getList("pants");
+						InventoryList* const inv = player->inventory.getList("pants");
 						if (!inv->getItem(0)) {
-							InventoryItem *item = inv->changeItem(
+							InventoryItem* const item = inv->changeItem(
 								0,
 								InventoryItem::create(CONTENT_CLOTHESITEM_CANVAS_PANTS_BLUE,1)
 							);
 							if (item)
 								delete item;
 						}
 					}
 					{
-						InventoryList *inv = player->inventory.getList("boots");
+						InventoryList* const inv = player->inventory.getList("boots");
 						if (!inv->getItem(0)) {
-							InventoryItem *item = inv->changeItem(
+							InventoryItem* const item = inv->changeItem(
 								0,
 								InventoryItem::create(CONTENT_CLOTHESITEM_LEATHER_SHOES,1)
 							);
 							if (item)
 								delete item;
@@ -1582,11 +1583,11 @@
 void Client::throwItem(v3f dir, u16 item)
 {
 	std::ostringstream os(std::ios_base::binary);
 	u8 buf[15];
 
-	LocalPlayer* player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 
 	// Write command
 	writeU16(buf, TOSERVER_THROWITEM);
 	os.write((char*)buf, 2);
 
@@ -1622,11 +1623,11 @@
 	// Send as reliable
 	Send(0, data, true);
 
 #if USE_AUDIO == 1
 	{
-		InventoryItem *item = (InventoryItem*)m_env.getLocalPlayer()->getWieldItem();
+		InventoryItem* const item = (InventoryItem*)m_env.getLocalPlayer()->getWieldItem();
 		if (!item)
 			return;
 		std::string snd("");
 		content_t w = item->getContent();
 		if ((w&CONTENT_CRAFTITEM_MASK) == CONTENT_CRAFTITEM_MASK)
@@ -1644,20 +1645,20 @@
 				"cancelled (not connected)"
 				<<std::endl;
 		return;
 	}
 
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (player == NULL)
 		return;
 
-	ClientActiveObject *obj = m_env.getActiveObject(id);
+	ClientActiveObject* const obj = m_env.getActiveObject(id);
 	if (obj) {
 		if (button == 0) {
 			content_t punch_item = CONTENT_IGNORE;
 
-			InventoryList *mlist = player->inventory.getList("main");
+			InventoryList* const mlist = player->inventory.getList("main");
 			if (mlist != NULL) {
 				InventoryItem *item = mlist->getItem(item_i);
 				if (item)
 					punch_item = item->getContent();
 			}
@@ -1763,11 +1764,11 @@
 }
 
 void Client::sendChangePassword(const std::wstring oldpassword,
 		const std::wstring newpassword)
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if(player == NULL)
 		return;
 
 	std::string playername = player->getName();
 	std::string oldpwd = translatePassword(playername, oldpassword);
@@ -1844,11 +1845,11 @@
 	Send(0, data, true);
 }
 
 void Client::sendPlayerPos()
 {
-	LocalPlayer *myplayer = m_env.getLocalPlayer();
+	LocalPlayer* const myplayer = m_env.getLocalPlayer();
 	if (myplayer == NULL)
 		return;
 
 	// Save bandwidth by only updating position when something changed
 	if (
@@ -1899,11 +1900,11 @@
 	Send(0, data, false);
 }
 
 void Client::sendPlayerItem(u16 item)
 {
-	Player *myplayer = m_env.getLocalPlayer();
+	Player* const myplayer = m_env.getLocalPlayer();
 	if(myplayer == NULL)
 		return;
 
 	u16 our_peer_id = m_con.GetPeerID();
 
@@ -2009,18 +2010,18 @@
 }
 
 void Client::setPlayerControl(PlayerControl &control)
 {
 	//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
-	LocalPlayer *player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 	assert(player != NULL);
 	player->control = control;
 }
 
 void Client::selectPlayerItem(u16 item)
 {
-	LocalPlayer *player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 	assert(player != NULL);
 
 	player->wieldItem(item);
 
 	sendPlayerItem(item);
@@ -2039,11 +2040,11 @@
 
 // Copies the inventory of the local player to parameter
 void Client::getLocalInventory(Inventory &dst)
 {
 	//JMutexAutoLock envlock(m_env_mutex); //bulk comment-out
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	assert(player != NULL);
 	dst = player->inventory;
 }
 
 InventoryContext *Client::getInventoryContext()
@@ -2086,26 +2087,26 @@
 	case InventoryLocation::UNDEFINED:
 	{}
 	break;
 	case InventoryLocation::CURRENT_PLAYER:
 	{
-		Player *player = m_env.getLocalPlayer();
+		Player* const player = m_env.getLocalPlayer();
 		assert(player != NULL);
 		return &player->inventory;
 	}
 	break;
 	case InventoryLocation::PLAYER:
 	{
-		Player *player = m_env.getPlayer(loc->name.c_str());
+		Player* const player = m_env.getPlayer(loc->name.c_str());
 		if(!player)
 			return NULL;
 		return &player->inventory;
 	}
 	break;
 	case InventoryLocation::NODEMETA:
 	{
-		NodeMetadata *meta = m_env.getMap().getNodeMetadata(loc->p);
+		NodeMetadata* const meta = m_env.getMap().getNodeMetadata(loc->p);
 		if(!meta)
 			return NULL;
 		return meta->getInventory();
 	}
 	break;
@@ -2158,35 +2159,35 @@
 {
 }
 
 u16 Client::getHP()
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0;
 	return player->health;
 }
 
 u16 Client::getAir()
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0;
 	return player->air;
 }
 
 u16 Client::getHunger()
 {
-	Player *player = m_env.getLocalPlayer();
+	Player* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0;
 	return player->hunger;
 }
 
 float Client::getEnergy()
 {
-	LocalPlayer *player = m_env.getLocalPlayer();
+	LocalPlayer* const player = m_env.getLocalPlayer();
 	if (!player)
 		return 0.0;
 	return player->getEnergy();
 }
 
@@ -2285,11 +2286,13 @@
 }
 
 // foot: 0 = left, 1 = right
 void Client::playStepSound(int foot)
 {
+#if USE_AUDIO == 1
 	sound_play_step(&m_env.getMap(),m_env.getLocalPlayer()->getPosition(),foot,1.0);
+#endif
 }
 
 void Client::playDigSound(content_t c)
 {
 	if (c == CONTENT_IGNORE) {
@@ -2297,19 +2300,22 @@
 		if ((c&CONTENT_MOB_MASK) != 0)
 			return;
 	}
 	if (c == CONTENT_IGNORE)
 		c = CONTENT_AIR;
-
+	
+#if USE_AUDIO == 1
 	sound_play_dig(c,m_env.getLocalPlayer()->getPosition());
+#endif
 }
 
 void Client::playPlaceSound(content_t c)
 {
 	if (c == CONTENT_IGNORE)
 		c = getPointedContent();
 
+#if USE_AUDIO == 1
 	ContentFeatures *f = &content_features(c);
 	if (f->sound_place != "") {
 		sound_play_effect((char*)f->sound_place.c_str(),1.0,0,NULL);
 		return;
 	}
@@ -2318,17 +2324,22 @@
 		sound_play_effect("liquid-place",1.0,0,NULL);
 		break;
 	default:
 		sound_play_effect("place",1.0,0,NULL);
 	}
+#endif
 }
 
 void Client::playSound(std::string &name, bool loop)
 {
+#if USE_AUDIO == 1
 	sound_play_effect((char*)name.c_str(),1.0,loop,NULL);
+#endif
 }
 
 void Client::playSoundAt(std::string &name, v3f pos, bool loop)
 {
+#if USE_AUDIO == 1
 	v3_t p = {pos.X,pos.Y,pos.Z};
 	sound_play_effect((char*)name.c_str(),1.0,loop,&p);
+#endif
 }
diff -rU5 voxelands-v1709.00old/src/collision.h voxelands-v1709.00good/src/collision.h
--- voxelands-v1709.00old/src/collision.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/collision.h	2024-06-18 14:59:37.581688089 +0200
@@ -44,11 +44,11 @@
 	v3s16 node_p; // COLLISION_NODE
 	v3f old_speed;
 	v3f new_speed;
 
 	CollisionInfo():
-		t(COLLISION_NODE),
+		t(COLLISION_NODE),speed(0),
 		node_p(-32768,-32768,-32768),
 		old_speed(0,0,0),
 		new_speed(0,0,0)
 	{}
 };
diff -rU5 voxelands-v1709.00old/src/common.h voxelands-v1709.00good/src/common.h
--- voxelands-v1709.00old/src/common.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/common.h	2024-06-09 13:17:14.656158083 +0200
@@ -98,54 +98,54 @@
 #define SEND_NO_PREFIX (1<<2)
 
 /* defined in string.c */
 char* trim(char* str);
 /*char* strdup(const char* str);*/
-int str_sanitise(char* dest, int size, char* str);
+int str_sanitise(char* dest, int size,const char* str);
 int strappend(char* dest, int size, char* str);
-int parse_bool(char* str);
-int str_tov3t(char* str, v3_t *v);
+int parse_bool(const char* str);
+int str_tov3t(const char* str, v3_t *v);
 int str_topwd(char* name, char* pass, char* buff, int size);
 
 /* defined in config.c */
-char* config_get(char* name);
-int config_get_int(char* name);
-int64_t config_get_int64(char* name);
-float config_get_float(char* name);
-int config_get_bool(char* name);
-int config_get_v3t(char* name, v3_t *value);
-void config_set(char* name, char* value);
+const char* config_get(const char* name);
+int config_get_int(const char* name);
+int64_t config_get_int64(const char* name);
+float config_get_float(const char* name);
+int config_get_bool(const char* name);
+int config_get_v3t(const char* name, v3_t *value);
+void config_set(const char* name,const char* value);
 int config_set_command(command_context_t *ctx, array_t *args);
-void config_set_int(char* name, int value);
-void config_set_int64(char* name, int64_t value);
-void config_set_float(char* name, float value);
-void config_set_default(char* name, char* value, int (*setter)(char* v));
-void config_set_default_int(char* name, int value, int (*setter)(char* v));
-void config_set_default_float(char* name, float value, int (*setter)(char* v));
-void config_load(char* type, char* file);
+void config_set_int(const char* name, int value);
+void config_set_int64(const char* name, int64_t value);
+void config_set_float(const char* name, float value);
+void config_set_default(const char* name,const char* value, int (*setter)(const char* v));
+void config_set_default_int(const char* name, int value, int (*setter)(const char* v));
+void config_set_default_float(const char* name, float value, int (*setter)(const char* v));
+void config_load(const char* type,const char* file);
 int config_load_command(command_context_t *ctx, array_t *args);
 int config_ignore_command(command_context_t *ctx, array_t *args);
 void config_init(int argc, char** argv);
-void config_save(char* section, char* type, char* file);
-void config_clear(char* section);
+void config_save(const char* section,const char* type,const char* file);
+void config_clear(const char* section);
 
 /* defined in config_default.c */
 void config_default_init(void);
 void config_default_creative(void);
 void config_default_survival(void);
-int config_default_gamemode(char* mode);
+int config_default_gamemode(const char* mode);
 
 /* defined in log.c */
-int log_minlevel_setter(char* v);
-int log_maxlevel_setter(char* v);
-int log_sminlevel_setter(char* v);
-int log_smaxlevel_setter(char* v);
-int log_cminlevel_setter(char* v);
-int log_cmaxlevel_setter(char* v);
-int log_file_setter(char* v);
-void vlprint(uint8_t type, char* str);
-void vlprintf(uint8_t type, char* fmt,...);
+int log_minlevel_setter(const char* v);
+int log_maxlevel_setter(const char* v);
+int log_sminlevel_setter(const char* v);
+int log_smaxlevel_setter(const char* v);
+int log_cminlevel_setter(const char* v);
+int log_cmaxlevel_setter(const char* v);
+int log_file_setter(const char* v);
+void vlprint(uint8_t type,const char* str);
+void vlprintf(uint8_t type,const char* fmt,...);
 
 /* defined in utf8.c */
 int utf8_seqlen(char* str);
 uint32_t utf8_nextchar(char* str, int *i);
 uint32_t utf8_toutf32(char* src, int size);
@@ -196,25 +196,25 @@
 int command_adduser(command_context_t *ctx, array_t *args);
 int command_clearobjects(command_context_t *ctx, array_t *args);
 int command_setpassword(command_context_t *ctx, array_t *args);
 
 /* defined in world.c */
-int world_create(char* name);
-int world_load(char* name);
+int world_create(const char* name);
+int world_load(const char* name);
 int world_import(char* path);
 void world_unload(void);
-int world_init(char* name);
+int world_init(const char* name);
 void world_exit(void);
 worldlist_t *world_list_get(void);
 void world_list_free(worldlist_t *l);
 
 #ifdef __cplusplus
 }
 #include <string>
 class Client;
 void bridge_register_client(Client *c);
-std::string bridge_config_get(char* name);
+std::string bridge_config_get(const char* name);
 #endif
 
 /* bridge stuff TODO: remove */
 #ifdef __cplusplus
 #define EXTERNC extern "C"
diff -rU5 voxelands-v1709.00old/src/config.c voxelands-v1709.00good/src/config.c
--- voxelands-v1709.00old/src/config.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/config.c	2024-06-09 13:17:14.656158083 +0200
@@ -38,15 +38,15 @@
 	0
 };
 
 typedef struct config_s {
 	char* default_value;
-	int (*setter)(char* v);
+	int (*setter)(const char* v);
 } config_t;
 
 /* get the value of a config setting */
-char* config_get(char* name)
+const char* config_get(const char* name)
 {
 	nvp_t *n = nvp_get(&config.items,name);
 	if (!n)
 		return NULL;
 
@@ -55,58 +55,58 @@
 
 	return n->value;
 }
 
 /* get a config setting as an int value */
-int config_get_int(char* name)
+int config_get_int(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (v)
 		return strtol(v,NULL,10);
 
 	return 0;
 }
 
 /* get a config setting as an int value */
-int64_t config_get_int64(char* name)
+int64_t config_get_int64(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (v)
 		return strtoll(v,NULL,10);
 
 	return 0;
 }
 
 /* get a config setting as a float value */
-float config_get_float(char* name)
+float config_get_float(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (v)
 		return strtof(v,NULL);
 
 	return 0.0;
 }
 
 /* get a config setting as a boolean value */
-int config_get_bool(char* name)
+int config_get_bool(const char* name)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	return parse_bool(v);
 }
 
 /* get a config setting as a v3_t value */
-int config_get_v3t(char* name, v3_t *value)
+int config_get_v3t(const char* name, v3_t *value)
 {
-	char* v = config_get(name);
+	const char* v = config_get(name);
 	if (!v)
 		return 1;
 
 	return str_tov3t(v,value);
 }
 
 /* set the value of a config setting */
-void config_set(char* name, char* value)
+void config_set(const char* name,const char* value)
 {
 	config_t *c;
 	nvp_t *n;
 
 	if (!name)
@@ -163,35 +163,35 @@
 
 	return 0;
 }
 
 /* set a config setting to an int value */
-void config_set_int(char* name, int value)
+void config_set_int(const char* name, int value)
 {
 	char str[20];
 	sprintf(str,"%d",value);
 	config_set(name,str);
 }
 
 /* set a config setting to a 64bit int value */
-void config_set_int64(char* name, int64_t value)
+void config_set_int64(const char* name, int64_t value)
 {
 	char str[50];
 	sprintf(str,"%ld",value);
 	config_set(name,str);
 }
 
 /* set a config setting to a float value */
-void config_set_float(char* name, float value)
+void config_set_float(const char* name, float value)
 {
 	char str[50];
 	sprintf(str,"%f",value);
 	config_set(name,str);
 }
 
 /* set the default value of a config setting */
-void config_set_default(char* name, char* value, int (*setter)(char* v))
+void config_set_default(const char* name,const char* value, int (*setter)(const char* v))
 {
 	config_t *c;
 	nvp_t *n = nvp_get(&config.items,name);
 
 	if (!n) {
@@ -223,27 +223,27 @@
 	if (value)
 		c->default_value = strdup(value);
 }
 
 /* set the default of a config setting to an int value */
-void config_set_default_int(char* name, int value, int (*setter)(char* v))
+void config_set_default_int(const char* name, int value, int (*setter)(const char* v))
 {
 	char str[20];
 	sprintf(str,"%d",value);
 	config_set_default(name,str,setter);
 }
 
 /* set the default of a config setting to a float value */
-void config_set_default_float(char* name, float value, int (*setter)(char* v))
+void config_set_default_float(const char* name, float value, int (*setter)(const char* v))
 {
 	char str[50];
 	sprintf(str,"%f",value);
 	config_set_default(name,str,setter);
 }
 
 /* load a config file */
-void config_load(char* type, char* file)
+void config_load(const char* type,const char* file)
 {
 	char buff[2048];
 	int s;
 	char* l;
 	file_t *f;
@@ -356,11 +356,11 @@
 
 	config.isinit = 1;
 }
 
 /* save the current config */
-void config_save(char* section, char* type, char* file)
+void config_save(const char* section,const char* type,const char* file)
 {
 	file_t *f;
 	nvp_t *n;
 
 	if (!type && !file) {
@@ -408,11 +408,11 @@
 	file_flush(f);
 	file_free(f);
 }
 
 /* clears all config values for section (i.e. "world.*") to defaults */
-void config_clear(char* section)
+void config_clear(const char* section)
 {
 	nvp_t *n;
 	int l;
 
 	/* don't clear everything, only sections */
diff -rU5 voxelands-v1709.00old/src/config_default.c voxelands-v1709.00good/src/config_default.c
--- voxelands-v1709.00old/src/config_default.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/config_default.c	2024-06-09 14:22:20.628257907 +0200
@@ -53,17 +53,27 @@
 	config_set_default("client.video.vsync","false",NULL);
 	config_set_default("client.video.size.width","1024",NULL);
 	config_set_default("client.video.size.height","600",NULL);
 	config_set_default("client.video.driver","opengl",NULL);
 	config_set_default("client.video.hpfpu","true",NULL);
-
+	
+#if USE_AUDIO == 1
 	config_set_default("client.sound.volume","50",sound_master_setter);
 	config_set_default("client.sound.volume.effects","50",sound_effects_setter);
 	config_set_default("client.sound.volume.music","50",sound_music_setter);
+#else
+	config_set_default("client.sound.volume","50",NULL);
+	config_set_default("client.sound.volume.effects","50",NULL);
+	config_set_default("client.sound.volume.music","50",NULL);
+#endif
 	config_set_default("client.sound.mumble","true",NULL);
 #if USE_MUMBLE == 0
+# if USE_AUDIO == 1
 	config_set_default("client.name",NULL,sound_mumble_set_ident);
+# else
+	config_set_default("client.name",NULL,NULL);
+# endif
 #endif
 
 	config_set_default("client.graphics.mesh.lod","3",NULL);
 	config_set_default("client.graphics.texture.animations","false",NULL);
 	config_set_default("client.graphics.texture.atlas","true",NULL);
@@ -228,11 +238,11 @@
 	config_set_default("world.player.hunger","true",NULL);
 
 	config_set_default("world.game.mob.spawn.level","destructive",NULL);
 }
 
-int config_default_gamemode(char* mode)
+int config_default_gamemode(const char* mode)
 {
 	if (mode && !strcmp(mode,"creative")) {
 		config_default_creative();
 	}else{
 		config_default_survival();
diff -rU5 voxelands-v1709.00old/src/connection.cpp voxelands-v1709.00good/src/connection.cpp
--- voxelands-v1709.00old/src/connection.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/connection.cpp	2024-06-14 22:36:26.069168173 +0200
@@ -168,11 +168,11 @@
 	core::list<BufferedPacket>::Iterator i;
 	i = m_list.begin();
 	for(; i != m_list.end(); i++)
 	{
 		u16 s = readU16(&(i->data[BASE_HEADER_SIZE+1]));
-		dout_con<<s<<" ";
+		dout_con << s << " ";
 	}
 }
 bool ReliablePacketBuffer::empty()
 {
 	return m_list.empty();
@@ -217,11 +217,11 @@
 }
 BufferedPacket ReliablePacketBuffer::popSeqnum(u16 seqnum)
 {
 	RPBSearchResult r = findPacket(seqnum);
 	if(r == notFound()){
-		dout_con<<"Not found"<<std::endl;
+		dout_con << "Not found" << std::endl;
 		throw NotFoundException("seqnum not found in buffer");
 	}
 	BufferedPacket p = *r;
 	m_list.erase(r);
 	return p;
@@ -349,17 +349,17 @@
 
 	IncomingSplitPacket *sp = m_buf[seqnum];
 
 	// TODO: These errors should be thrown or something? Dunno.
 	if(chunk_count != sp->chunk_count)
-		derr_con<<"Connection: WARNING: chunk_count="<<chunk_count
-				<<" != sp->chunk_count="<<sp->chunk_count
-				<<std::endl;
+		derr_con << "Connection: WARNING: chunk_count=" << chunk_count
+				 << " != sp->chunk_count=" << sp->chunk_count
+				 << std::endl;
 	if(reliable != sp->reliable)
-		derr_con<<"Connection: WARNING: reliable="<<reliable
-				<<" != sp->reliable="<<sp->reliable
-				<<std::endl;
+		derr_con << "Connection: WARNING: reliable=" << reliable
+				 << " != sp->reliable=" << sp->reliable
+				 << std::endl;
 
 	// If chunk already exists, cancel
 	if(sp->chunks.find(chunk_num) != NULL)
 		throw AlreadyExistsException("Chunk already in buffer");
 
@@ -420,12 +420,12 @@
 	}
 	core::list<u16>::Iterator j;
 	j = remove_queue.begin();
 	for(; j != remove_queue.end(); j++)
 	{
-		dout_con<<"NOTE: Removing timed out unreliable split packet"
-				<<std::endl;
+		dout_con << "NOTE: Removing timed out unreliable split packet"
+				 << std::endl;
 		delete m_buf[*j];
 		m_buf.remove(*j);
 	}
 }
 
@@ -518,11 +518,12 @@
 	m_bc_peerhandler(NULL),
 	m_bc_receive_timeout(0),
 	m_indentation(0)
 {
 	m_socket.setTimeoutMs(5);
-
+	m_peers_mutex.Init();
+	
 	Start();
 }
 
 Connection::Connection(u32 protocol_id, u32 max_packet_size, float timeout,
 		PeerHandler *peerhandler):
@@ -533,10 +534,11 @@
 	m_bc_peerhandler(peerhandler),
 	m_bc_receive_timeout(0),
 	m_indentation(0)
 {
 	m_socket.setTimeoutMs(5);
+	m_peers_mutex.Init();
 
 	Start();
 }
 
 
@@ -548,13 +550,15 @@
 /* Internal stuff */
 
 void * Connection::Thread()
 {
 	ThreadStarted();
+	log_mutex.Lock();
 	log_register_thread("Connection");
+	log_mutex.Unlock();
 
-	dout_con<<"Connection thread started"<<std::endl;
+	dout_con  <<  "Connection thread started"  <<  std::endl;
 
 	u32 curtime = porting::getTimeMs();
 	u32 lasttime = curtime;
 
 	while(getRun())
@@ -594,35 +598,39 @@
 
 void Connection::processCommand(ConnectionCommand &c)
 {
 	switch(c.type){
 	case CONNCMD_NONE:
-		dout_con<<getDesc()<<" processing CONNCMD_NONE"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_NONE" << std::endl;
 		return;
 	case CONNCMD_SERVE:
-		dout_con<<getDesc()<<" processing CONNCMD_SERVE port="
-				<<c.port<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_SERVE port="
+				<< c.port << std::endl;
 		serve(c.port);
 		return;
 	case CONNCMD_CONNECT:
-		dout_con<<getDesc()<<" processing CONNCMD_CONNECT"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_CONNECT"
+			 << std::endl;
 		connect(c.address);
 		return;
 	case CONNCMD_DISCONNECT:
-		dout_con<<getDesc()<<" processing CONNCMD_DISCONNECT"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_DISCONNECT"
+			 << std::endl;
 		disconnect();
 		return;
 	case CONNCMD_SEND:
-		dout_con<<getDesc()<<" processing CONNCMD_SEND"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_SEND" << std::endl;
 		send(c.peer_id, c.channelnum, c.data, c.reliable);
 		return;
 	case CONNCMD_SEND_TO_ALL:
-		dout_con<<getDesc()<<" processing CONNCMD_SEND_TO_ALL"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_SEND_TO_ALL"
+			 << std::endl;
 		sendToAll(c.channelnum, c.data, c.reliable);
 		return;
 	case CONNCMD_DELETE_PEER:
-		dout_con<<getDesc()<<" processing CONNCMD_DELETE_PEER"<<std::endl;
+		dout_con << getDesc() << " processing CONNCMD_DELETE_PEER"
+			 << std::endl;
 		deletePeer(c.peer_id, false);
 		return;
 	}
 }
 
@@ -715,11 +723,11 @@
 
 		u16 peer_id = readPeerId(*packetdata);
 		u8 channelnum = readChannel(*packetdata);
 		if(channelnum > CHANNEL_COUNT-1){
 			PrintInfo(derr_con);
-			derr_con<<"Receive(): Invalid channel "<<channelnum<<std::endl;
+			derr_con << "Receive(): Invalid channel " << channelnum << std::endl;
 			throw InvalidIncomingDataException("Channel doesn't exist");
 		}
 
 		if(peer_id == PEER_ID_INEXISTENT)
 		{
@@ -754,12 +762,12 @@
 			else
 			{
 				Peer *peer = j.getNode()->getValue();
 				peer_id = peer->id;
 				PrintInfo(derr_con);
-				derr_con<<"WARNING: Assuming unknown peer to be "
-						<<"peer_id="<<peer_id<<std::endl;
+				derr_con << "WARNING: Assuming unknown peer to be "
+						 << "peer_id=" << peer_id << std::endl;
 			}
 		}
 
 		/*
 			The peer was not found in our lists. Add it.
@@ -785,17 +793,17 @@
 					break;
 				}
 				peer_id_new++;
 			}
 			if(out_of_ids){
-				errorstream<<getDesc()<<" ran out of peer ids"<<std::endl;
+				errorstream << getDesc() << " ran out of peer ids" << std::endl;
 				continue;
 			}
 
 			PrintInfo();
-			dout_con<<"Receive(): Got a packet with peer_id=PEER_ID_INEXISTENT,"
-					" giving peer_id="<<peer_id_new<<std::endl;
+			dout_con  <<  "Receive(): Got a packet with peer_id=PEER_ID_INEXISTENT,"
+					" giving peer_id=" << peer_id_new<<std::endl;
 
 			// Create a peer
 			Peer *peer = new Peer(peer_id_new, sender);
 			m_peers.insert(peer->id, peer);
 
@@ -823,22 +831,22 @@
 		{
 			// Peer not found
 			// This means that the peer id of the sender is not PEER_ID_INEXISTENT
 			// and it is invalid.
 			PrintInfo(derr_con);
-			derr_con<<"Receive(): Peer not found"<<std::endl;
+			derr_con << "Receive(): Peer not found" << std::endl;
 			throw InvalidIncomingDataException("Peer not found (possible timeout)");
 		}
 
 		Peer *peer = node->getValue();
 
 		// Validate peer address
 		if(peer->address != sender)
 		{
 			PrintInfo(derr_con);
-			derr_con<<"Peer "<<peer_id<<" sending from different address."
-					" Ignoring."<<std::endl;
+			derr_con  <<  "Peer " << peer_id << " sending from different address."
+					" Ignoring." << std::endl;
 			continue;
 		}
 
 		peer->timeout_counter = 0.0;
 
@@ -855,12 +863,12 @@
 			// Process it (the result is some data with no headers made by us)
 			SharedBuffer<u8> resultdata = processPacket
 					(channel, strippeddata, peer_id, channelnum, false);
 
 			PrintInfo();
-			dout_con<<"ProcessPacket returned data of size "
-					<<resultdata.getSize()<<std::endl;
+			dout_con << "ProcessPacket returned data of size "
+					<< resultdata.getSize() << std::endl;
 
 			if(datasize < resultdata.getSize())
 				throw InvalidIncomingDataException
 						("Buffer too small for received data");
 
@@ -891,14 +899,14 @@
 		*/
 		peer->timeout_counter += dtime;
 		if(peer->timeout_counter > m_timeout)
 		{
 			PrintInfo(derr_con);
-			derr_con<<"RunTimeouts(): Peer "<<peer->id
-					<<" has timed out."
-					<<" (source=peer->timeout_counter)"
-					<<std::endl;
+			derr_con << "RunTimeouts(): Peer " << peer->id
+					 << " has timed out."
+					 << " (source=peer->timeout_counter)"
+					 << std::endl;
 			// Add peer to the list
 			timeouted_peers.push_back(peer->id);
 			// Don't bother going through the buffers of this one
 			continue;
 		}
@@ -920,14 +928,14 @@
 			// Check reliable packet total times, remove peer if
 			// over timeout.
 			if(channel->outgoing_reliables.anyTotaltimeReached(m_timeout))
 			{
 				PrintInfo(derr_con);
-				derr_con<<"RunTimeouts(): Peer "<<peer->id
-						<<" has timed out."
-						<<" (source=reliable packet totaltime)"
-						<<std::endl;
+				derr_con << "RunTimeouts(): Peer " << peer->id
+						 << " has timed out."
+						 << " (source=reliable packet totaltime)"
+						 << std::endl;
 				// Add peer to the to-be-removed list
 				timeouted_peers.push_back(peer->id);
 				goto nextpeer;
 			}
 
@@ -944,17 +952,17 @@
 				u16 peer_id = readPeerId(*(j->data));
 				u8 channel = readChannel(*(j->data));
 				u16 seqnum = readU16(&(j->data[BASE_HEADER_SIZE+1]));
 
 				PrintInfo(derr_con);
-				derr_con<<"RE-SENDING timed-out RELIABLE to ";
+				derr_con << "RE-SENDING timed-out RELIABLE to ";
 				j->address.print(&derr_con);
-				derr_con<<"(t/o="<<resend_timeout<<"): "
-						<<"from_peer_id="<<peer_id
-						<<", channel="<<((int)channel&0xff)
-						<<", seqnum="<<seqnum
-						<<std::endl;
+				derr_con << "(t/o=" << resend_timeout << "): "
+						 << "from_peer_id=" << peer_id
+						 << ", channel=" << ((int)channel&0xff)
+						 << ", seqnum=" << seqnum
+						 << std::endl;
 
 				rawSend(*j);
 
 				// Enlarge avg_rtt and resend_timeout:
 				// The rtt will be at least the timeout.
@@ -986,18 +994,18 @@
 	// Remove timed out peers
 	core::list<u16>::Iterator i = timeouted_peers.begin();
 	for(; i != timeouted_peers.end(); i++)
 	{
 		PrintInfo(derr_con);
-		derr_con<<"RunTimeouts(): Removing peer "<<(*i)<<std::endl;
+		derr_con << "RunTimeouts(): Removing peer " << (*i) << std::endl;
 		deletePeer(*i, true);
 	}
 }
 
 void Connection::serve(u16 port)
 {
-	dout_con<<getDesc()<<" serving at port "<<port<<std::endl;
+	dout_con << getDesc() << " serving at port " << port << std::endl;
 #ifndef SERVER
 	try{
 #endif
 	m_socket.Bind(port);
 #ifndef SERVER
@@ -1009,12 +1017,12 @@
 	m_peer_id = PEER_ID_SERVER;
 }
 
 void Connection::connect(Address address)
 {
-	dout_con<<getDesc()<<" connecting to "<<address.serializeString()
-			<<":"<<address.getPort()<<std::endl;
+	dout_con << getDesc() << " connecting to " << address.serializeString()
+			<< ":" << address.getPort() << std::endl;
 
 	core::map<u16, Peer*>::Node *node = m_peers.find(PEER_ID_SERVER);
 	if(node != NULL){
 		throw ConnectionException("Already connected to a server");
 	}
@@ -1035,11 +1043,11 @@
 	Send(PEER_ID_SERVER, 0, data, true);
 }
 
 void Connection::disconnect()
 {
-	dout_con<<getDesc()<<" disconnecting"<<std::endl;
+	dout_con << getDesc() << " disconnecting" << std::endl;
 
 	// Create and send DISCO packet
 	SharedBuffer<u8> data(2);
 	writeU8(&data[0], TYPE_CONTROL);
 	writeU8(&data[1], CONTROLTYPE_DISCO);
@@ -1066,11 +1074,11 @@
 }
 
 void Connection::send(u16 peer_id, u8 channelnum,
 		SharedBuffer<u8> data, bool reliable)
 {
-	dout_con<<getDesc()<<" sending to peer_id="<<peer_id<<std::endl;
+	dout_con << getDesc() << " sending to peer_id=" << peer_id << std::endl;
 
 	assert(channelnum < CHANNEL_COUNT);
 
 	Peer *peer = getPeerNoEx(peer_id);
 	if(peer == NULL)
@@ -1126,13 +1134,13 @@
 			channel->outgoing_reliables.insert(p);
 		}
 		catch(AlreadyExistsException &e)
 		{
 			PrintInfo(derr_con);
-			derr_con<<"WARNING: Going to send a reliable packet "
-					"seqnum="<<seqnum<<" that is already "
-					"in outgoing buffer"<<std::endl;
+			derr_con << "WARNING: Going to send a reliable packet "
+					"seqnum=" << seqnum << " that is already "
+					"in outgoing buffer" << std::endl;
 			//assert(0);
 		}
 
 		// Send the packet
 		rawSend(p);
@@ -1151,12 +1159,12 @@
 void Connection::rawSend(const BufferedPacket &packet)
 {
 	try{
 		m_socket.Send(packet.address, *packet.data, packet.data.getSize());
 	} catch(SendFailedException &e){
-		derr_con<<"Connection::rawSend(): SendFailedException: "
-				<<packet.address.serializeString()<<std::endl;
+		derr_con << "Connection::rawSend(): SendFailedException: "
+				 << packet.address.serializeString() << std::endl;
 	}
 }
 
 Peer* Connection::getPeer(u16 peer_id)
 {
@@ -1232,11 +1240,11 @@
 			channel->incoming_reliables.popFirst();
 		else
 			break;
 	}
 	// This happens if all packets are old
-	}catch(con::NotFoundException)
+	}catch(con::NotFoundException const&)
 	{}
 
 	if(channel->incoming_reliables.empty() == false)
 	{
 		if(firstseqnum == channel->next_incoming_seqnum)
@@ -1246,15 +1254,15 @@
 			peer_id = readPeerId(*p.data);
 			u8 channelnum = readChannel(*p.data);
 			u16 seqnum = readU16(&p.data[BASE_HEADER_SIZE+1]);
 
 			PrintInfo();
-			dout_con<<"UNBUFFERING TYPE_RELIABLE"
-					<<" seqnum="<<seqnum
-					<<" peer_id="<<peer_id
-					<<" channel="<<((int)channelnum&0xff)
-					<<std::endl;
+			dout_con << "UNBUFFERING TYPE_RELIABLE"
+					<< " seqnum=" << seqnum
+					<< " peer_id=" << peer_id
+					<< " channel=" << ((int)channelnum&0xff)
+					<< std::endl;
 
 			channel->next_incoming_seqnum++;
 
 			u32 headers_size = BASE_HEADER_SIZE + RELIABLE_HEADER_SIZE;
 			// Get out the inside packet and re-process it
@@ -1292,13 +1300,14 @@
 				throw InvalidIncomingDataException
 						("packetdata.getSize() < 4 (ACK header size)");
 
 			u16 seqnum = readU16(&packetdata[2]);
 			PrintInfo();
-			dout_con<<"Got CONTROLTYPE_ACK: channelnum="
-					<<((int)channelnum&0xff)<<", peer_id="<<peer_id
-					<<", seqnum="<<seqnum<<std::endl;
+			dout_con << "Got CONTROLTYPE_ACK: channelnum="
+				 << ((int)channelnum&0xff)
+				 << ", peer_id=" << peer_id
+				 << ", seqnum=" << seqnum << std::endl;
 
 			try{
 				BufferedPacket p = channel->outgoing_reliables.popSeqnum(seqnum);
 				// Get round trip time
 				float rtt = p.totaltime;
@@ -1316,13 +1325,13 @@
 				channel->outgoing_reliables.print();
 				dout_con<<std::endl;*/
 			}
 			catch(NotFoundException &e){
 				PrintInfo(derr_con);
-				derr_con<<"WARNING: ACKed packet not "
+				derr_con << "WARNING: ACKed packet not "
 						"in outgoing queue"
-						<<std::endl;
+						<< std::endl;
 			}
 
 			throw ProcessedSilentlyException("Got an ACK");
 		}
 		else if(controltype == CONTROLTYPE_SET_PEER_ID)
@@ -1330,63 +1339,63 @@
 			if(packetdata.getSize() < 4)
 				throw InvalidIncomingDataException
 						("packetdata.getSize() < 4 (SET_PEER_ID header size)");
 			u16 peer_id_new = readU16(&packetdata[2]);
 			PrintInfo();
-			dout_con<<"Got new peer id: "<<peer_id_new<<"... "<<std::endl;
+			dout_con << "Got new peer id: " << peer_id_new << "... " << std::endl;
 
 			if(GetPeerID() != PEER_ID_INEXISTENT)
 			{
 				PrintInfo(derr_con);
-				derr_con<<"WARNING: Not changing"
-						" existing peer id."<<std::endl;
+				derr_con << "WARNING: Not changing"
+						" existing peer id." << std::endl;
 			}
 			else
 			{
-				dout_con<<"changing."<<std::endl;
+				dout_con << "changing." << std::endl;
 				SetPeerID(peer_id_new);
 			}
 			throw ProcessedSilentlyException("Got a SET_PEER_ID");
 		}
 		else if(controltype == CONTROLTYPE_PING)
 		{
 			// Just ignore it, the incoming data already reset
 			// the timeout counter
 			PrintInfo();
-			dout_con<<"PING"<<std::endl;
+			dout_con << "PING" << std::endl;
 			throw ProcessedSilentlyException("Got a PING");
 		}
 		else if(controltype == CONTROLTYPE_DISCO)
 		{
 			// Just ignore it, the incoming data already reset
 			// the timeout counter
 			PrintInfo();
-			dout_con<<"DISCO: Removing peer "<<(peer_id)<<std::endl;
+			dout_con << "DISCO: Removing peer " << (peer_id) << std::endl;
 
 			if(deletePeer(peer_id, false) == false)
 			{
 				PrintInfo(derr_con);
-				derr_con<<"DISCO: Peer not found"<<std::endl;
+				derr_con << "DISCO: Peer not found" << std::endl;
 			}
 
 			throw ProcessedSilentlyException("Got a DISCO");
 		}
 		else{
 			PrintInfo(derr_con);
-			derr_con<<"INVALID TYPE_CONTROL: invalid controltype="
-					<<((int)controltype&0xff)<<std::endl;
+			derr_con << "INVALID TYPE_CONTROL: invalid controltype="
+					 << ((int)controltype&0xff) << std::endl;
 			throw InvalidIncomingDataException("Invalid control type");
 		}
 	}
 	else if(type == TYPE_ORIGINAL)
 	{
 		if(packetdata.getSize() < ORIGINAL_HEADER_SIZE)
 			throw InvalidIncomingDataException
 					("packetdata.getSize() < ORIGINAL_HEADER_SIZE");
 		PrintInfo();
-		dout_con<<"RETURNING TYPE_ORIGINAL to user"
-				<<std::endl;
+		dout_con << "RETURNING TYPE_ORIGINAL to user"
+				<< std::endl;
 		// Get the inside packet out and return it
 		SharedBuffer<u8> payload(packetdata.getSize() - ORIGINAL_HEADER_SIZE);
 		memcpy(*payload, &packetdata[ORIGINAL_HEADER_SIZE], payload.getSize());
 		return payload;
 	}
@@ -1403,16 +1412,16 @@
 		// Buffer the packet
 		SharedBuffer<u8> data = channel->incoming_splits.insert(packet, reliable);
 		if(data.getSize() != 0)
 		{
 			PrintInfo();
-			dout_con<<"RETURNING TYPE_SPLIT: Constructed full data, "
-					<<"size="<<data.getSize()<<std::endl;
+			dout_con << "RETURNING TYPE_SPLIT: Constructed full data, "
+					<< "size=" << data.getSize() << std::endl;
 			return data;
 		}
 		PrintInfo();
-		dout_con<<"BUFFERED TYPE_SPLIT"<<std::endl;
+		dout_con << "BUFFERED TYPE_SPLIT" << std::endl;
 		throw ProcessedSilentlyException("Buffered a split packet chunk");
 	}
 	else if(type == TYPE_RELIABLE)
 	{
 		// Recursive reliable packets not allowed
@@ -1427,20 +1436,20 @@
 		bool is_future_packet = seqnum_higher(seqnum, channel->next_incoming_seqnum);
 		bool is_old_packet = seqnum_higher(channel->next_incoming_seqnum, seqnum);
 
 		PrintInfo();
 		if(is_future_packet)
-			dout_con<<"BUFFERING";
+			dout_con << "BUFFERING";
 		else if(is_old_packet)
-			dout_con<<"OLD";
+			dout_con << "OLD";
 		else
-			dout_con<<"RECUR";
-		dout_con<<" TYPE_RELIABLE seqnum="<<seqnum
-				<<" next="<<channel->next_incoming_seqnum;
-		dout_con<<" [sending CONTROLTYPE_ACK"
-				" to peer_id="<<peer_id<<"]";
-		dout_con<<std::endl;
+			dout_con << "RECUR";
+		dout_con << " TYPE_RELIABLE seqnum=" << seqnum
+				<< " next=" << channel->next_incoming_seqnum;
+		dout_con << " [sending CONTROLTYPE_ACK"
+				" to peer_id=" << peer_id << "]";
+		dout_con << std::endl;
 
 		//DEBUG
 		//assert(channel->incoming_reliables.size() < 100);
 
 		// Send a CONTROLTYPE_ACK
@@ -1496,11 +1505,11 @@
 		return processPacket(channel, payload, peer_id, channelnum, true);
 	}
 	else
 	{
 		PrintInfo(derr_con);
-		derr_con<<"Got invalid type="<<((int)type&0xff)<<std::endl;
+		derr_con << "Got invalid type=" << ((int)type&0xff) << std::endl;
 		throw InvalidIncomingDataException("Invalid packet type");
 	}
 
 	// We should never get here.
 	// If you get here, add an exception or a return to some of the
@@ -1595,12 +1604,12 @@
 u32 Connection::Receive(u16 &peer_id, SharedBuffer<u8> &data)
 {
 	for(;;){
 		ConnectionEvent e = waitEvent(m_bc_receive_timeout);
 		if(e.type != CONNEVENT_NONE)
-			dout_con<<getDesc()<<": Receive: got event: "
-					<<e.describe()<<std::endl;
+			dout_con << getDesc() << ": Receive: got event: "
+					<<e.describe() << std::endl;
 		switch(e.type){
 		case CONNEVENT_NONE:
 			throw NoIncomingDataException("No incoming data");
 		case CONNEVENT_DATA_RECEIVED:
 			peer_id = e.peer_id;
diff -rU5 voxelands-v1709.00old/src/content_cao.cpp voxelands-v1709.00good/src/content_cao.cpp
--- voxelands-v1709.00old/src/content_cao.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_cao.cpp	2024-06-09 14:17:57.623794190 +0200
@@ -74,24 +74,25 @@
 {
 	if (m_node != NULL)
 		return;
 
 	video::IVideoDriver* driver = smgr->getVideoDriver();
-	MobFeatures m = content_mob_features(m_content);
+	MobFeatures& m = content_mob_features(m_content);
+	
 	if (m.texture_display == MDT_EXTRUDED) {
 		ExtrudedSpriteSceneNode *node = new ExtrudedSpriteSceneNode(smgr->getRootSceneNode(),smgr,-1,v3f(0,0,0),v3f(0,0,0),v3f(5,5,5));
 		node->setVisible(true);
 		node->setSprite(g_texturesource->getTextureRaw(m.texture));
 		m_node = (scene::IMeshSceneNode*)node;
 		m_draw_type = MDT_EXTRUDED;
 		updateNodePos();
 	}else if (m.model != "") {
-		scene::IAnimatedMesh* mesh = createModelMesh(smgr,m.model.c_str(),true);
+		scene::IAnimatedMesh* const mesh = createModelMesh(smgr,m.model.c_str(),true);
 		if (!mesh)
 			return;
 
-		scene::IAnimatedMeshSceneNode* node = smgr->addAnimatedMeshSceneNode(mesh);
+		scene::IAnimatedMeshSceneNode* const node = smgr->addAnimatedMeshSceneNode(mesh);
 
 		if (node) {
 			int s;
 			int e;
 			char buff[1024];
@@ -155,11 +156,12 @@
 		m_node = NULL;
 	}
 }
 void MobCAO::updateLight(u8 light_at_pos)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
+	
 	if (m.glow_light)
 		light_at_pos = m.glow_light;
 	if (m_shooting && m.attack_glow_light)
 		light_at_pos = m.attack_glow_light;
 
@@ -206,11 +208,11 @@
 void MobCAO::step(float dtime, ClientEnvironment *env)
 {
 	if (!m_node)
 		return;
 
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 
 	pos_translator.translate(dtime);
 
 	updateNodePos();
 
@@ -270,11 +272,13 @@
 	if (!m.moves_silently && m_walking && m_draw_type == MDT_MODEL) {
 		m_last_step += dtime;
 		/* roughly sort of when a step sound should probably be heard, maybe */
 		if (m_last_step > 0.5) {
 			m_last_step -= 0.5;
+#if USE_AUDIO == 1
 			sound_play_step(&env->getMap(),m_position,m_next_foot, 0.3);
+#endif
 			m_next_foot = !m_next_foot;
 		}
 	}
 }
 void MobCAO::processMessage(const std::string &data)
@@ -357,11 +361,11 @@
 
 	updateNodePos();
 }
 bool MobCAO::directReportPunch(content_t punch_item, v3f dir)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	if (m.punch_action == MPA_IGNORE)
 		return false;
 
 	ToolItemFeatures f = content_toolitem_features(punch_item);
 	if (m.special_dropped_item != CONTENT_IGNORE && (m.special_punch_item == TT_NONE || f.type == m.special_punch_item))
diff -rU5 voxelands-v1709.00old/src/content_mob.cpp voxelands-v1709.00good/src/content_mob.cpp
--- voxelands-v1709.00old/src/content_mob.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_mob.cpp	2024-06-09 13:17:14.657158375 +0200
@@ -31,17 +31,18 @@
 #include "profiler.h"
 #include "intl.h"
 
 MobFeatures g_content_mob_features[CONTENT_MOB_COUNT];
 
-MobFeatures & content_mob_features(content_t c)
+MobFeatures& content_mob_features(content_t c)
 {
 	static MobFeatures ignore = MobFeatures();
-	if ((c&CONTENT_MOB_MASK) != CONTENT_MOB_MASK)
+	
+	if ((c & CONTENT_MOB_MASK) != CONTENT_MOB_MASK)
 		return ignore;
 
-	u16 i = (c&~CONTENT_MOB_MASK);
+	u16 i = (c & ~CONTENT_MOB_MASK) - 1;
 
 	if (i >= CONTENT_MOB_COUNT)
 		return ignore;
 
 	if (g_content_mob_features[i].content != c)
@@ -60,10 +61,11 @@
 		tiles[i].alpha = alpha;
 		tiles[i].material_type = MATERIAL_ALPHA_VERTEX;
 	}
 }
 #endif
+
 void MobFeatures::getAnimationFrames(MobAnimation type, int *start, int *end)
 {
 	*start = 0;
 	*end = 0;
 	switch (type) {
@@ -131,30 +133,29 @@
 
 	if ((c1 != CONTENT_AIR && c1 != CONTENT_WATERSOURCE) && c1 != c2)
 		return false;
 
 	for (u16 i=0; i<CONTENT_MOB_COUNT; i++) {
-		MobFeatures m = g_content_mob_features[i];
+		const MobFeatures& m = g_content_mob_features[i];
 		if (m.spawn_min_height > pos.Y)
 			continue;
 		if (m.spawn_max_height < pos.Y)
 			continue;
-		if (m.spawn_chance > 1 && rand%m.spawn_chance != 0)
+		if (m.spawn_chance > 1 && rand % m.spawn_chance != 0)
 			continue;
 		can.push_back(i);
 	}
 
 	if (can.size() == 0)
 		return false;
 
-	MobFeatures m;
 	u32 index = 0;
 
 	if (can.size() > 1)
 		index = myrand_range(0,can.size()-1);
 
-	m = g_content_mob_features[can[index]];
+	const MobFeatures& m = g_content_mob_features[can[index]];
 
 	if (m.content == CONTENT_IGNORE)
 		return false;
 
 	v3f p = intToFloat(pos+v3s16(0,1,0), BS);
@@ -172,12 +173,11 @@
 	return true;
 }
 
 void mob_spawn(v3s16 pos, content_t mob, ServerEnvironment *env)
 {
-
-	MobFeatures &m = content_mob_features(mob);
+	const MobFeatures& m = content_mob_features(mob);
 
 	if (m.content == CONTENT_IGNORE)
 		return;
 	if (!config_get_bool("world.game.mob.spawn.natural"))
 		return;
@@ -198,11 +198,11 @@
 void mob_spawn_passive(v3s16 pos, bool water, ServerEnvironment *env)
 {
 	std::vector<content_t> can;
 	int rand = myrand();
 	for (u16 i=0; i<CONTENT_MOB_COUNT; i++) {
-		MobFeatures m = g_content_mob_features[i];
+		const MobFeatures& m = g_content_mob_features[i];
 		if (!m.spawn_naturally)
 			continue;
 		if (m.level > MOB_PASSIVE)
 			continue;
 		if (m.spawn_water != water)
@@ -213,17 +213,16 @@
 	}
 
 	if (can.size() == 0)
 		return;
 
-	MobFeatures m;
 	u32 index = 0;
 
 	if (can.size() > 1)
 		index = myrand_range(0,can.size()-1);
 
-	m = g_content_mob_features[can[index]];
+	const MobFeatures& m = g_content_mob_features[can[index]];
 
 	if (m.content == CONTENT_IGNORE)
 		return;
 
 	v3s16 spots[9] = {
@@ -277,11 +276,11 @@
 	std::vector<content_t> can;
 	u8 level = mobLevelI(config_get("world.game.mob.spawn.level"));
 	if (level < MOB_AGGRESSIVE)
 		return;
 	for (u16 i=0; i<CONTENT_MOB_COUNT; i++) {
-		MobFeatures m = g_content_mob_features[i];
+		const MobFeatures& m = g_content_mob_features[i];
 		if (!m.spawn_naturally)
 			continue;
 		if (m.level < MOB_AGGRESSIVE)
 			continue;
 		if (m.level > level)
@@ -292,17 +291,16 @@
 	}
 
 	if (can.size() == 0)
 		return;
 
-	MobFeatures m;
 	u32 index = 0;
 
 	if (can.size() > 1)
 		index = myrand_range(0,can.size()-1);
 
-	m = g_content_mob_features[can[index]];
+	const MobFeatures& m = g_content_mob_features[can[index]];
 
 	if (m.content == CONTENT_IGNORE)
 		return;
 
 	v3s16 spots[9] = {
@@ -356,11 +354,12 @@
 {
 	content_t i;
 	MobFeatures *f = NULL;
 
 	i = CONTENT_MOB_RAT;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Rat");
 	f->level = MOB_PASSIVE;
 	f->model = "rat.x";
 	f->setTexture("mob_rat.png");
@@ -375,11 +374,12 @@
 	f->spawn_naturally = true;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_FIREFLY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Firefly");
 	f->level = MOB_PASSIVE;
 	f->model_scale = v3f(0.5,0.5,0.5);
 	f->setTexture("mob_firefly.png");
@@ -394,11 +394,12 @@
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/4.,-BS/6.,-BS/4., BS/4.,BS/6.,BS/4.));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_OERKKI;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Oerkki");
 	f->level = MOB_AGGRESSIVE;
 	f->model = "oerkki.x";
 	f->model_scale = v3f(4,4,4);
@@ -415,11 +416,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS*2.,BS/3.));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_DUNGEON_MASTER;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Dungeon Master");
 	f->level = MOB_DESTRUCTIVE;
 	f->model = "dungeon_master.b3d";
 	f->model_rotation = v3f(0,-90,0);
@@ -436,11 +438,12 @@
 	f->attack_throw_offset = v3f(0,1.4,-1.0);
 	f->setCollisionBox(aabb3f(-0.75*BS, 0.*BS, -0.75*BS, 0.75*BS, 2.0*BS, 0.75*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_FIREBALL;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Fireball");
 	f->level = MOB_DESTRUCTIVE;
 	f->setTexture("mob_fireball.png");
 	f->punch_action = MPA_IGNORE;
@@ -453,11 +456,12 @@
 	f->contact_explosion_diameter = 3;
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 
 	i = CONTENT_MOB_DOE;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Doe");
 	f->level = MOB_PASSIVE;
 	f->hp = 30;
 	f->model = "doe.x";
@@ -480,11 +484,12 @@
 	f->spawn_group = 3;
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_STAG;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Stag");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 40;
 	f->model = "stag.x";
@@ -509,11 +514,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.7*BS, 0., -0.7*BS, 0.7*BS, 1.5*BS, 0.7*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_TAMESTAG;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Stag");
 	f->level = MOB_PASSIVE;
 	f->hp = 40;
 	f->model = "stag.b3d";
@@ -532,11 +538,12 @@
 	f->sound_random = "mob-deer-env";
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-0.7*BS, 0., -0.7*BS, 0.7*BS, 1.5*BS, 0.7*BS));
 
 	i = CONTENT_MOB_FISH;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Fish");
 	f->level = MOB_PASSIVE;
 	f->model = "fish.b3d";
 	f->model_rotation = v3f(0,-90,0);
@@ -558,11 +565,12 @@
 	f->hp = 5;
 	f->setCollisionBox(aabb3f(-0.25*BS, 0.25*BS, -0.25*BS, 0.25*BS, 0.75*BS, 0.25*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SHARK;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Shark");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 40;
 	f->model = "shark.b3d";
@@ -583,11 +591,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.75*BS, 0., -0.75*BS, 0.75*BS, 1.*BS, 0.75*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_WOLF;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Wolf");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 40;
 	f->model = "wolf.b3d";
@@ -611,11 +620,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.5*BS, 0., -0.5*BS, 0.5*BS, 1.*BS, 0.5*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_TAMEWOLF;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Tame Wolf");
 	f->level = MOB_PASSIVE;
 	f->hp = 40;
 	f->model = "wolf.b3d";
@@ -637,11 +647,12 @@
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-0.5*BS, 0., -0.5*BS, 0.5*BS, 1.*BS, 0.5*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SHEEP;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Sheep");
 	f->level = MOB_PASSIVE;
 	f->hp = 30;
 	f->model = "sheep.b3d";
@@ -669,11 +680,12 @@
 	f->spawn_group = 4;
 	f->setCollisionBox(aabb3f(-0.4*BS, 0., -0.4*BS, 0.4*BS, 1.*BS, 0.4*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SHEARED_SHEEP;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Sheared Sheep");
 	f->level = MOB_PASSIVE;
 	f->hp = 30;
 	f->model = "sheared_sheep.b3d";
@@ -694,11 +706,12 @@
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-0.4*BS, 0., -0.4*BS, 0.4*BS, 1.*BS, 0.4*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SNOWBALL;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Snowball");
 	f->level = MOB_AGGRESSIVE;
 	f->setTexture("snow_ball.png");
 	f->model_offset = v3f(0,0.2,0);
@@ -712,11 +725,12 @@
 	f->contact_drop_item = CONTENT_CRAFTITEM_SNOW_BALL;
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 
 	i = CONTENT_MOB_ARROW;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Arrow");
 	f->level = MOB_AGGRESSIVE;
 	f->setTexture("mob_arrow.png");
 	f->texture_display = MDT_EXTRUDED;
@@ -730,11 +744,12 @@
 	f->contact_drop_item = CONTENT_CRAFTITEM_ARROW;
 	f->spawn_naturally = false;
 	f->setCollisionBox(aabb3f(-BS/3.,0.0,-BS/3., BS/3.,BS/2.,BS/3.));
 
 	i = CONTENT_MOB_GREY_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Grey Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
@@ -757,11 +772,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_WHITE_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("White Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
@@ -784,11 +800,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_SIAMESE_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Siamese Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
@@ -811,11 +828,12 @@
 	f->attack_player_range = v3f(1,1,1);
 	f->setCollisionBox(aabb3f(-0.6*BS, 0., -0.6*BS, 0.6*BS, 1.25*BS, 0.6*BS));
 	content_list_add("creative",CONTENT_TOOLITEM_MOB_SPAWNER,1,i);
 
 	i = CONTENT_MOB_GINGER_KITTY;
-	f = &g_content_mob_features[i&~CONTENT_MOB_MASK];
+	f = &g_content_mob_features[(i & ~CONTENT_MOB_MASK) - 1];
+	new(f) MobFeatures;
 	f->content = i;
 	f->description = gettext("Ginger Kitten");
 	f->level = MOB_AGGRESSIVE;
 	f->hp = 30;
 	f->model = "kitty.b3d";
diff -rU5 voxelands-v1709.00old/src/content_mob.h voxelands-v1709.00good/src/content_mob.h
--- voxelands-v1709.00old/src/content_mob.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_mob.h	2024-06-09 13:17:14.657158375 +0200
@@ -86,13 +86,14 @@
 };
 
 
 #define CONTENT_MOB_MASK 0x2000
 
-struct MobFeatures {
+class MobFeatures {
+    public:
 	content_t content;
-	char* description;
+	const char* description;
 	u8 level;
 #ifndef SERVER
 	TileSpec tiles[6];
 #endif
 	std::string texture;
@@ -148,45 +149,54 @@
 	MobFeatures()
 	{
 		reset();
 	}
 
+	MobFeatures(const MobFeatures& m)
+	{
+		copie(m);
+	}
+	
+	MobFeatures& operator=(const MobFeatures& m)
+	{
+		copie(m);
+		return *this;
+	}
+	
 	void setCollisionBox(aabb3f cb)
 	{
 		cb.MinEdge.Y -= 0.5*BS;
 		cb.MaxEdge.Y -= 0.5*BS;
 		collisionbox = cb;
 	}
 
-	aabb3f getCollisionBox()
+	aabb3f getCollisionBox() const
 	{
 		if (collisionbox.MinEdge != collisionbox.MaxEdge)
 			return collisionbox;
 		return aabb3f(-0.5*BS,0.,-0.5*BS,0.5*BS,BS,0.5*BS);
 	}
 
-	v3f getSize()
+	v3f getSize() const
 	{
 		aabb3f c = getCollisionBox();
 		return v3f((c.MaxEdge.X-c.MinEdge.X)/BS,(c.MaxEdge.Y-c.MinEdge.Y)/BS,(c.MaxEdge.Z-c.MinEdge.Z)/BS);
 	}
 
-	v3s16 getSizeBlocks()
+	v3s16 getSizeBlocks() const
 	{
 		v3f s = getSize();
 		return v3s16(MYMAX(s.X+0.5,1.0),MYMAX(s.Y+0.5,1.0),MYMAX(s.Z+0.5,1.0));
 	}
 
 	void getAnimationFrames(MobAnimation type, int *start, int *end);
 	void setAnimationFrames(MobAnimation type, int start, int end);
 	void setTexture(std::string name) {texture = name;}
 
 #ifdef SERVER
-	void setBoxTexture(u16 i, std::string name, u8 alpha=255)
-	{}
-	void setAllBoxTextures(std::string name, u8 alpha=255)
-	{}
+	void setBoxTexture(u16 i, std::string name, u8 alpha=255) {}
+	void setAllBoxTextures(std::string name, u8 alpha=255) {}
 #else
 	void setBoxTexture(u16 i, std::string name, u8 alpha=255);
 
 	void setAllBoxTextures(std::string name, u8 alpha=255)
 	{
@@ -194,20 +204,20 @@
 			setBoxTexture(i, name, alpha);
 		}
 	}
 #endif
 
+    private:
+	
 	void reset()
 	{
-		content = CONTENT_IGNORE;
-		description = (char*)"";
-		texture = "";
-		texture_display = MDT_AUTO;
-		model = "";
-		model_scale = v3f(1.0,1.0,1.0);
-		model_offset = v3f(0,0,0);
+		content = CONTENT_IGNORE;description = "";level = MOB_NONE;
+		texture = "";texture_display = MDT_AUTO;
+		model = "";model_scale = v3f(1.0,1.0,1.0);model_offset = v3f(0,0,0);
 		model_rotation = v3f(0,0,0);
+		collisionbox = aabb3f(-0.5*BS,0.,-0.5*BS,0.5*BS,BS,0.5*BS);
+		
 		punch_action = MPA_DIE;
 		motion_type = MMT_WALK;
 		motion = MM_STATIC;
 		angry_motion = MM_STATIC;
 		static_thrown_speed = 20.0;
@@ -229,23 +239,68 @@
 		special_dropped_max = 0;
 		contact_explosion_diameter = 0;
 		contact_place_node = CONTENT_IGNORE;
 		contact_drop_item = CONTENT_IGNORE;
 		moves_silently = false;
+		
 		sound_spawn = "";
 		sound_death = "";
 		sound_attack = "";
 		sound_punch = "mob-dig";
 		sound_random = "";
 		sound_random_extra = "";
+		
 		spawn_min_height = -20000;
 		spawn_max_height = 100;
 		spawn_chance = 1;
 		spawn_group = 1;
 		spawn_water = false;
+		
 		spawn_naturally = true;
 	}
+
+	void copie(const MobFeatures& m)
+	{
+		content = m.content;description = m.description;level = m.level;
+		texture = m.texture;texture_display = m.texture_display;
+		model = m.model;model_scale = m.model_scale;
+		model_offset = m.model_offset;model_rotation = m.model_rotation;
+		collisionbox = m.collisionbox;
+		
+		punch_action = m.punch_action;motion_type = m.motion_type;motion = m.motion;
+		angry_motion = m.angry_motion;
+		static_thrown_speed = m.static_thrown_speed;
+		follow_item = m.follow_item;tamed_mob = m.tamed_mob;
+		attack_throw_object = m.attack_throw_object;
+		attack_throw_offset = m.attack_throw_offset;
+		attack_player_damage = m.attack_player_damage;
+		attack_player_range = m.attack_player_range;
+		attack_mob_damage = m.attack_mob_damage;
+		attack_mob_range = m.attack_mob_range;
+		glow_light = m.glow_light;attack_glow_light = m.attack_glow_light;
+		hp = m.hp;dropped_item = m.dropped_item;
+		special_punch_item = m.special_punch_item;
+		special_dropped_item = m.special_dropped_item;
+		special_dropped_count = m.special_dropped_count;
+		special_dropped_max = m.special_dropped_max;
+		contact_explosion_diameter = m.contact_explosion_diameter;
+		contact_place_node = m.contact_place_node;
+		contact_drop_item = m.contact_drop_item;
+		moves_silently = m.moves_silently;
+		
+		sound_spawn = m.sound_spawn;sound_death = m.sound_death;
+		sound_attack = m.sound_attack;sound_punch = m.sound_punch;
+		sound_random = m.sound_random;sound_random_extra = m.sound_random_extra;
+		
+		spawn_min_height = m.spawn_min_height;
+		spawn_max_height = m.spawn_max_height;
+		spawn_chance = m.spawn_chance;
+		spawn_group = m.spawn_group;
+		spawn_water = m.spawn_water;
+		
+		spawn_naturally = m.spawn_naturally;
+	}
 };
 
 inline u8 mobLevelI(std::string level)
 {
 	if (level == "destructive")
@@ -297,8 +352,8 @@
 #define CONTENT_MOB_SIAMESE_KITTY (CONTENT_MOB_MASK | 0x12)
 #define CONTENT_MOB_GINGER_KITTY (CONTENT_MOB_MASK | 0x13)
 #define CONTENT_MOB_SHEARED_SHEEP (CONTENT_MOB_MASK | 0x14)
 
 // increment me if you add a mob!
-#define CONTENT_MOB_COUNT 21
+#define CONTENT_MOB_COUNT 20
 
 #endif
diff -rU5 voxelands-v1709.00old/src/content_sao.cpp voxelands-v1709.00good/src/content_sao.cpp
--- voxelands-v1709.00old/src/content_sao.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/content_sao.cpp	2024-06-09 13:17:14.657158375 +0200
@@ -94,10 +94,11 @@
 	m_hp(10),
 	m_angry(false),
 	m_special_count(0),
 	m_tamed_chance(0),
 	m_disturb_timer(100000),
+	m_disturbing_player(),
 	m_random_disturb_timer(0),
 	m_walk_around(false),
 	m_walk_around_timer(0),
 	m_shoot_reload_timer(0),
 	m_shooting(false),
@@ -125,10 +126,11 @@
 	m_hp(10),
 	m_angry(false),
 	m_special_count(0),
 	m_tamed_chance(0),
 	m_disturb_timer(100000),
+	m_disturbing_player(),
 	m_random_disturb_timer(0),
 	m_walk_around(false),
 	m_walk_around_timer(0),
 	m_shoot_reload_timer(0),
 	m_shooting(false),
@@ -205,11 +207,11 @@
 	writeU8(os,(u8)m_shooting);
 	return os.str();
 }
 void MobSAO::step(float dtime, bool send_recommended)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	Player *disturbing_player = NULL;
 	v3f disturbing_player_off = v3f(0,1,0);
 	v3f disturbing_player_norm = v3f(0,1,0);
 	float disturbing_player_distance = 1000000;
 	float disturbing_player_dir = 0;
@@ -540,11 +542,11 @@
 	if (m_base_position.getDistanceFrom(m_last_sent_position) > 0.5*BS)
 		sendPosition();
 }
 void MobSAO::stepMotionWander(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 	v3s16 pos_size_off(0,0,0);
 
 	if (m.motion_type == MMT_WALK) {
 		if (!m_next_pos_exists) {
@@ -704,11 +706,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionSeeker(float dtime, float offset)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 	Player *disturbing_player = m_env->getPlayer(m_disturbing_player.c_str());
 	if (!disturbing_player) {
 		m_next_pos_exists = false;
 		return;
@@ -900,11 +902,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionFlee(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 	Player *disturbing_player = m_env->getPlayer(m_disturbing_player.c_str());
 	if (!disturbing_player) {
 		m_next_pos_exists = false;
 		return;
@@ -1073,11 +1075,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionSentry(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	v3s16 pos_i = floatToInt(m_base_position, BS);
 
 	if (m.motion_type == MMT_WALK) {
 		if (!m_next_pos_exists) {
 			/* Check whether to drop down */
@@ -1212,11 +1214,11 @@
 		}
 	}
 }
 void MobSAO::stepMotionThrown(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	m_base_position += m_speed * dtime;
 	m_speed.Y -= 10.0*BS*dtime;
 
 	m_yaw = wrapDegrees_180(180./PI*atan2(m_speed.Z, m_speed.X));
 
@@ -1239,11 +1241,12 @@
 		return;
 	}
 }
 void MobSAO::stepMotionConstant(float dtime)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
+	
 	m_base_position += m_speed * dtime;
 
 	m_yaw = wrapDegrees_180(180./PI*atan2(m_speed.Z, m_speed.X));
 
 	v3s16 pos_i = floatToInt(m_base_position, BS);
@@ -1341,12 +1344,13 @@
 	}
 	map->dispatchEvent(&event);
 }
 InventoryItem* MobSAO::createPickedUpItem(content_t punch_item)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	ToolItemFeatures f = content_toolitem_features(punch_item);
+	
 	if (m.punch_action != MPA_PICKUP) {
 		if (!m_removed) {
 			if (m.special_dropped_item != CONTENT_IGNORE && (m.special_punch_item == TT_NONE || f.type == m.special_punch_item)) {
 				if (m.special_dropped_max > 0) {
 					if (m_special_count < m.special_dropped_count)
@@ -1372,11 +1376,12 @@
 		m_removed = true;
 	return item;
 }
 u16 MobSAO::punch(content_t punch_item, v3f dir, const std::string &playername)
 {
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
+	
 	if (m.sound_punch != "")
 		m_env->addEnvEvent(ENV_EVENT_SOUND,m_base_position,m.sound_punch);
 	if (m.punch_action == MPA_IGNORE)
 		return 0;
 	ToolItemFeatures f = content_toolitem_features(punch_item);
@@ -1437,11 +1442,11 @@
 {
 	// so get the player
 	if (!player)
 		return false;
 	// see if mob is tamable
-	MobFeatures m = content_mob_features(m_content);
+	const MobFeatures& m = content_mob_features(m_content);
 	if (m.tamed_mob == CONTENT_IGNORE)
 		return false;
 	// get the wielded item
 	u16 item_i = player->getSelectedItem();
 	InventoryList *ilist = player->inventory.getList("main");
diff -rU5 voxelands-v1709.00old/src/crypto_base64.c voxelands-v1709.00good/src/crypto_base64.c
--- voxelands-v1709.00old/src/crypto_base64.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/crypto_base64.c	2024-06-09 13:17:14.657158375 +0200
@@ -184,11 +184,11 @@
 
 		/* convert the characters */
 		tmplen = s_base64_decode_triple((unsigned char*)quadruple, (unsigned char*)tmpresult);
 
 		/* check if the fit in the result buffer */
-		if (targetlen < tmplen) {
+		if (targetlen < (size_t) tmplen) {
 			free(src);
 			return -1;
 		}
 
 		/* put the partial result in the result buffer */
diff -rU5 voxelands-v1709.00old/src/environment.cpp voxelands-v1709.00good/src/environment.cpp
--- voxelands-v1709.00old/src/environment.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/environment.cpp	2024-06-09 13:17:14.658158668 +0200
@@ -397,11 +397,13 @@
 			player->serialize(os);
 			nvp_set(&saved_players, (char*)player->getName(), (char*)player->getName(), player);
 		}
 		list_file = list_file->next;
 	}
-
+	
+	path_dirlist_free(list);
+	
 	for (i=0; i<m_players->length; i++) {
 		player = (Player*)array_get_ptr(m_players,i);
 		if (!player)
 			continue;
 		if (nvp_get(&saved_players, (char*)player->getName()) != NULL)
@@ -425,11 +427,10 @@
 			nvp_set(&saved_players, (char*)player->getName(), (char*)player->getName(), player);
 		}
 	}
 
 	nvp_free(&saved_players,0);
-
 }
 
 void ServerEnvironment::deSerializePlayers()
 {
 
@@ -3116,10 +3117,14 @@
 			send_recommended = true;
 		}
 
 		for (std::map<u16, ServerActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++) {
 			ServerActiveObject* obj = i->second;
+
+			if(!obj)
+			    continue;
+			
 			// Remove non-peaceful mobs on peaceful mode
 			if (obj->level() > mob_level)
 				obj->m_removed = true;
 			// Don't step if is to be removed or stored statically
 			if (obj->m_removed)
@@ -3163,14 +3168,17 @@
 void ServerEnvironment::getActiveObjects(v3f origin, f32 max_d, core::array<DistanceSortedActiveObject> &dest)
 {
 	for (std::map<u16, ServerActiveObject*>::iterator i = m_active_objects.begin(); i != m_active_objects.end(); i++) {
 		ServerActiveObject* obj = i->second;
 
+		if(!obj)
+		    continue;
+		
 		f32 d = (obj->getBasePosition() - origin).getLength();
 
 		if (d > max_d)
-			continue;
+		    continue;
 
 		DistanceSortedActiveObject dso(obj, d);
 
 		dest.push_back(dso);
 	}
diff -rU5 voxelands-v1709.00old/src/environment.h voxelands-v1709.00good/src/environment.h
--- voxelands-v1709.00old/src/environment.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/environment.h	2024-06-09 13:17:14.658158668 +0200
@@ -198,11 +198,11 @@
 		m_time = t;
 	}
 
 	u32 getSeason()
 	{
-		char* s = config_get("world.game.environment.season");
+		const char* s = config_get("world.game.environment.season");
 		if (s) {
 			if (!strcmp(s,"summer"))
 				return ENV_SEASON_SUMMER;
 			if (!strcmp(s,"autumn") || !strcmp(s,"fall"))
 				return ENV_SEASON_AUTUMN;
diff -rU5 voxelands-v1709.00old/src/file.c voxelands-v1709.00good/src/file.c
--- voxelands-v1709.00old/src/file.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/file.c	2024-06-09 13:17:14.658158668 +0200
@@ -48,15 +48,15 @@
 
 	return inc;
 }
 
 /* load a file into memory */
-file_t *file_load(char* type, char* name)
+file_t *file_load(const char* type,const char* name)
 {
 	file_t *ft;
 	FILE *f;
-	char* fn;
+	const char* fn;
 	char* path;
 
 	if (type) {
 		fn = name;
 		path = path_get(type,name,1,NULL,0);
@@ -99,11 +99,11 @@
 		fclose(f);
 		free(ft);
 		return NULL;
 	}
 
-	if (ft->len != fread(ft->data, 1, ft->len, f)) {
+	if ((size_t) ft->len != fread(ft->data, 1, ft->len, f)) {
 		free(path);
 		fclose(f);
 		free(ft->data);
 		free(ft);
 		return NULL;
@@ -119,14 +119,14 @@
 
 	return ft;
 }
 
 /* load a file into memory */
-file_t *file_create(char* type, char *name)
+file_t *file_create(const char* type,const char *name)
 {
 	file_t *ft;
-	char* fn;
+	const char* fn;
 	char* path;
 
 	if (name) {
 		if (type) {
 			fn = name;
@@ -193,11 +193,11 @@
 	f = fopen(file->path, "wb");
 	if (!f)
 		return;
 
 	if (file->len) {
-		if (fwrite(file->data,1,file->len,f) != file->len) {
+	    if (fwrite(file->data,1,file->len,f) != (size_t) file->len) {
 			fclose(f);
 			return;
 		}
 	}
 
@@ -380,11 +380,11 @@
 {
 	return file->data+file->pos;
 }
 
 /* write data to a file buffer */
-int file_write(file_t *file, void *buff, int size)
+int file_write(file_t *file,const void *buff, int size)
 {
 	if (!file || !buff || size)
 		return -1;
 
 	if (file->size <= (file->pos+size+1)) {
@@ -407,11 +407,11 @@
 
 	return size;
 }
 
 /* write a formatted string to a file buffer (printf style) */
-int file_writef(file_t *file, char* fmt, ...)
+int file_writef(file_t *file,const char* fmt, ...)
 {
 	va_list ap;
 	int l;
 	int s;
 	if (!file)
diff -rU5 voxelands-v1709.00old/src/file.h voxelands-v1709.00good/src/file.h
--- voxelands-v1709.00old/src/file.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/file.h	2024-06-09 13:17:14.658158668 +0200
@@ -22,12 +22,12 @@
 	int modified;
 } file_t;
 #endif
 
 /* defined in file.c */
-file_t *file_load(char* type, char *name);
-file_t *file_create(char* type, char *name);
+file_t *file_load(const char* type,const char *name);
+file_t *file_create(const char* type,const char *name);
 void file_free(file_t *file);
 void file_flush(file_t *file);
 int file_find(file_t *file, int offset, unsigned char value);
 int file_strfind(file_t *file, int offset, char* value);
 int file_read(file_t *file, void* dst, int size);
@@ -38,12 +38,12 @@
 uint32_t file_read_uint(file_t *file);
 float file_read_float(file_t *file);
 int file_seek(file_t *file, int offset, int origin);
 int file_tell(file_t *file);
 void *file_get(file_t *file);
-int file_write(file_t *file, void *buff, int size);
-int file_writef(file_t *file, char* fmt, ...);
+int file_write(file_t *file,const  void *buff, int size);
+int file_writef(file_t *file,const char* fmt, ...);
 
 #ifdef __cplusplus
 }
 #endif
 
diff -rU5 voxelands-v1709.00old/src/game.cpp voxelands-v1709.00good/src/game.cpp
--- voxelands-v1709.00old/src/game.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/game.cpp	2024-06-09 13:17:14.659158961 +0200
@@ -749,11 +749,11 @@
 		Create server.
 		SharedPtr will delete it when it goes out of scope.
 	*/
 	SharedPtr<Server> server;
 	{
-		char* v = config_get("world.server.address");
+		const char* v = config_get("world.server.address");
 		if (!v || !v[0]) {
 			//draw_load_screen(L"Creating server...", driver, font);
 			drawLoadingScreen(device,narrow_to_wide(gettext("Creating server...")));
 			infostream<<"Creating server"<<std::endl;
 			server = new Server();
@@ -776,11 +776,11 @@
 	port = config_get_int("world.server.port");
 	if (!port)
 		port = 30000;
 	Address connect_address(0,0,0,0, port);
 	try{
-		char* v = config_get("world.server.address");
+		const char* v = config_get("world.server.address");
 		if (!v || !v[0]) {
 			connect_address.setAddress(127,0,0,1);
 		}else{
 			connect_address.Resolve(v);
 		}
@@ -925,11 +925,11 @@
 	show_debug = config_get_bool("debug.show");
 	fps_max = config_get_float("client.graphics.fps.max");
 	profiler_print_interval = config_get_float("debug.profiler.interval");
 	mouse_sensitivity = config_get_float("client.ui.mouse.sensitivity");
 	{
-		char* v = config_get("client.graphics.selection");
+		const char* v = config_get("client.graphics.selection");
 		if (v && !strcmp(v,"outline"))
 			highlight_selected_node = false;
 	}
 	enable_particles = config_get_bool("client.graphics.particles");
 	enable_fog = config_get_bool("client.graphics.light.fog");
@@ -1139,11 +1139,11 @@
 			Launch menus according to keys
 		*/
 		if (input->wasKeyDown(getKeySetting(VLKC_INVENTORY))) {
 			infostream<<"the_game: Launching inventory"<<std::endl;
 
-			GUIFormSpecMenu *menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+			GUIFormSpecMenu* const menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
 
 			InventoryLocation inventoryloc;
 			inventoryloc.setCurrentPlayer();
 
 			PlayerInventoryFormIO *fio = new PlayerInventoryFormIO(&client);
@@ -1475,11 +1475,11 @@
 					if (event.player_damage.amount >= 2) {
 						damage_flash_timer += 0.05 * event.player_damage.amount;
 					}
 #if USE_AUDIO == 1
 					{
-						char* v;
+						const char* v;
 						std::string ch = std::string(PLAYER_DEFAULT_CHARDEF);
 						v = config_get("client.character");
 						if (v)
 							ch = v;
 						Strfnd f(ch);
@@ -1494,14 +1494,14 @@
 					camera_pitch = event.player_force_move.pitch;
 				}else if (event.type == CE_DEATHSCREEN) {
 					if (respawn_menu_active)
 						continue;
 
-					MainRespawnInitiator *respawner =
+					MainRespawnInitiator* const respawner =
 							new MainRespawnInitiator(
 									&respawn_menu_active, &client);
-					GUIDeathScreen *menu =
+					GUIDeathScreen* const menu =
 							new GUIDeathScreen(guienv, guiroot, -1,
 								&g_menumgr, respawner);
 					menu->drop();
 
 					/* Handle visualization */
@@ -1756,11 +1756,12 @@
 							InventoryLocation inventoryloc;
 							inventoryloc.setNodeMeta(nodepos);
 
 							/* Create menu */
 
-							GUIFormSpecMenu *menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+							GUIFormSpecMenu* const menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+							
 							menu->setFormSpec(meta->getDrawSpecString(client.getLocalPlayer()), inventoryloc);
 							menu->setFormIO(new NodeMetadataFormIO(nodepos, &client));
 							menu->drop();
 							{
 								std::string sound = content_features(client.getEnv().getMap().getNodeNoEx(nodepos).getContent()).sound_access;
@@ -1781,11 +1782,13 @@
 									InventoryLocation inventoryloc;
 									inventoryloc.setNodeMeta(nodepos);
 
 									/* Create menu */
 
-									GUIFormSpecMenu *menu = new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+									GUIFormSpecMenu* const menu =
+									    new GUIFormSpecMenu(guienv, guiroot, -1, &g_menumgr, &client);
+									
 									menu->setFormSpec(ameta->getDrawSpecString(client.getLocalPlayer()), inventoryloc);
 									menu->setFormIO(new NodeMetadataFormIO(npos, &client));
 									menu->drop();
 									{
 										std::string sound = content_features(nn.getContent()).sound_access;
diff -rU5 voxelands-v1709.00old/src/game.h voxelands-v1709.00good/src/game.h
--- voxelands-v1709.00old/src/game.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/game.h	2024-06-09 13:17:14.659158961 +0200
@@ -37,11 +37,11 @@
 class KeyList : protected core::list<KeyPress>
 {
 	typedef core::list<KeyPress> super;
 	typedef super::Iterator Iterator;
 	typedef super::ConstIterator ConstIterator;
-
+	
 	virtual ConstIterator find(const KeyPress &key) const
 	{
 		ConstIterator f(begin());
 		ConstIterator e(end());
 		while (f!=e) {
@@ -63,10 +63,12 @@
 		}
 		return e;
 	}
 
 public:
+	virtual ~KeyList() {};
+
 	void clear() { super::clear(); }
 
 	void set(const KeyPress &key)
 	{
 		if (find(key) == end())
diff -rU5 voxelands-v1709.00old/src/guiMainMenu.cpp voxelands-v1709.00good/src/guiMainMenu.cpp
--- voxelands-v1709.00old/src/guiMainMenu.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/guiMainMenu.cpp	2024-06-09 13:17:14.659158961 +0200
@@ -157,11 +157,11 @@
 	*/
 
 	/*
 		Client section
 	*/
-	char* selected_tab = config_get("client.ui.mainmenu.tab");
+	const char* selected_tab = config_get("client.ui.mainmenu.tab");
 	if (!selected_tab) {
 		m_data->selected_tab = TAB_SINGLEPLAYER;
 	}else if (!strcmp(selected_tab,"multiplayer")) {
 		m_data->selected_tab = TAB_MULTIPLAYER;
 	}else if (!strcmp(selected_tab,"settings")) {
@@ -171,14 +171,14 @@
 	}else{
 		m_data->selected_tab = TAB_SINGLEPLAYER;
 	}
 
 	if (m_data->selected_tab == TAB_MULTIPLAYER) {
-		GUIMultiplayerMenu *mmenu = new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
+		GUIMultiplayerMenu* const mmenu = new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
 		mmenu->drop();
 	}else if (m_data->selected_tab == TAB_SINGLEPLAYER) {
-		GUISingleplayerMenu *mmenu = new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
+		GUISingleplayerMenu* const mmenu = new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
 		mmenu->drop();
 	}else if (m_data->selected_tab == TAB_CREDITS) {
 		// CREDITS
 		{
 			core::rect<s32> rect(0, 0, 550, 550);
@@ -312,29 +312,32 @@
 			}
 			case GUI_ID_TAB_SINGLEPLAYER:
 			{
 				if (m_data->selected_tab == TAB_SETTINGS)
 					acceptInput();
-				GUISingleplayerMenu *mmenu = new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
+				GUISingleplayerMenu* const mmenu =
+				    new GUISingleplayerMenu(env, parent, -1,menumgr,m_gamecallback);
 				mmenu->drop();
 				m_data->selected_tab = TAB_SINGLEPLAYER;
 				config_set("client.ui.mainmenu.tab","singleplayer");
 				return true;
 			}
 			case GUI_ID_TAB_MULTIPLAYER:
 			{
 				if (m_data->selected_tab == TAB_SETTINGS)
 					acceptInput();
-				GUIMultiplayerMenu *mmenu = new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
+				GUIMultiplayerMenu* const mmenu =
+				    new GUIMultiplayerMenu(env, parent, -1,m_data,menumgr,m_gamecallback);
 				mmenu->drop();
 				m_data->selected_tab = TAB_MULTIPLAYER;
 				config_set("client.ui.mainmenu.tab","multiplayer");
 				return true;
 			}
 			case GUI_ID_TAB_SETTINGS:
 			{
-				GUISettingsMenu *smenu = new GUISettingsMenu(env, parent, -1,menumgr, false);
+				GUISettingsMenu* const smenu =
+				    new GUISettingsMenu(env, parent, -1,menumgr, false);
 				smenu->drop();
 				return true;
 			}
 			case GUI_ID_TAB_CREDITS:
 				if (m_data->selected_tab == TAB_SETTINGS)
diff -rU5 voxelands-v1709.00old/src/guiPauseMenu.h voxelands-v1709.00good/src/guiPauseMenu.h
--- voxelands-v1709.00old/src/guiPauseMenu.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/guiPauseMenu.h	2024-06-09 13:17:14.659158961 +0200
@@ -30,10 +30,11 @@
 #include "modalMenu.h"
 
 class IGameCallback
 {
 public:
+	virtual ~IGameCallback() {};
 	virtual void exitToOS() = 0;
 	virtual void disconnect() = 0;
 	virtual void changePassword() = 0;
 	virtual void startGame() = 0;
 };
diff -rU5 voxelands-v1709.00old/src/guiSingleplayerMenu.cpp voxelands-v1709.00good/src/guiSingleplayerMenu.cpp
--- voxelands-v1709.00old/src/guiSingleplayerMenu.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/guiSingleplayerMenu.cpp	2024-06-09 13:17:14.659158961 +0200
@@ -531,11 +531,11 @@
 
 	world_unload();
 }
 void GUISingleplayerMenu::loadWorld(bool create)
 {
-	char* v;
+	const char* v;
 	config_clear("world");
 
 	survival_mode = true;
 	random_seed = true;
 	flat_map = false;
diff -rU5 voxelands-v1709.00old/src/http.cpp voxelands-v1709.00good/src/http.cpp
--- voxelands-v1709.00old/src/http.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/http.cpp	2024-06-12 21:27:48.942302031 +0200
@@ -68,12 +68,13 @@
 
 /* server thread main loop */
 void * HTTPServerThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("HTTPServerThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
@@ -291,11 +292,11 @@
 }
 
 /* handle /api/xxx url's */
 int HTTPRemoteClient::handleAPI()
 {
-	char* v;
+	const char* v;
 
 	std::string u1 = m_recv_headers.getUrl(1);
 
 	if (u1 == "summary" || u1 == "") {
 		std::string txt(VERSION_STRING);
@@ -343,11 +344,11 @@
 			v = "";
 		txt += v;
 		txt += "\n";
 
 		txt += "summary,motd,mode,name,players,public,version,privs,features";
-		send((char*)txt.c_str());
+		send(txt.c_str());
 		return 1;
 	}else if (u1 == "motd") {
 		v = config_get("world.game.motd");
 		if (!v)
 			v = "";
@@ -391,11 +392,11 @@
 			if (c++)
 				txt += ", ";
 			txt += player->getName();
 		}
 		array_free(players,1);
-		send((char*)txt.c_str());
+		send(txt.c_str());
 		return 1;
 	}else if (u1 == "public") {
 		v = config_get("world.server.client.default.password");
 		if (v || config_get_bool("world.server.client.private")) {
 			send("private");
@@ -411,11 +412,11 @@
 }
 
 /* handle / url's */
 int HTTPRemoteClient::handleIndex()
 {
-	char* v;
+	const char* v;
 	int c = 0;
 
 	std::string html("<div class=\"panel\"><h2>");
 	v = config_get("world.game.motd");
 	if (v)
@@ -453,11 +454,11 @@
 	sendHTML(html);
 	return 1;
 }
 
 /* send text data to a remote http client */
-void HTTPRemoteClient::send(char* data)
+void HTTPRemoteClient::send(const char* data)
 {
 	int l = strlen(data);
 	m_send_headers.setHeader("Content-Type","text/plain");
 	m_send_headers.setLength(l);
 	sendHeaders();
@@ -571,11 +572,11 @@
 
 /*
  * HTTP request
  */
 
-std::string http_request(char* host, char* url, char* post, int port)
+std::string http_request(const char* host, char* url, char* post, int port)
 {
 	Address addr;
 	TCPSocket *sock;
 	HTTPResponseHeaders headers;
 	int s;
diff -rU5 voxelands-v1709.00old/src/http.h voxelands-v1709.00good/src/http.h
--- voxelands-v1709.00old/src/http.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/http.h	2024-06-09 13:17:14.659158961 +0200
@@ -53,11 +53,11 @@
 public:
 	HTTPHeaders()
 	{
 		clear();
 	}
-	~HTTPHeaders() {};
+	virtual ~HTTPHeaders() {};
 	void clear()
 	{
 		m_contentLength = 0;
 		m_url = std::string("");
 		m_url_split.clear();
@@ -84,17 +84,19 @@
 };
 
 class HTTPRequestHeaders : public HTTPHeaders
 {
 public:
+	virtual ~HTTPRequestHeaders() {};
 	virtual int read(TCPSocket *sock);
 private:
 };
 
 class HTTPResponseHeaders : public HTTPHeaders
 {
 public:
+	virtual ~HTTPResponseHeaders() {};
 	virtual int read(TCPSocket *sock);
 	void setResponse(int r) {m_response = r;}
 	int getResponse() {return m_response;}
 private:
 	int m_response;
@@ -122,12 +124,12 @@
 	int handleIndex();
 	int handleAPI();
 	int handleSpecial(const char* response, std::string content);
 	int handleSpecial(const char* response) {return handleSpecial(response,"");}
 
-	void send(char* data);
-	void send(std::string &data) {send((char*)data.c_str());}
+	void send(const char* data);
+	void send(std::string &data) {send(data.c_str());}
 	void sendHTML(char* data);
 	void sendHTML(std::string &data) {sendHTML((char*)data.c_str());}
 	void sendFile(std::string &file);
 	void setResponse(const char* response) {std::string r(response); m_response = r;}
 
@@ -158,9 +160,9 @@
 	std::vector<HTTPRemoteClient*> m_peers;
 	HTTPServerThread m_thread;
 	Server *m_server;
 };
 
-std::string http_request(char* host, char* url, char* post=NULL, int port=80);
+std::string http_request(const char* host, char* url, char* post=NULL, int port=80);
 std::string http_url_encode(std::string &str);
 
 #endif
diff -rU5 voxelands-v1709.00old/src/intl.c voxelands-v1709.00good/src/intl.c
--- voxelands-v1709.00old/src/intl.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/intl.c	2024-06-18 14:57:13.475050681 +0200
@@ -565,11 +565,11 @@
 }
 
 /* initialise an intl_t by loading in an mo file */
 int intl_load(intl_t *intl, char* file)
 {
-	char fbuff[2048];
+	char fbuff[2049];
 	char lbuff[128];
 	file_t *f;
 	uint32_t magic;
 	char* head;
 	char* p;
@@ -647,11 +647,11 @@
 	head = p;
 	e = strchr(head,'\n');
 	if (e)
 		*e = 0;
 
-	strncpy(fbuff,head+13,2048);
+	strncpy(fbuff,head+13,2048);fbuff[2048] = '\0';
 	if (e)
 		*e = '\n';
 	head = fbuff;
 
 	p = strstr(head,"nplurals=");
diff -rU5 voxelands-v1709.00old/src/inventory.cpp voxelands-v1709.00good/src/inventory.cpp
--- voxelands-v1709.00old/src/inventory.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/inventory.cpp	2024-06-09 13:17:14.659158961 +0200
@@ -803,14 +803,14 @@
 
 /*
 	Inventory
 */
 
-InventoryList::InventoryList(std::string name, u32 size)
+InventoryList::InventoryList(std::string name, u32 size) :
+		m_items(),m_size(size),m_name(name),m_allowed(),
+		m_denied(),m_stackable(false),m_diff()
 {
-	m_name = name;
-	m_size = size;
 	clearItems();
 	clearAllowed();
 	clearDenied();
 	setStackable();
 }
@@ -991,11 +991,14 @@
 			throw SerializationError("Unknown inventory identifier (3)");
 		}
 	}
 }
 
-InventoryList::InventoryList(const InventoryList &other)
+InventoryList::InventoryList(const InventoryList &other) :
+		m_items(),m_size(other.m_size),m_name(other.m_name),
+		m_allowed(other.m_allowed),m_denied(other.m_denied),
+		m_stackable(other.m_stackable),m_diff()
 {
 	/*
 		Do this so that the items get cloned. Otherwise the pointers
 		in the array will just get copied.
 	*/
@@ -1005,19 +1008,17 @@
 InventoryList & InventoryList::operator = (const InventoryList &other)
 {
 	m_name = other.m_name;
 	m_size = other.m_size;
 	clearItems();
+
 	for (u32 i=0; i<other.m_items.size(); i++) {
 		InventoryItem *item = other.m_items[i];
 		if (item != NULL)
 			m_items[i] = item->clone();
 	}
-	m_stackable = other.m_stackable;
-	m_allowed = other.m_allowed;
-	m_denied = other.m_denied;
-
+	
 	return *this;
 }
 
 const std::string &InventoryList::getName() const
 {
@@ -1445,11 +1446,11 @@
 	if (i == -1)
 		return NULL;
 	return m_lists[i];
 }
 
-const s32 Inventory::getListIndex(const std::string &name) const
+s32 Inventory::getListIndex(const std::string &name) const
 {
 	for (u32 i=0; i<m_lists.size(); i++) {
 		if (m_lists[i]->getName() == name)
 			return i;
 	}
diff -rU5 voxelands-v1709.00old/src/inventory.h voxelands-v1709.00good/src/inventory.h
--- voxelands-v1709.00old/src/inventory.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/inventory.h	2024-06-09 13:17:14.660159253 +0200
@@ -330,13 +330,12 @@
 
 class ToolItem : public InventoryItem
 {
 public:
 	ToolItem(content_t content, u16 wear, u16 data):
-		InventoryItem(1,data)
+			InventoryItem(1,data),m_wear(wear)
 	{
-		m_wear = wear;
 		m_content = content_toolitem_features(content).content;
 	}
 	/*
 		Implementation interface
 	*/
@@ -698,11 +697,11 @@
 		return m_diff;
 	}
 
 private:
 	// -1 if not found
-	const s32 getListIndex(const std::string &name) const;
+	s32 getListIndex(const std::string &name) const;
 
 	core::array<InventoryList*> m_lists;
 	InventoryDiff m_diff;
 };
 
diff -rU5 voxelands-v1709.00old/src/jthread/jthread.h voxelands-v1709.00good/src/jthread/jthread.h
--- voxelands-v1709.00old/src/jthread/jthread.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/jthread/jthread.h	2024-06-09 13:17:14.660159253 +0200
@@ -43,28 +43,32 @@
 
 class JTHREAD_IMPORTEXPORT JThread
 {
 public:
 	JThread();
+	JThread(const JThread& jt);
 	virtual ~JThread();
+	
+	JThread& operator=(const JThread& jt);
+
 	int Start();
 	int Kill();
 	virtual void *Thread() = 0;
 	bool IsRunning();
 	void *GetReturnValue();
 protected:
 	void ThreadStarted();
 private:
 
 #ifdef JTHREAD_CONFIG_WIN32THREADS
-#ifdef _WIN32_WCE
+# ifdef _WIN32_WCE
 	DWORD threadid;
 	static DWORD WINAPI TheThread(void *param);
-#else
+# else
 	static UINT __stdcall TheThread(void *param);
 	UINT threadid;
-#endif // _WIN32_WCE
+# endif // _WIN32_WCE
 	HANDLE threadhandle;
 #else // pthread type threads
 	static void *TheThread(void *param);
 	
 	pthread_t threadid;
diff -rU5 voxelands-v1709.00old/src/jthread/pthread/jmutex.cpp voxelands-v1709.00good/src/jthread/pthread/jmutex.cpp
--- voxelands-v1709.00old/src/jthread/pthread/jmutex.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/jthread/pthread/jmutex.cpp	2024-06-09 13:17:14.660159253 +0200
@@ -28,46 +28,45 @@
 #include "jmutex.h"
 
 namespace jthread
 {
 
-JMutex::JMutex()
-{
-	initialized = false;
-}
-
-JMutex::~JMutex()
-{
-	if (initialized)
+    JMutex::JMutex() : mutex(),initialized(false)
+    {
+    }
+
+    JMutex::~JMutex()
+    {
+	    if (initialized)
 		pthread_mutex_destroy(&mutex);
-}
+    }
 
-int JMutex::Init()
-{
-	if (initialized)
+    int JMutex::Init()
+    {
+	    if (initialized)
 		return ERR_JMUTEX_ALREADYINIT;
-	
-	pthread_mutex_init(&mutex,NULL);
-	initialized = true;
-	return 0;	
-}
-
-int JMutex::Lock()
-{
-	if (!initialized)
+	    
+	    pthread_mutex_init(&mutex,NULL);
+	    initialized = true;
+	    return 0;	
+    }
+
+    int JMutex::Lock()
+    {
+	    if (!initialized)
 		return ERR_JMUTEX_NOTINIT;
 		
-	pthread_mutex_lock(&mutex);
-	return 0;
-}
-
-int JMutex::Unlock()
-{
-	if (!initialized)
+	    pthread_mutex_lock(&mutex);
+	    return 0;
+    }
+
+    int JMutex::Unlock()
+    {
+	    if (!initialized)
 		return ERR_JMUTEX_NOTINIT;
 	
-	pthread_mutex_unlock(&mutex);
-	return 0;
-}
+	    pthread_mutex_unlock(&mutex);
+	    return 0;
+    }
 
 } // end namespace
 
diff -rU5 voxelands-v1709.00old/src/jthread/pthread/jthread.cpp voxelands-v1709.00good/src/jthread/pthread/jthread.cpp
--- voxelands-v1709.00old/src/jthread/pthread/jthread.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/jthread/pthread/jthread.cpp	2024-06-09 13:17:14.660159253 +0200
@@ -31,155 +31,173 @@
 #include <stdlib.h>
 
 namespace jthread
 {
 
-JThread::JThread()
-{
-	retval = NULL;
-	mutexinit = false;
-	running = false;
-}
-
-JThread::~JThread()
-{
-	Kill();
-}
+    JThread::JThread() : threadid(),retval(NULL),running(false),runningmutex(),
+			 continuemutex(),continuemutex2(),mutexinit(false)
+    {
+    }
+
+    JThread::JThread(const JThread& jt) : threadid(jt.threadid),
+					  retval(jt.retval),running(jt.running),
+					  runningmutex(jt.runningmutex),
+					  continuemutex(jt.continuemutex),
+					  continuemutex2(jt.continuemutex2),
+					  mutexinit(jt.mutexinit)
+    {
+    }
+
+    JThread::~JThread()
+    {
+	    Kill();
+    }
+
+    JThread& JThread::operator=(const JThread& jt)
+    {
+	    threadid = jt.threadid;retval = jt.retval;
+	    running = jt.running;
+	    runningmutex = jt.runningmutex;
+	    continuemutex = jt.continuemutex;
+	    continuemutex2 = jt.continuemutex2;
+	    mutexinit = jt.mutexinit;
+	    return *this;
+    }
+    
+    int JThread::Start()
+    {
+	    int status;
 
-int JThread::Start()
-{
-	int status;
-
-	if (!mutexinit)
-	{
+	    if (!mutexinit)
+	    {
 		if (!runningmutex.IsInitialized())
 		{
-			if (runningmutex.Init() < 0)
-				return ERR_JTHREAD_CANTINITMUTEX;
+		    if (runningmutex.Init() < 0)
+			return ERR_JTHREAD_CANTINITMUTEX;
 		}
 		if (!continuemutex.IsInitialized())
 		{
-			if (continuemutex.Init() < 0)
-				return ERR_JTHREAD_CANTINITMUTEX;
+		    if (continuemutex.Init() < 0)
+			return ERR_JTHREAD_CANTINITMUTEX;
 		}
 		if (!continuemutex2.IsInitialized())
 		{
-			if (continuemutex2.Init() < 0)
-				return ERR_JTHREAD_CANTINITMUTEX;
+		    if (continuemutex2.Init() < 0)
+			return ERR_JTHREAD_CANTINITMUTEX;
 		}
 		mutexinit = true;
-	}
+	    }
 	
-	runningmutex.Lock();
-	if (running)
-	{
+	    runningmutex.Lock();
+	    if (running)
+	    {
 		runningmutex.Unlock();
 		return ERR_JTHREAD_ALREADYRUNNING;
-	}
-	runningmutex.Unlock();
+	    }
+	    runningmutex.Unlock();
 	
-	pthread_attr_t attr;
-	pthread_attr_init(&attr);
-	pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
-	
-	continuemutex.Lock();
-	status = pthread_create(&threadid,&attr,TheThread,this);	
-	pthread_attr_destroy(&attr);
-	if (status != 0)
-	{
+	    pthread_attr_t attr;
+	    pthread_attr_init(&attr);
+	    pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
+	
+	    continuemutex.Lock();
+	    status = pthread_create(&threadid,&attr,TheThread,this);	
+	    pthread_attr_destroy(&attr);
+	    if (status != 0)
+	    {
 		continuemutex.Unlock();
 		return ERR_JTHREAD_CANTSTARTTHREAD;
-	}
+	    }
 	
 	/* Wait until 'running' is set */
 	
-	runningmutex.Lock();			
-	while (!running)
-	{
+	    runningmutex.Lock();			
+	    while (!running)
+	    {
 		runningmutex.Unlock();
 		
 		struct timespec req,rem;
 
 		req.tv_sec = 0;
 		req.tv_nsec = 1000000;
 		nanosleep(&req,&rem);
 
 		runningmutex.Lock();
-	}
-	runningmutex.Unlock();
+	    }
+	    runningmutex.Unlock();
 	
-	continuemutex.Unlock();
+	    continuemutex.Unlock();
 	
-	continuemutex2.Lock();
-	continuemutex2.Unlock();
-	return 0;
-}
-
-int JThread::Kill()
-{
-	runningmutex.Lock();			
-	if (!running)
-	{
+	    continuemutex2.Lock();
+	    continuemutex2.Unlock();
+	    return 0;
+    }
+
+    int JThread::Kill()
+    {
+	    runningmutex.Lock();			
+	    if (!running)
+	    {
 		runningmutex.Unlock();
 		return ERR_JTHREAD_NOTRUNNING;
-	}
-	pthread_cancel(threadid);
-	running = false;
-	runningmutex.Unlock();
-	return 0;
-}
-
-bool JThread::IsRunning()
-{
-	bool r;
-	
-	runningmutex.Lock();			
-	r = running;
-	runningmutex.Unlock();
-	return r;
-}
-
-void *JThread::GetReturnValue()
-{
-	void *val;
+	    }
+	    pthread_cancel(threadid);
+	    running = false;
+	    runningmutex.Unlock();
+	    return 0;
+    }
+
+    bool JThread::IsRunning()
+    {
+	    bool r;
+	
+	    runningmutex.Lock();			
+	    r = running;
+	    runningmutex.Unlock();
+	    return r;
+    }
+
+    void *JThread::GetReturnValue()
+    {
+	    void *val;
 	
-	runningmutex.Lock();
-	if (running)
+	    runningmutex.Lock();
+	    if (running)
 		val = NULL;
-	else
+	    else
 		val = retval;
-	runningmutex.Unlock();
-	return val;
-}
-
-void *JThread::TheThread(void *param)
-{
-	JThread *jthread;
-	void *ret;
-	
-	jthread = (JThread *)param;
-	
-	jthread->continuemutex2.Lock();
-	jthread->runningmutex.Lock();
-	jthread->running = true;
-	jthread->runningmutex.Unlock();
-	
-	jthread->continuemutex.Lock();
-	jthread->continuemutex.Unlock();
-	
-	ret = jthread->Thread();
-
-	jthread->runningmutex.Lock();
-	jthread->running = false;
-	jthread->retval = ret;
-	jthread->runningmutex.Unlock();
-
-	return NULL;
-}
-
-void JThread::ThreadStarted()
-{
-	continuemutex2.Unlock();
-}
+	    runningmutex.Unlock();
+	    return val;
+    }
+
+    void *JThread::TheThread(void *param)
+    {
+	    JThread *jthread;
+	    void *ret;
+	
+	    jthread = (JThread *)param;
+	
+	    jthread->continuemutex2.Lock();
+	    jthread->runningmutex.Lock();
+	    jthread->running = true;
+	    jthread->runningmutex.Unlock();
+	
+	    jthread->continuemutex.Lock();
+	    jthread->continuemutex.Unlock();
+	
+	    ret = jthread->Thread();
+
+	    jthread->runningmutex.Lock();
+	    jthread->running = false;
+	    jthread->retval = ret;
+	    jthread->runningmutex.Unlock();
+
+	    return NULL;
+    }
+
+    void JThread::ThreadStarted()
+    {
+	    continuemutex2.Unlock();
+    }
 
 } // end namespace
 
diff -rU5 voxelands-v1709.00old/src/keycode.cpp voxelands-v1709.00good/src/keycode.cpp
--- voxelands-v1709.00old/src/keycode.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/keycode.cpp	2024-06-09 13:17:14.660159253 +0200
@@ -500,11 +500,11 @@
 KeyPress *g_key_setting_cache[256];
 static bool key_setting_cache_init = false;
 
 KeyPress getKeySetting(KeyCode code)
 {
-	char* v;
+	const char* v;
 	if (!key_setting_cache_init)
 		clearKeyCache();
 	if (g_key_setting_cache[code])
 		return *g_key_setting_cache[code];
 
diff -rU5 voxelands-v1709.00old/src/log.c voxelands-v1709.00good/src/log.c
--- voxelands-v1709.00old/src/log.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/log.c	2024-06-09 13:17:14.660159253 +0200
@@ -43,11 +43,11 @@
 	5,
 	NULL,
 	{"none","error","warn","action","chat","info","debug"}
 };
 
-static void level_setter(char* v, int *l, int d)
+static void level_setter(const char* v, int *l, int d)
 {
 	int i;
 	if (v) {
 		for (i=0; i<7; i++) {
 			if (!strcmp(logdata.levels[i],v)) {
@@ -59,41 +59,41 @@
 
 	*l = d;
 }
 
 /* config setters */
-int log_minlevel_setter(char* v)
+int log_minlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.min_level,1);
 	return 0;
 }
-int log_maxlevel_setter(char* v)
+int log_maxlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.max_level,5);
 	return 0;
 }
-int log_sminlevel_setter(char* v)
+int log_sminlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.system_min_level,4);
 	return 0;
 }
-int log_smaxlevel_setter(char* v)
+int log_smaxlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.system_max_level,5);
 	return 0;
 }
-int log_cminlevel_setter(char* v)
+int log_cminlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.console_min_level,4);
 	return 0;
 }
-int log_cmaxlevel_setter(char* v)
+int log_cmaxlevel_setter(const char* v)
 {
 	level_setter(v,&logdata.console_max_level,5);
 	return 0;
 }
-int log_file_setter(char* v)
+int log_file_setter(const char* v)
 {
 	if (logdata.logfile)
 		free(logdata.logfile);
 	logdata.logfile = NULL;
 
@@ -104,11 +104,11 @@
 
 	return 0;
 }
 
 /* print text to game and system consoles */
-void vlprint(uint8_t type, char* str)
+void vlprint(uint8_t type,const char* str)
 {
 	char buff[1024];
 	char* b = buff;
 	int s = 1024;
 
@@ -179,11 +179,11 @@
 		fclose(f);
 	}
 }
 
 /* print formatted text to game and system consoles */
-void vlprintf(uint8_t type, char* fmt,...)
+void vlprintf(uint8_t type,const char* fmt,...)
 {
 	char buff[1024];
 	va_list ap;
 
 	if (!fmt)
diff -rU5 voxelands-v1709.00old/src/log.cpp voxelands-v1709.00good/src/log.cpp
--- voxelands-v1709.00old/src/log.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/log.cpp	2024-06-16 15:42:44.029853231 +0200
@@ -29,10 +29,12 @@
 #include <list>
 #include <sstream>
 #include "threads.h"
 #include "debug.h"
 #include "gettime.h"
+#include "jmutex.h"
+#include "jmutexautolock.h"
 
 std::list<ILogOutput*> log_outputs[LMT_NUM_VALUES];
 std::map<threadid_t, std::string> log_threadnames;
 
 void log_add_output(ILogOutput *out, enum LogMessageLevel lev)
@@ -73,17 +75,21 @@
 		break;
 	}
 	return "(unknown level)";
 }
 
-void log_printline(enum LogMessageLevel lev, const std::string &text)
+static void log_printline(enum LogMessageLevel lev, const std::string &text)
 {
 	std::string threadname = "(unknown thread)";
 	std::map<threadid_t, std::string>::const_iterator i;
+	
+	log_mutex.Lock();
 	i = log_threadnames.find(get_current_thread_id());
 	if(i != log_threadnames.end())
 		threadname = i->second;
+	log_mutex.Unlock();
+
 	std::string levelname = get_lev_string(lev);
 	std::ostringstream os(std::ios_base::binary);
 	os<<getTimestamp()<<": "<<levelname<<"["<<threadname<<"]: "<<text;
 	for(std::list<ILogOutput*>::iterator i = log_outputs[lev].begin();
 			i != log_outputs[lev].end(); i++){
@@ -95,12 +101,14 @@
 
 class Logbuf : public std::streambuf
 {
 public:
 	Logbuf(enum LogMessageLevel lev):
-		m_lev(lev)
+			m_lev(lev),m_buf(),m_mutex()
 	{
+		m_mutex.Init();
+		assert(m_mutex.IsInitialized());
 	}
 
 	~Logbuf()
 	{
 	}
@@ -115,31 +123,29 @@
 		for(int i=0; i<n; i++)
 			bufchar(s[i]);
 		return n;
 	}
 
-	void printbuf()
-	{
-		log_printline(m_lev, m_buf);
-	}
-
 	void bufchar(char c)
 	{
+	    	JMutexAutoLock lock(m_mutex);
 		if(c == '\n' || c == '\r'){
 			if(m_buf != "")
-				printbuf();
+			    log_printline(m_lev, m_buf);
 			m_buf = "";
 			return;
 		}
 		m_buf += c;
 	}
 
 private:
 	enum LogMessageLevel m_lev;
 	std::string m_buf;
+	JMutex m_mutex;
 };
 
+JMutex log_mutex;
 Logbuf errorbuf(LMT_ERROR);
 Logbuf actionbuf(LMT_ACTION);
 Logbuf infobuf(LMT_INFO);
 Logbuf verbosebuf(LMT_VERBOSE);
 std::ostream errorstream(&errorbuf);
diff -rU5 voxelands-v1709.00old/src/log.h voxelands-v1709.00good/src/log.h
--- voxelands-v1709.00old/src/log.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/log.h	2024-06-16 15:15:52.735809913 +0200
@@ -25,10 +25,11 @@
 
 #ifndef LOG_HEADER
 #define LOG_HEADER
 
 #include <string>
+#include "jmutex.h"
 
 /*
 	Use this for logging everything.
 
 	If you need to explicitly print something, use dstream or cout or cerr.
@@ -43,10 +44,12 @@
 };
 
 class ILogOutput
 {
 public:
+	virtual ~ILogOutput() {};
+	
 	/* line: Full line with timestamp, level and thread */
 	virtual void printLog(const std::string &line){};
 	/* line: Only actual printed text */
 	virtual void printLog(enum LogMessageLevel lev, const std::string &line){};
 };
@@ -55,21 +58,13 @@
 void log_add_output_maxlev(ILogOutput *out, enum LogMessageLevel lev);
 void log_add_output_all_levs(ILogOutput *out);
 
 void log_register_thread(const std::string &name);
 
-void log_printline(enum LogMessageLevel lev, const std::string &text);
-
-#define LOGLINEF(lev, ...)\
-{\
-	char buf[10000];\
-	snprintf(buf, 10000, __VA_ARGS__);\
-	log_printline(lev, buf);\
-}
-
 extern std::ostream errorstream;
 extern std::ostream actionstream;
 extern std::ostream infostream;
 extern std::ostream verbosestream;
+extern jthread::JMutex log_mutex;
 
 #endif
 
diff -rU5 voxelands-v1709.00old/src/main.cpp voxelands-v1709.00good/src/main.cpp
--- voxelands-v1709.00old/src/main.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/main.cpp	2024-06-12 21:31:22.917413966 +0200
@@ -132,10 +132,11 @@
 
 // A small helper class
 class TimeGetter
 {
 public:
+	virtual ~TimeGetter() {};
 	virtual u32 getTime() = 0;
 };
 
 // A precise irrlicht one
 class IrrlichtTimeGetter: public TimeGetter
@@ -715,14 +716,13 @@
 int main(int argc, char *argv[])
 {
 	/*
 		Initialization
 	*/
-
+	log_mutex.Init();
 	log_add_output_maxlev(&main_stderr_log_out, LMT_ACTION);
 	log_add_output_all_levs(&main_dstream_no_stderr_log_out);
-
 	log_register_thread("main");
 
 	/*
 		Low-level initialization
 	*/
@@ -796,11 +796,11 @@
 		DSTACK("Dedicated server branch");
 
 		// Create time getter
 		g_timegetter = new SimpleTimeGetter();
 
-		char* v = config_get("server.world");
+		const char* v = config_get("server.world");
 		world_init(v);
 
 		// Create server
 		Server server;
 		server.start();
@@ -834,11 +834,11 @@
 	// Determine driver
 
 	video::E_DRIVER_TYPE driverType = video::EDT_OPENGL;
 
 	{
-		char* v = config_get("client.video.driver");
+		const char* v = config_get("client.video.driver");
 		if (v && !strcmp(v,"d3d9"))
 			driverType = video::EDT_DIRECT3D9;
 	}
 
 	/*
@@ -898,11 +898,11 @@
 	gui::IGUIFont* font = NULL;
 	{
 		char buff[1024];
 #if USE_FREETYPE
 		uint16_t font_size = config_get_int("client.ui.font.size");
-		char* v = config_get("client.ui.font");
+		const char* v = config_get("client.ui.font");
 		if (!v)
 			v = "unifont.ttf";
 		if (path_get("font",v,1,buff,1024))
 			font = gui::CGUITTFont::createTTFont(guienv, buff, font_size, true, true, 1, 128);
 #else
@@ -969,11 +969,11 @@
 	std::string password;
 
 	// if there's no chardef then put the player directly into the character creator
 	bool character_creator = true;
 	{
-		char* v = config_get("client.character");
+		const char* v = config_get("client.character");
 		if (v && v[0])
 			character_creator = false;
 	}
 
 	/*
@@ -1009,11 +1009,11 @@
 				smgr->clear();
 
 				// Initialize menu data
 				std::string playername = "";
 				{
-					char* v = config_get("client.name");
+					const char* v = config_get("client.name");
 					if (v)
 						playername = std::string(v);
 				}
 				if (playername == "")
 					playername = porting::getUser();
@@ -1038,11 +1038,11 @@
 				menudata.fixed_seed = narrow_to_wide(bridge_config_get("world.seed"));
 				if (menudata.fixed_seed != L"")
 					menudata.use_fixed_seed = true;
 				menudata.map_type = config_get("world.map.type");
 
-				GUIMainMenu *menu = new GUIMainMenu(
+				GUIMainMenu* const menu = new GUIMainMenu(
 					guienv,
 					guiroot,
 					-1,
 					&g_menumgr,
 					&menudata,
@@ -1052,11 +1052,11 @@
 
 				if (error_message != L"") {
 					errorstream<<"error_message = "
 							<<wide_to_narrow(error_message)<<std::endl;
 
-					GUIMessageMenu *menu2 =
+					GUIMessageMenu* const menu2 =
 							new GUIMessageMenu(guienv, guiroot, -1,
 								&g_menumgr, error_message.c_str());
 					menu2->drop();
 					error_message = L"";
 				}
@@ -1103,11 +1103,11 @@
 				if (device->run() == false || kill == true)
 					break;
 
 				infostream<<"Dropping main menu"<<std::endl;
 
-				menu->drop();
+				menu->drop(); // Don't use after.
 
 				character_creator = menudata.character_creator;
 
 				if (character_creator)
 					break;
@@ -1167,11 +1167,11 @@
 
 			if (character_creator) {
 				character_creator = false;
 				video::IVideoDriver* driver = device->getVideoDriver();
 
-				GUICharDefMenu *menu = new GUICharDefMenu(device, guienv, guiroot, -1, &g_menumgr);
+				GUICharDefMenu* const menu = new GUICharDefMenu(device, guienv, guiroot, -1, &g_menumgr);
 				menu->allowFocusRemoval(true);
 
 #if USE_AUDIO == 1
 				sound_play_music("bg-charcreator",1.0,1);
 #endif
@@ -1199,21 +1199,20 @@
 #if USE_AUDIO == 1
 				sound_stop_music(1.0);
 #endif
 
 				menu->drop();
-
 				continue;
 			}
 			// Initialize mapnode again to enable changed graphics settings
 			init_mapnode(device);
 
 			/*
 				Run game
 			*/
 			{
-				char* v = config_get("world.server.address");
+				const char* v = config_get("world.server.address");
 				if (!v || !v[0]) {
 					if (!world_init(NULL)) {
 						the_game(
 							kill,
 							input,
diff -rU5 voxelands-v1709.00old/src/map.cpp voxelands-v1709.00good/src/map.cpp
--- voxelands-v1709.00old/src/map.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/map.cpp	2024-06-15 18:12:45.198447436 +0200
@@ -70,21 +70,28 @@
 	Map
 */
 
 Map::Map(std::ostream &dout):
 	m_dout(dout),
-	m_sector_cache(NULL)
+	m_event_receivers(),
+	m_sectors(),
+	m_sectors_mutex(),
+	m_sector_cache(NULL),
+	m_sector_cache_p(),
+	m_transforming_liquid()
 {
-	/*m_sector_mutex.Init();
-	assert(m_sector_mutex.IsInitialized());*/
+	m_sectors_mutex.Init();
+	assert(m_sectors_mutex.IsInitialized());
 }
 
 Map::~Map()
 {
 	/*
 		Free all MapSectors
 	*/
+	JMutexAutoLock lock(m_sectors_mutex);
+	
 	core::map<v2s16, MapSector*>::Iterator i = m_sectors.getIterator();
 	for(; i.atEnd() == false; i++)
 	{
 		MapSector *sector = i.getNode()->getValue();
 		delete sector;
@@ -135,10 +142,11 @@
 	return sector;
 }
 
 MapSector * Map::getSectorNoGenerateNoEx(v2s16 p)
 {
+	JMutexAutoLock lock(m_sectors_mutex);
 	return getSectorNoGenerateNoExNoLock(p);
 }
 
 MapSector * Map::getSectorNoGenerate(v2s16 p)
 {
@@ -150,11 +158,12 @@
 }
 
 MapBlock * Map::getBlockNoCreateNoEx(v3s16 p3d)
 {
 	v2s16 p2d(p3d.X, p3d.Z);
-	MapSector * sector = getSectorNoGenerateNoEx(p2d);
+	JMutexAutoLock lock(m_sectors_mutex);
+	MapSector * sector = getSectorNoGenerateNoExNoLock(p2d);
 	if(sector == NULL)
 		return NULL;
 	MapBlock *block = sector->getBlockNoCreateNoEx(p3d.Y);
 	return block;
 }
@@ -1231,14 +1240,15 @@
 
 	core::list<v2s16> sector_deletion_queue;
 	u32 deleted_blocks_count = 0;
 	u32 saved_blocks_count = 0;
 
-	core::map<v2s16, MapSector*>::Iterator si;
-
 	beginSave();
-	si = m_sectors.getIterator();
+	m_sectors_mutex.Lock();
+	
+	core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
+	
 	for(; si.atEnd() == false; si++)
 	{
 		MapSector *sector = si.getNode()->getValue();
 
 		bool all_blocks_deleted = true;
@@ -1282,10 +1292,11 @@
 		if(all_blocks_deleted)
 		{
 			sector_deletion_queue.push_back(si.getNode()->getKey());
 		}
 	}
+	m_sectors_mutex.Unlock();
 	endSave();
 
 	// Finally delete the empty sectors
 	deleteSectors(sector_deletion_queue);
 
@@ -1301,13 +1312,15 @@
 }
 
 void Map::deleteSectors(core::list<v2s16> &list)
 {
 	core::list<v2s16>::Iterator j;
+	JMutexAutoLock lock(m_sectors_mutex);
+
 	for(j=list.begin(); j!=list.end(); j++)
 	{
-		MapSector *sector = m_sectors[*j];
+		MapSector* const sector = m_sectors[*j];
 		// If sector is in sector cache, remove it from there
 		if(m_sector_cache == sector)
 			m_sector_cache = NULL;
 		// Remove from map and delete
 		m_sectors.remove(*j);
@@ -1659,12 +1672,14 @@
 		blocks are loaded when this is run. (They might get unloaded)
 		NOTE: ^- Actually, that might not be so. In a quick test it
 		reloaded a block with a furnace when I walked back to it from
 		a distance.
 	*/
-	core::map<v2s16, MapSector*>::Iterator si;
-	si = m_sectors.getIterator();
+	JMutexAutoLock lock(m_sectors_mutex);
+
+	core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
+	
 	for(; si.atEnd() == false; si++)
 	{
 		MapSector *sector = si.getNode()->getValue();
 		core::list< MapBlock * > sectorblocks;
 		sector->getBlocks(sectorblocks);
@@ -1999,11 +2014,13 @@
 	sector = new ServerMapSector(this, p2d);
 
 	/*
 		Insert to container
 	*/
+	m_sectors_mutex.Lock();
 	m_sectors.insert(p2d, sector);
+	m_sectors_mutex.Unlock();
 
 	return sector;
 }
 
 /*
@@ -2258,10 +2275,11 @@
 	u32 block_count = 0;
 	u32 block_count_all = 0; // Number of blocks in memory
 
 	// Don't do anything with sqlite unless something is really saved
 	bool save_started = false;
+	JMutexAutoLock lock(m_sectors_mutex);
 
 	for (core::map<v2s16, MapSector*>::Iterator i = m_sectors.getIterator(); i.atEnd() == false; i++) {
 		ServerMapSector *sector = (ServerMapSector*)i.getNode()->getValue();
 		assert(sector->getId() == MAPSECTOR_SERVER);
 		core::list<MapBlock*> blocks;
@@ -2351,11 +2369,11 @@
 	}else{
 		m_seed = config_get_int64("world.seed");
 	}
 	m_type = MGT_DEFAULT;
 	if (config_get("world.map.type")) {
-		char* type = config_get("world.map.type");
+		const char* type = config_get("world.map.type");
 		if (!strcmp(type,"flat")) {
 			m_type = MGT_FLAT;
 		}else{
 			config_set("world.map.type","default");
 		}
@@ -2547,24 +2565,23 @@
 		s32 id
 ):
 	Map(dout_client),
 	scene::ISceneNode(parent, mgr, id),
 	m_client(client),
+	m_box(-BS*1000000,-BS*1000000,-BS*1000000,
+			BS*1000000,BS*1000000,BS*1000000),
 	m_control(control),
 	m_camera_position(0,0,0),
 	m_camera_direction(0,0,1),
-	m_camera_fov(PI)
+	m_camera_fov(PI),
+	m_render_trilinear(config_get_bool("client.video.trilinear")),
+	m_render_bilinear(config_get_bool("client.video.bilinear")),
+	m_render_anisotropic(config_get_bool("client.video.anisotropic")),
+	m_last_drawn_sectors()
 {
 	m_camera_mutex.Init();
 	assert(m_camera_mutex.IsInitialized());
-
-	m_box = core::aabbox3d<f32>(-BS*1000000,-BS*1000000,-BS*1000000,
-			BS*1000000,BS*1000000,BS*1000000);
-
-	m_render_trilinear = config_get_bool("client.video.trilinear");
-	m_render_bilinear = config_get_bool("client.video.bilinear");
-	m_render_anisotropic = config_get_bool("client.video.anisotropic");
 }
 
 ClientMap::~ClientMap()
 {
 }
@@ -2582,11 +2599,11 @@
 
 	// Create a sector
 	ClientMapSector *sector = new ClientMapSector(this, p2d);
 
 	{
-		//JMutexAutoLock lock(m_sector_mutex); // Bulk comment-out
+		JMutexAutoLock lock(m_sectors_mutex);
 		m_sectors.insert(p2d, sector);
 	}
 
 	return sector;
 }
@@ -2659,10 +2676,11 @@
 	int time1 = time(0);
 
 	m_camera_mutex.Lock();
 	v3f camera_position = m_camera_position;
 	v3f camera_direction = m_camera_direction;
+	v3s16 camera_offset = m_camera_offset;
 	f32 camera_fov = m_camera_fov;
 	m_camera_mutex.Unlock();
 
 	/*
 		Get all blocks and draw all visible ones
@@ -2722,10 +2740,12 @@
 
 	for(core::map<v2s16, MapSector*>::Iterator
 			si = m_sectors.getIterator();
 			si.atEnd() == false; si++)
 	{
+	    	m_sectors_mutex.Lock();
+
 		MapSector *sector = si.getNode()->getValue();
 		v2s16 sp = sector->getPos();
 
 		if(m_control.range_all == false)
 		{
@@ -2736,29 +2756,34 @@
 				continue;
 		}
 
 		core::list< MapBlock * > sectorblocks;
 		sector->getBlocks(sectorblocks);
+		
+		m_sectors_mutex.Unlock();
 
 		/*
 			Loop through blocks in sector
 		*/
 
 		u32 sector_blocks_drawn = 0;
 
 		core::list< MapBlock * >::Iterator i;
 		for(i=sectorblocks.begin(); i!=sectorblocks.end(); i++)
 		{
-			MapBlock *block = *i;
+			MapBlock* const block = *i;
 
+			if(!block)
+			    continue;
+			
 			/*
 				Compare block position to camera position, skip
 				if not seen on display
 			*/
 
 			if (block->mesh != NULL)
-				block->mesh->updateCameraOffset(m_camera_offset);
+				block->mesh->updateCameraOffset(camera_offset);
 
 			float range = 100000 * BS;
 			if(m_control.range_all == false)
 				range = m_control.wanted_range * BS;
 
@@ -2872,11 +2897,11 @@
 				Ignore if mesh doesn't exist
 			*/
 			{
 				JMutexAutoLock lock(block->mesh_mutex);
 
-				MapBlockMesh *mesh = block->mesh;
+				MapBlockMesh* const mesh = block->mesh;
 
 				if (mesh == NULL) {
 					blocks_in_range_without_mesh++;
 					continue;
 				}
@@ -2940,11 +2965,11 @@
 			Draw the faces of the block
 		*/
 		{
 			JMutexAutoLock lock(block->mesh_mutex);
 
-			MapBlockMesh *mesh = block->mesh;
+			MapBlockMesh* const mesh = block->mesh;
 			if (!mesh || !mesh->getMesh())
 				continue;
 			scene::SMesh *m = NULL;
 			if (mesh->isfar) {
 				m = mesh->getFarMesh();
@@ -3141,29 +3166,34 @@
 
 	int sunlight_seen_count = 0;
 	float sunlight_min_d = max_d*0.8;
 	if (sunlight_min_d > 35*BS)
 		sunlight_min_d = 35*BS;
-
+	
+	m_camera_mutex.Lock();
+	v3f camera_position = m_camera_position;
+	v3f camera_direction = m_camera_direction;
+	m_camera_mutex.Unlock();
+	
 	core::array<int> values;
 
 	for (u32 i=0; i<sizeof(z_directions)/sizeof(*z_directions); i++) {
 		v3f z_dir = z_directions[i];
 		z_dir.normalize();
 		core::CMatrix4<f32> a;
 		a.buildRotateFromTo(v3f(0,1,0), z_dir);
-		v3f dir = m_camera_direction;
+		v3f dir = camera_direction;
 		a.rotateVect(dir);
 		int br = 0;
 		float step = BS*1.5;
 		if (max_d > 35*BS)
 			step = max_d / 35 * 1.5;
 		float off = step * z_offsets[i];
 		bool sunlight_seen_now = false;
 		bool ok = getVisibleBrightness(
 			this,
-			m_camera_position,
+			camera_position,
 			dir,
 			step,
 			1.0,
 			max_d*0.6+off,
 			max_d,
@@ -3198,11 +3228,11 @@
 		brightness_count++;
 	}
 
 	int ret = 0;
 	if (brightness_count == 0) {
-		MapNode n = getNodeNoEx(floatToInt(m_camera_position, BS));
+		MapNode n = getNodeNoEx(floatToInt(camera_position, BS));
 		if (content_features(n).param_type == CPT_LIGHT) {
 			ret = decode_light(n.getLightBlend(daylight_factor));
 		}else{
 			ret = oldvalue;
 		}
@@ -3279,18 +3309,22 @@
 }
 
 void ClientMap::expireMeshes(bool only_daynight_diffed)
 {
 	TimeTaker timer("expireMeshes()");
-
-	core::map<v2s16, MapSector*>::Iterator si;
-	si = m_sectors.getIterator();
+	
+	core::map<v2s16, MapSector*>::Iterator si = m_sectors.getIterator();
+	
 	for (; si.atEnd() == false; si++) {
+	    	m_sectors_mutex.Lock();
+
 		MapSector *sector = si.getNode()->getValue();
 
 		core::list< MapBlock * > sectorblocks;
 		sector->getBlocks(sectorblocks);
+		
+		m_sectors_mutex.Unlock();
 
 		core::list< MapBlock * >::Iterator i;
 		for (i=sectorblocks.begin(); i!=sectorblocks.end(); i++) {
 			MapBlock *block = *i;
 
diff -rU5 voxelands-v1709.00old/src/map.h voxelands-v1709.00good/src/map.h
--- voxelands-v1709.00old/src/map.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/map.h	2024-06-09 17:00:56.209264806 +0200
@@ -121,10 +121,12 @@
 };
 
 class MapEventReceiver
 {
 public:
+	virtual ~MapEventReceiver() {};
+	
 	// event shall be deleted by caller after the call.
 	virtual void onMapEditEvent(MapEditEvent *event) = 0;
 };
 
 class Map /*: public NodeContainer*/
@@ -319,10 +321,11 @@
 	std::ostream &m_dout;
 
 	core::map<MapEventReceiver*, bool> m_event_receivers;
 
 	core::map<v2s16, MapSector*> m_sectors;
+	JMutex m_sectors_mutex;
 
 	// Be sure to set this to NULL when the cached sector is deleted
 	MapSector *m_sector_cache;
 	v2s16 m_sector_cache_p;
 
@@ -481,11 +484,11 @@
 			scene::ISceneNode* parent,
 			scene::ISceneManager* mgr,
 			s32 id
 	);
 
-	~ClientMap();
+	virtual ~ClientMap();
 
 	s32 mapType() const
 	{
 		return MAPTYPE_CLIENT;
 	}
@@ -547,11 +550,11 @@
 	}
 
 private:
 	Client *m_client;
 
-	core::aabbox3d<f32> m_box;
+	const core::aabbox3d<f32> m_box;
 
 	// This is the master heightmap mesh
 	//scene::SMesh *mesh;
 	//JMutex mesh_mutex;
 
@@ -561,13 +564,13 @@
 	v3f m_camera_direction;
 	f32 m_camera_fov;
 	v3s16 m_camera_offset;
 	JMutex m_camera_mutex;
 
-	bool m_render_trilinear;
-	bool m_render_bilinear;
-	bool m_render_anisotropic;
+	const bool m_render_trilinear;
+	const bool m_render_bilinear;
+	const bool m_render_anisotropic;
 
 	core::map<v2s16, bool> m_last_drawn_sectors;
 };
 
 #endif
diff -rU5 voxelands-v1709.00old/src/mapblock.cpp voxelands-v1709.00good/src/mapblock.cpp
--- voxelands-v1709.00old/src/mapblock.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapblock.cpp	2024-06-15 19:22:56.253525260 +0200
@@ -532,12 +532,12 @@
 	}
 
 	std::ostringstream desc;
 
 	v3s16 p = block->getPos();
-	char spos[20];
-	snprintf(spos, 20, "(%2d,%2d,%2d), ", p.X, p.Y, p.Z);
+	char spos[32];
+	snprintf(spos, 32, "(%2d,%2d,%2d), ", p.X, p.Y, p.Z);
 	desc<<spos;
 
 	switch(block->getModified())
 	{
 	case MOD_STATE_CLEAN:
diff -rU5 voxelands-v1709.00old/src/mapblock_mesh.cpp voxelands-v1709.00good/src/mapblock_mesh.cpp
--- voxelands-v1709.00old/src/mapblock_mesh.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapblock_mesh.cpp	2024-06-09 18:56:50.890980184 +0200
@@ -414,24 +414,24 @@
 	if (corner.Y == 1)
 		p.Y += 1;
 	if (corner.Z == 1)
 		p.Z += 1;
 
-		for (u8 i = 0; i < 8; i++) {
-		MapNode n = vmanip.getNodeRO(p - dirs8[i]);
-		ContentFeatures &f = content_features(n);
-		if (f.param_type == CPT_LIGHT) {
-			dl += n.getLight(LIGHTBANK_DAY);
-			nl += n.getLight(LIGHTBANK_NIGHT);
-			light_count++;
-			if (f.light_source > 0)
-				ambient_occlusion -= 1.0;
-		} else if (f.draw_type == CDT_CUBELIKE || f.draw_type == CDT_DIRTLIKE) {
-			ambient_occlusion += 0.5;
-		} else if (n.getContent() != CONTENT_IGNORE) {
-			ambient_occlusion += 0.25;
-		}
+	for (u8 i = 0; i < 8; i++) {
+	    MapNode n = vmanip.getNodeRO(p - dirs8[i]);
+	    ContentFeatures &f = content_features(n);
+	    if (f.param_type == CPT_LIGHT) {
+		dl += n.getLight(LIGHTBANK_DAY);
+		nl += n.getLight(LIGHTBANK_NIGHT);
+		light_count++;
+		if (f.light_source > 0)
+		    ambient_occlusion -= 1.0;
+	    } else if (f.draw_type == CDT_CUBELIKE || f.draw_type == CDT_DIRTLIKE) {
+		ambient_occlusion += 0.5;
+	    } else if (n.getContent() != CONTENT_IGNORE) {
+		ambient_occlusion += 0.25;
+	    }
 	}
 
 	if (light_count == 0)
 		return 0;
 
@@ -469,10 +469,11 @@
 {
 	m_mesh->drop();
 	m_mesh = NULL;
 	m_farmesh->drop();
 	m_farmesh = NULL;
+	
 	if (!m_animation_data.empty())
 		m_animation_data.clear();
 }
 
 void MapBlockMesh::animate(float time)
@@ -684,10 +685,14 @@
 		}
 	}
 
 	scene::SMesh *mesh = new scene::SMesh();
 	scene::SMesh *fmesh = new scene::SMesh();
+	
+	if (mutex != NULL)
+		mutex->Lock();
+
 	for (u32 i=0; i<data->m_meshdata.size(); i++) {
 		MeshData &d = data->m_meshdata[i];
 
 		// - Texture animation
 		if (d.tile.material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES) {
@@ -699,48 +704,57 @@
 		}
 
 		// Create meshbuffer
 		// This is a "Standard MeshBuffer",
 		// it's a typedeffed CMeshBuffer<video::S3DVertex>
-		scene::SMeshBuffer *buf = new scene::SMeshBuffer();
+		scene::SMeshBuffer* const buf = new scene::SMeshBuffer();
+
+		if(buf) {
 		// Set material
-		buf->Material = d.tile.getMaterial();
+		    buf->Material = d.tile.getMaterial();
 		// Add to mesh
-		mesh->addMeshBuffer(buf);
+		    mesh->addMeshBuffer(buf);
 		// Mesh grabbed it
-		buf->drop();
-
-		buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
+		    buf->drop();
+		    buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
+		}
 	}
 	for (u32 i=0; i<data->m_fardata.size(); i++) {
 		MeshData &d = data->m_fardata[i];
 		// Create meshbuffer
 		// This is a "Standard MeshBuffer",
 		// it's a typedeffed CMeshBuffer<video::S3DVertex>
-		scene::SMeshBuffer *buf = new scene::SMeshBuffer();
+		scene::SMeshBuffer* const buf = new scene::SMeshBuffer();
+
+		if(buf) {
 		// Set material
-		buf->Material = d.tile.getMaterial();
+		    buf->Material = d.tile.getMaterial();
 		// Add to mesh
-		fmesh->addMeshBuffer(buf);
+		    fmesh->addMeshBuffer(buf);
 		// Mesh grabbed it
-		buf->drop();
-
-		buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
+		    buf->drop();
+		    buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
+		}
 	}
 
+	if (mutex != NULL)
+		mutex->Unlock();
+
 	translateMesh(mesh, intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset, BS));
 	translateMesh(fmesh, intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset, BS));
 
 	if (mutex != NULL)
 		mutex->Lock();
 
 	if (m_mesh != NULL)
 		m_mesh->drop();
+	m_mesh = mesh;
+	
 	if (m_farmesh != NULL)
 		m_farmesh->drop();
-	m_mesh = mesh;
 	m_farmesh = fmesh;
+	
 	m_meshdata.swap(data->m_meshdata);
 	m_fardata.swap(data->m_fardata);
 	refresh(data->m_daynight_ratio);
 	m_mesh->recalculateBoundingBox();
 
diff -rU5 voxelands-v1709.00old/src/mapnode.h voxelands-v1709.00good/src/mapnode.h
--- voxelands-v1709.00old/src/mapnode.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mapnode.h	2024-06-09 13:17:14.661159546 +0200
@@ -277,17 +277,16 @@
 };
 
 class FaceText
 {
 public:
-	FaceText():
-		m_hastext(false)
+	FaceText() :
+			m_type(FTT_INFO),m_hastext(false)
 	{
 	}
-	FaceText(f32 tlx, f32 tly, f32 brx, f32 bry):
-		m_type(FTT_INFO),
-		m_hastext(true)
+	FaceText(f32 tlx, f32 tly, f32 brx, f32 bry) :
+			m_type(FTT_INFO),m_hastext(true)
 	{
 #ifndef SERVER
 		m_pos = core::rect<f32>(tlx,tly,brx,bry);
 #endif
 	}
@@ -548,18 +547,12 @@
 		rotate_tile_with_nodebox = false;
 		plantlike_tiled = false;
 		wield_nodebox = true;
 		description = (char*)"";
 		nodeboxes.clear();
-		nodeboxes.push_back(NodeBox(
-			-0.5*BS,
-			-0.5*BS,
-			-0.5*BS,
-			0.5*BS,
-			0.5*BS,
-			0.5*BS
-		));
+		nodeboxes.push_back(NodeBox(-0.5*BS,-0.5*BS,-0.5*BS,
+						0.5*BS,0.5*BS,0.5*BS));
 		wield_nodeboxes.clear();
 		setAllFaceTexts(FaceText());
 		param_type = CPT_NONE;
 		param2_type = CPT_NONE;
 		item_param_type = CPT_NONE;
@@ -833,16 +826,13 @@
 	u16 crack;
 	bool has_crack;
 	bool is_coloured;
 	content_t content;
 
-	SelectedNode()
+	SelectedNode() : pos(0,0,0),crack(0),has_crack(false),is_coloured(false),
+			 content(CONTENT_IGNORE)	 
 	{
-		pos = v3s16(0,0,0);
-		has_crack = false;
-		is_coloured = false;
-		content = CONTENT_IGNORE;
 	}
 
 	SelectedNode(v3s16 p, u16 c, bool h, content_t cnt)
 	{
 		pos = p;
@@ -962,23 +952,29 @@
 	*/
 	u8 param2;
 
 	u32 envticks;
 
-	MapNode(const MapNode & n)
+	MapNode(const MapNode & n) :
+			content(n.content),param1(n.param1),param2(n.param2),
+			envticks(n.envticks)
 	{
-		*this = n;
 	}
 
-	MapNode(content_t a_content=CONTENT_AIR, u8 a_param1=0, u8 a_param2=0)
+	MapNode(content_t a_content=CONTENT_AIR, u8 a_param1=0, u8 a_param2=0) :
+			content(a_content),param1(a_param1),param2(a_param2),
+			envticks(0)
 	{
-		content = a_content;
-		param1 = a_param1;
-		param2 = a_param2;
-		envticks = 0;
 	}
 
+	MapNode& operator=(const MapNode& n)
+	{
+		content = n.content;param1 = n.param1;param2 = n.param2;
+		envticks = n.envticks;
+		return *this;
+	}
+	
 	bool operator==(const MapNode &other)
 	{
 		return (content == other.content
 				&& param1 == other.param1
 				&& param2 == other.param2);
@@ -1088,11 +1084,10 @@
 	*/
 
 	static u32 serializedLength(u8 version);
 	void serialize(u8 *dest, u8 version);
 	void deSerialize(u8 *source, u8 version);
-
 };
 
 /*
 	Gets lighting value at face of node
 
diff -rU5 voxelands-v1709.00old/src/mesh.cpp voxelands-v1709.00good/src/mesh.cpp
--- voxelands-v1709.00old/src/mesh.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/mesh.cpp	2024-06-09 13:17:14.661159546 +0200
@@ -120,11 +120,12 @@
 			}
 		}
 
 		u16 indices[6] = {0,1,2,2,3,0};
 		for (u32 i=0; i<6; ++i) {
-			scene::IMeshBuffer *buf = new scene::SMeshBuffer();
+			scene::IMeshBuffer* const buf = new scene::SMeshBuffer();
+			
 			buf->append(vertices + 4 * i, 4, indices, 6);
 			// Set default material
 			buf->getMaterial().setFlag(video::EMF_LIGHTING, false);
 			buf->getMaterial().setFlag(video::EMF_BILINEAR_FILTER, false);
 			buf->getMaterial().MaterialType = video::EMT_TRANSPARENT_ALPHA_CHANNEL_REF;
@@ -132,11 +133,12 @@
 			mesh->addMeshBuffer(buf);
 			buf->drop();
 		}
 	}
 
-	scene::SAnimatedMesh *anim_mesh = new scene::SAnimatedMesh(mesh);
+	scene::SAnimatedMesh* const anim_mesh = new scene::SAnimatedMesh(mesh);
+	
 	mesh->drop();
 	scaleMesh(anim_mesh, scale);  // also recalculates bounding box
 	return anim_mesh;
 }
 
@@ -167,11 +169,12 @@
 		return mesh;
 #if (IRRLICHT_VERSION_MAJOR >= 1 && IRRLICHT_VERSION_MINOR >= 8) || IRRLICHT_VERSION_MAJOR >= 2
 	// irrlicht 1.8+ we just manually load the mesh
 	scene::IMeshLoader *loader;
 	u32 lc = smgr->getMeshLoaderCount();
-	io::IReadFile* file = smgr->getFileSystem()->createAndOpenFile(buff);
+	io::IReadFile* const file = smgr->getFileSystem()->createAndOpenFile(buff);
+	
 	if (!file)
 		return 0;
 	for (u32 i=0; i<lc; i++) {
 		loader = smgr->getMeshLoader(i);
 		file->seek(0);
@@ -344,15 +347,17 @@
 	}
 
 	delete[] solidity;
 
 	// Add to mesh
-	scene::SMesh *mesh = new scene::SMesh();
+	scene::SMesh* const mesh = new scene::SMesh();
 	mesh->addMeshBuffer(buf);
 	buf->drop();
-	scene::SAnimatedMesh *anim_mesh = new scene::SAnimatedMesh(mesh);
+	
+	scene::SAnimatedMesh* const anim_mesh = new scene::SAnimatedMesh(mesh);
 	mesh->drop();
+	
 	return anim_mesh;
 }
 
 scene::IAnimatedMesh* createExtrudedMesh(video::ITexture *texture,
 		video::IVideoDriver *driver, v3f scale)
@@ -367,16 +372,16 @@
 		if (data == NULL)
 			return NULL;
 		mesh = extrudeARGB(size.Width, size.Height, (u8*) data);
 		texture->unlock();
 	}else{
-		video::IImage *img1 = driver->createImageFromData(format, size, texture->lock(MY_ETLM_READ_ONLY));
+		video::IImage* const img1 = driver->createImageFromData(format, size, texture->lock(MY_ETLM_READ_ONLY));
 		if (img1 == NULL)
 			return NULL;
 
 		// img1 is in the texture's color format, convert to 8-bit ARGB
-		video::IImage *img2 = driver->createImage(video::ECF_A8R8G8B8, size);
+		video::IImage* const img2 = driver->createImage(video::ECF_A8R8G8B8, size);
 		if (img2 != NULL) {
 			img1->copyTo(img2);
 
 			mesh = extrudeARGB(size.Width, size.Height, (u8*) img2->lock());
 			img2->unlock();
@@ -561,16 +566,17 @@
 
 	// Set render target
 	driver->setRenderTarget(rtt, false, true, video::SColor(0,0,0,0));
 
 	// Get a scene manager
-	scene::ISceneManager *smgr_main = device->getSceneManager();
+	scene::ISceneManager* const smgr_main = device->getSceneManager();
 	assert(smgr_main);
-	scene::ISceneManager *smgr = smgr_main->createNewSceneManager();
+	scene::ISceneManager* const smgr = smgr_main->createNewSceneManager();
 	assert(smgr);
 
-	scene::IMeshSceneNode* meshnode = smgr->addMeshSceneNode(mesh, NULL, -1, v3f(0,0,0), v3f(0,0,0), v3f(1,1,1), true);
+	scene::IMeshSceneNode* const meshnode =
+	    smgr->addMeshSceneNode(mesh, NULL, -1, v3f(0,0,0), v3f(0,0,0), v3f(1,1,1), true);
 	meshnode->setMaterialFlag(video::EMF_LIGHTING, true);
 	meshnode->setMaterialFlag(video::EMF_ANTI_ALIASING, true);
 	meshnode->setMaterialFlag(video::EMF_BILINEAR_FILTER, true);
 
 	scene::ICameraSceneNode* camera = smgr->addCameraSceneNode(0,
diff -rU5 voxelands-v1709.00old/src/modalMenu.h voxelands-v1709.00good/src/modalMenu.h
--- voxelands-v1709.00old/src/modalMenu.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/modalMenu.h	2024-06-09 13:17:14.661159546 +0200
@@ -32,10 +32,11 @@
 
 class IMenuManager
 {
 public:
 	// A GUIModalMenu calls these when this class is passed as a parameter
+	virtual ~IMenuManager() {};
 	virtual void createdMenu(GUIModalMenu *menu) = 0;
 	virtual void deletingMenu(GUIModalMenu *menu) = 0;
 };
 
 /*
diff -rU5 voxelands-v1709.00old/src/nvp.c voxelands-v1709.00good/src/nvp.c
--- voxelands-v1709.00old/src/nvp.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/nvp.c	2024-06-09 13:17:14.662159838 +0200
@@ -55,11 +55,11 @@
 			free(n->data);
 	}
 }
 
 /* get a name/value pair */
-nvp_t *nvp_get(nvp_t **list, char* name)
+nvp_t *nvp_get(nvp_t **list,const char* name)
 {
 	nvp_t *c = *list;
 	unsigned int h = hash(name);
 	while (c) {
 		if (c->h > h)
@@ -70,56 +70,56 @@
 	}
 	return NULL;
 }
 
 /* get the value of a name/value pair */
-char* nvp_get_str(nvp_t **list, char* name)
+char* nvp_get_str(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return c->value;
 	return NULL;
 }
 
 /* get the value of a name/value pair as an int value */
-int nvp_get_int(nvp_t **list, char* name)
+int nvp_get_int(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return strtol(c->value,NULL,10);
 	return 0;
 }
 
 /* get the value of a name/value pair as a float value */
-float nvp_get_float(nvp_t **list, char* name)
+float nvp_get_float(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return strtof(c->value,NULL);
 	return 0.0;
 }
 
 /* get the value of a name/value pair as a boolean value */
-int nvp_get_bool(nvp_t **list, char* name)
+int nvp_get_bool(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c && (!strcmp(c->value,"1") || !strcmp(c->value,"true")))
 		return 1;
 	return 0;
 }
 
 /* get a name/value pair's data value */
-void *nvp_get_data(nvp_t **list, char* name)
+void *nvp_get_data(nvp_t **list,const char* name)
 {
 	nvp_t *c = nvp_get(list,name);
 	if (c)
 		return c->data;
 	return NULL;
 }
 
 /* set the value of a name/value pair */
-void nvp_set(nvp_t **list, char* name, char* value, void *data)
+void nvp_set(nvp_t **list,const char* name,const char* value, void *data)
 {
 	nvp_t *c = *list;
 	unsigned int h = hash(name);
 
 	while (c) {
@@ -154,35 +154,35 @@
 
 	*list = list_insert_cmp(list,c,nvp_insert_cmp);
 }
 
 /* set a name/value pair to an int value */
-void nvp_set_int(nvp_t **list, char* name, int value)
+void nvp_set_int(nvp_t **list,const char* name, int value)
 {
 	char str[20];
 	sprintf(str,"%d",value);
 	nvp_set(list,name,str,NULL);
 }
 
 /* set a name/value pair to a float value */
-void nvp_set_float(nvp_t **list, char* name, float value)
+void nvp_set_float(nvp_t **list,const char* name, float value)
 {
 	char str[20];
 	sprintf(str,"%f",value);
 	nvp_set(list,name,str,NULL);
 }
 
 /* set a name/value pair to a float value */
-void nvp_set_v3t(nvp_t **list, char* name, v3_t *value)
+void nvp_set_v3t(nvp_t **list,const char* name, v3_t *value)
 {
 	char str[128];
 	sprintf(str,"(%f,%f,%f)",value->x,value->y,value->z);
 	nvp_set(list,name,str,NULL);
 }
 
 /* parse a name=value string to an nvp list */
-void nvp_from_str(nvp_t **list, char* str)
+void nvp_from_str(nvp_t **list,const char* str)
 {
 	char name[512];
 	char value[512];
 	uint8_t is_str = 0;
 	uint8_t is_value = 0;
diff -rU5 voxelands-v1709.00old/src/nvp.h voxelands-v1709.00good/src/nvp.h
--- voxelands-v1709.00old/src/nvp.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/nvp.h	2024-06-09 13:17:14.662159838 +0200
@@ -21,21 +21,21 @@
 } nvp_t;
 #endif
 
 /* defined in nvp.c */
 void nvp_free(nvp_t **list, int data);
-nvp_t *nvp_get(nvp_t **list, char* name);
-char* nvp_get_str(nvp_t **list, char* name);
-int nvp_get_int(nvp_t **list, char* name);
-float nvp_get_float(nvp_t **list, char* name);
-int nvp_get_bool(nvp_t **list, char* name);
-void *nvp_get_data(nvp_t **list, char* name);
-void nvp_set(nvp_t **list, char* name, char* value, void *data);
-void nvp_set_int(nvp_t **list, char* name, int value);
-void nvp_set_float(nvp_t **list, char* name, float value);
-void nvp_set_v3t(nvp_t **list, char* name, struct v3_s *value);
-void nvp_from_str(nvp_t **list, char* str);
+nvp_t *nvp_get(nvp_t **list,const char* name);
+char* nvp_get_str(nvp_t **list,const char* name);
+int nvp_get_int(nvp_t **list,const char* name);
+float nvp_get_float(nvp_t **list,const char* name);
+int nvp_get_bool(nvp_t **list,const char* name);
+void *nvp_get_data(nvp_t **list,const char* name);
+void nvp_set(nvp_t **list,const char* name,const char* value, void *data);
+void nvp_set_int(nvp_t **list,const char* name, int value);
+void nvp_set_float(nvp_t **list,const char* name, float value);
+void nvp_set_v3t(nvp_t **list,const char* name, struct v3_s *value);
+void nvp_from_str(nvp_t **list,const char* str);
 int nvp_to_str(nvp_t **list, char* buff, int size);
 
 #ifdef __cplusplus
 }
 #endif
diff -rU5 voxelands-v1709.00old/src/path.c voxelands-v1709.00good/src/path.c
--- voxelands-v1709.00old/src/path.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/path.c	2024-06-09 13:17:14.662159838 +0200
@@ -59,11 +59,11 @@
 	NULL,
 	NULL,
 	NULL
 };
 
-int path_check(char* base, char* rel)
+static int path_check(char* base,const char* rel)
 {
 	int l;
 	char path[2048];
 #ifndef WIN32
 	struct stat st;
@@ -103,11 +103,11 @@
 #endif
 
 	return 0;
 }
 
-static char* path_set(char* base, char* rel, char* buff, int size)
+static char* path_set(char* base,const char* rel, char* buff, int size)
 {
 	int l;
 	char path[2048];
 
 	if (!base && !rel)
@@ -342,11 +342,11 @@
 		free(path.screenshot);
 	path.screenshot = NULL;
 }
 
 /* sets path.data_custom */
-int path_custom_setter(char* p)
+int path_custom_setter(const char* p)
 {
 	if (path.data_custom)
 		free(path.data_custom);
 	path.data_custom = NULL;
 
@@ -355,11 +355,11 @@
 
 	return 0;
 }
 
 /* sets path.screenshot */
-int path_screenshot_setter(char* p)
+int path_screenshot_setter(const char* p)
 {
 	if (path.screenshot)
 		free(path.screenshot);
 	path.screenshot = NULL;
 
@@ -368,11 +368,11 @@
 
 	return 0;
 }
 
 /* sets the world path to user_data + /worlds/ + p, creates the path if necessary */
-int path_world_setter(char* p)
+int path_world_setter(const char* p)
 {
 	int c;
 	char buff[2048];
 	char* base = path.data_user;
 
@@ -419,11 +419,11 @@
  *
  * returns the path or NULL if either:
  *	must_exist is non-zero and the path doesn't exist
  *	buff is not NULL and too small to hold the full path
  */
-char* path_get(char* type, char* file, int must_exist, char* buff, int size)
+char* path_get(const char* type,const char* file, int must_exist, char* buff, int size)
 {
 	char rel_path[1024];
 
 	if (!file && !type)
 		return NULL;
@@ -501,11 +501,11 @@
 	}else if (!strcmp(type,"sound")) {
 		snprintf(rel_path,1024,"sounds/%s",file);
 	}else if (!strcmp(type,"font")) {
 		snprintf(rel_path,1024,"fonts/%s",file);
 	}else if (!strncmp(type,"translation-",12)) {
-		char* lang = type+12;
+		const char* lang = type+12;
 		type = "translation";
 		snprintf(rel_path,1024,"locale/%s/%s",lang,file);
 	}else{
 		strcpy(rel_path,file);
 	}
diff -rU5 voxelands-v1709.00old/src/path.h voxelands-v1709.00good/src/path.h
--- voxelands-v1709.00old/src/path.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/path.h	2024-06-09 13:17:14.662159838 +0200
@@ -16,14 +16,14 @@
 #endif
 
 /* defined in path.c */
 int path_init(void);
 void path_exit(void);
-int path_custom_setter(char* p);
-int path_screenshot_setter(char* p);
-int path_world_setter(char* p);
-char* path_get(char* type, char* file, int must_exist, char* buff, int size);
+int path_custom_setter(const char* p);
+int path_screenshot_setter(const char* p);
+int path_world_setter(const char* p);
+char* path_get(const char* type,const char* file, int must_exist, char* buff, int size);
 int path_exists(char* path);
 int path_create(char* type, char* file);
 int path_remove(char* type, char* path);
 dirlist_t *path_dirlist(char* type, char* path);
 void path_dirlist_free(dirlist_t *l);
diff -rU5 voxelands-v1709.00old/src/player.cpp voxelands-v1709.00good/src/player.cpp
--- voxelands-v1709.00old/src/player.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/player.cpp	2024-06-09 14:16:59.265264200 +0200
@@ -213,11 +213,11 @@
 }
 
 void Player::serialize(std::ostream &os)
 {
 	// Utilize a Settings object for storing values
-	char* flags[8] = {
+	const char* flags[8] = {
 		"flag_white",
 		"flag_blue",
 		"flag_green",
 		"flag_orange",
 		"flag_purple",
@@ -279,13 +279,13 @@
 
 void Player::deSerialize(std::istream &is)
 {
 	nvp_t *list = NULL;
 	std::string conf;
-	char* val;
+	const char* val;
 	v3_t v;
-	char* flags[8] = {
+	const char* flags[8] = {
 		"flag_white",
 		"flag_blue",
 		"flag_green",
 		"flag_orange",
 		"flag_purple",
@@ -637,11 +637,11 @@
 		if (!m_text)
 			return;
 		m_text->setPosition(v3f(0, (f32)BS*2.1, 0));
 
 		// get a unique mesh so that the player model has it's own lighting
-		scene::IAnimatedMesh* mesh = createModelMesh(mgr,"character.b3d",true);
+		scene::IAnimatedMesh* const mesh = createModelMesh(mgr,"character.b3d",true);
 		if (!mesh)
 			return;
 
 		m_node = mgr->addAnimatedMeshSceneNode(mesh,this);
 
@@ -699,11 +699,11 @@
 void RemotePlayer::wieldItem(u16 item)
 {
 	m_selected_item = item;
 	if (!m_wield)
 		return;
-	const InventoryItem *i = getWieldItem();
+	const InventoryItem* const i = getWieldItem();
 	if (!i) {
 		m_wield->setVisible(false);
 		return;
 	}
 	bool haveWield = false;
@@ -764,17 +764,21 @@
 	m_showpos = m_oldpos + movevector * moveratio;
 
 	int frame = m_node->getFrameNr();
 	/* roughly sort of when a step sound should probably be heard, maybe */
 	if (frame == 218 || frame == 186 || frame == 209 || frame == 177) {
+#if USE_AUDIO == 1
 		sound_play_step(&map,m_showpos,m_next_foot,1.0);
+#endif
 		m_next_foot = !m_next_foot;
 	}
 	/* roughly sort of when a dig sound should probably be heard, maybe */
+#if USE_AUDIO == 1
 	if (frame == 214 || frame == 205 || frame == 193) {
 		sound_play_dig(m_pointed,m_showpos);
 	}
+#endif
 
 	if (m_anim_id == PLAYERANIM_DIE) {
 		if (m_node->getEndFrame() != 167)
 			m_node->setFrameLoop(162,167);
 	}else{
@@ -859,11 +863,11 @@
 	m_sneak_node_exists(false),
 	m_can_use_energy(true),
 	m_ignore_energy(false),
 	m_low_energy_effect(0)
 {
-	char* v;
+	const char* v;
 	m_energy = 10.0;
 
 	v = config_get("client.character");
 	if (!v)
 		v = PLAYER_DEFAULT_CHARDEF;
@@ -1237,11 +1241,10 @@
 				m_character = std::string(PLAYER_DEFAULT_CHARDEF);
 			Strfnd f(m_character);
 			std::string gender = f.next(":");
 			std::string snd("low-energy-");
 			snd += gender;
-
 			m_low_energy_effect = sound_play_effect((char*)snd.c_str(),1.0,1,NULL);
 		}
 #endif
 	}else if (m_energy > 9.8) {
 		m_can_use_energy = true;
diff -rU5 voxelands-v1709.00old/src/player.h voxelands-v1709.00good/src/player.h
--- voxelands-v1709.00old/src/player.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/player.h	2024-06-09 13:17:14.662159838 +0200
@@ -187,11 +187,11 @@
 	}
 
 	virtual void wieldItem(u16 item);
 	virtual const InventoryItem *getWieldItem() const
 	{
-		const InventoryList *list = inventory.getList("main");
+		const InventoryList* const list = inventory.getList("main");
 		if (list)
 			return list->getItem(m_selected_item);
 		return NULL;
 	}
 	virtual u16 getSelectedItem() {return m_selected_item;}
diff -rU5 voxelands-v1709.00old/src/profiler.h voxelands-v1709.00good/src/profiler.h
--- voxelands-v1709.00old/src/profiler.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/profiler.h	2024-06-12 21:55:52.383879387 +0200
@@ -37,11 +37,11 @@
 */
 
 class Profiler
 {
 public:
-	Profiler()
+	Profiler() : m_mutex(),m_data(),m_avgcounts()
 	{
 		m_mutex.Init();
 	}
 
 	void add(const std::string &name, float value)
diff -rU5 voxelands-v1709.00old/src/selection_mesh.cpp voxelands-v1709.00good/src/selection_mesh.cpp
--- voxelands-v1709.00old/src/selection_mesh.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/selection_mesh.cpp	2024-06-09 13:17:14.662159838 +0200
@@ -318,18 +318,18 @@
 		}
 
 		// Create meshbuffer
 		// This is a "Standard MeshBuffer",
 		// it's a typedeffed CMeshBuffer<video::S3DVertex>
-		scene::SMeshBuffer *buf = new scene::SMeshBuffer();
+		scene::SMeshBuffer* const buf = new scene::SMeshBuffer();
+		
 		// Set material
 		buf->Material = d.tile.getMaterial();
 		// Add to mesh
 		mesh->addMeshBuffer(buf);
 		// Mesh grabbed it
 		buf->drop();
-
 		buf->append(d.vertices.data(), d.vertices.size(), d.indices.data(), d.indices.size());
 	}
 
 	translateMesh(mesh, intToFloat(data->m_blockpos_nodes - o_camera_offset, BS));
 
diff -rU5 voxelands-v1709.00old/src/server.cpp voxelands-v1709.00good/src/server.cpp
--- voxelands-v1709.00old/src/server.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/server.cpp	2024-06-12 21:28:23.536184482 +0200
@@ -85,12 +85,13 @@
 };
 
 void * ServerThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("ServerThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
@@ -122,12 +123,13 @@
 }
 
 void * EmergeThread::Thread()
 {
 	ThreadStarted();
-
+	log_mutex.Lock();
 	log_register_thread("EmergeThread");
+	log_mutex.Unlock();
 
 	DSTACK(__FUNCTION_NAME);
 
 	BEGIN_DEBUG_EXCEPTION_HANDLER
 
@@ -192,11 +194,12 @@
 
 			}
 		}
 
 		//vlprintf(CN_DEBUG,"EmergeThread: p=(%d,%d,%d) only_from_disk = %d",p.X,p.Y,p.Z,only_from_disk);
-
+		
+		JMutexAutoLock envlock(m_server->m_env_mutex);
 		ServerMap &map = ((ServerMap&)m_server->m_env.getMap());
 
 		//core::map<v3s16, MapBlock*> changed_blocks;
 		//core::map<v3s16, MapBlock*> lighting_invalidated_blocks;
 
@@ -206,12 +209,10 @@
 
 		/*
 			Fetch block from map or generate a single block
 		*/
 		{
-			JMutexAutoLock envlock(m_server->m_env_mutex);
-
 			// Load sector if it isn't loaded
 			map.getSectorNoGenerateNoEx(p2d);
 
 			block = map.getBlockNoCreateNoEx(p);
 			if (!block || block->isDummy() || !block->isGenerated()) {
@@ -348,10 +349,12 @@
 void RemoteClient::GetNextBlocks(Server *server, float dtime,
 		core::array<PrioritySortedBlockTransfer> &dest)
 {
 	DSTACK(__FUNCTION_NAME);
 
+    // Protected by mutexs in the caller.
+	
 	/*u32 timer_result;
 	TimeTaker timer("RemoteClient::GetNextBlocks", &timer_result);*/
 
 	// Increment timers
 	m_nothing_to_send_pause_timer -= dtime;
@@ -1442,10 +1445,12 @@
 		Send queued-for-sending map edit events.
 	*/
 	{
 		// Don't send too many at a time
 		//u32 count = 0;
+		JMutexAutoLock envlock(m_env_mutex);
+		JMutexAutoLock conlock(m_con_mutex);
 
 		// Single change sending is disabled if queue size is not small
 		bool disable_single_change_sending = false;
 		if(m_unsent_map_edit_queue.size() >= 4)
 			disable_single_change_sending = true;
@@ -1561,17 +1566,13 @@
 	*/
 	{
 		float &counter = m_objectdata_timer;
 		counter += dtime;
 		if (counter >= config_get_float("server.net.client.object.interval")) {
-			JMutexAutoLock lock1(m_env_mutex);
-			JMutexAutoLock lock2(m_con_mutex);
-
 			//ScopeProfiler sp(g_profiler, "Server: sending player positions");
 
 			SendPlayerInfo(counter);
-
 			counter = 0.0;
 		}
 	}
 
 	/*
@@ -1819,11 +1820,11 @@
 		char checkpwd[64];
 		if (auth_exists(playername)) {
 			if (auth_getpwd(playername,checkpwd))
 				checkpwd[0] = 0;
 		}else{
-			char* default_pwd = config_get("world.server.client.default.password");
+			const char* default_pwd = config_get("world.server.client.default.password");
 			if (default_pwd && default_pwd[0]) {
 				std::string defaultpwd = translatePassword(playername,narrow_to_wide(defaultpwd));
 				strcpy(checkpwd,defaultpwd.c_str());
 			}else{
 				strcpy(checkpwd,password);
@@ -1843,11 +1844,11 @@
 
 		// Add player to auth manager
 		if (!auth_exists(playername)) {
 			infostream<<"Server: adding player "<<playername<<" to auth manager"<<std::endl;
 			uint64_t privs = 0;
-			char* priv = config_get("world.server.client.default.privs");
+			const char* priv = config_get("world.server.client.default.privs");
 			if (priv)
 				privs = auth_str2privs(priv);
 
 			auth_add(playername);
 			auth_setpwd(playername,checkpwd);
@@ -1855,11 +1856,11 @@
 			auth_save();
 		}
 
 		// Enforce user limit.
 		// Don't enforce for users that have some admin right
-		char* admin_name = config_get("world.server.admin");
+		const char* admin_name = config_get("world.server.admin");
 		if (
 			m_clients.size() >= (uint16_t)config_get_int("world.server.client.max")
 			&& (auth_getprivs(playername) & (PRIV_SERVER|PRIV_BAN|PRIV_PRIVS)) == 0
 			&& (!admin_name || strcmp(admin_name,playername))
 		) {
@@ -2037,11 +2038,11 @@
 
 		if ((getPlayerPrivs(player) & PRIV_BUILD) == 0)
 			return;
 
 		ToolItem *titem = NULL;
-		InventoryList *ilist = player->inventory.getList("main");
+		InventoryList* const ilist = player->inventory.getList("main");
 		if (ilist == NULL)
 			return;
 
 		// Get item
 		InventoryItem *item = ilist->getItem(item_i);
@@ -2088,11 +2089,11 @@
 		}
 
 		v3f pf((f32)ps.X/100., (f32)ps.Y/100., (f32)ps.Z/100.);
 		v3f sf((f32)ss.X/100., (f32)ss.Y/100., (f32)ss.Z/100.);
 
-		ServerActiveObject *obj = new MobSAO(&m_env, 0, pf, sf*content_mob_features(thrown).static_thrown_speed*BS, thrown);
+		ServerActiveObject* const obj = new MobSAO(&m_env, 0, pf, sf*content_mob_features(thrown).static_thrown_speed*BS, thrown);
 
 		if (obj == NULL) {
 			infostream<<"WARNING: item resulted in NULL object, "
 							<<"not throwing into map"
 							<<std::endl;
@@ -2109,11 +2110,11 @@
 			if (item->getCount() <= 1) {
 				if (item->getCount() < 1)
 					infostream<<"WARNING: Server: dropped more items"
 							<<" than the slot contains"<<std::endl;
 
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (ilist)
 					// Remove from inventory and send inventory
 					ilist->deleteItem(item_i);
 			}else{
 				item->remove(1);
@@ -2125,18 +2126,18 @@
 		}
 	}
 	break;
 	case TOSERVER_USEITEM:
 	{
-		InventoryList *ilist = player->inventory.getList("main");
+		InventoryList* const ilist = player->inventory.getList("main");
 		if (ilist == NULL)
 			return;
 
-		u16 item_i = player->getSelectedItem();
+		const u16 item_i = player->getSelectedItem();
 
 		// Get item
-		InventoryItem *item = ilist->getItem(item_i);
+		InventoryItem* const item = ilist->getItem(item_i);
 		if (item == NULL)
 			return;
 
 		// Track changes super-crappily
 		u16 oldhp = player->health;
@@ -2276,29 +2277,29 @@
 		// Left click, pick object up (usually)
 		if (button == 0) {
 			content_t wield_item = CONTENT_IGNORE;
 			ToolItem *titem = NULL;
 
-			InventoryList *mlist = player->inventory.getList("main");
+			InventoryList* const mlist = player->inventory.getList("main");
 			if (mlist != NULL) {
-				InventoryItem *item = mlist->getItem(item_i);
+				InventoryItem* const item = mlist->getItem(item_i);
 				if (item) {
 					wield_item = item->getContent();
 					if ((wield_item&CONTENT_TOOLITEM_MASK) == CONTENT_TOOLITEM_MASK)
 						titem = (ToolItem*)item;
 				}
 			}
 			/*
 				Try creating inventory item
 			*/
-			InventoryItem *item = obj->createPickedUpItem(wield_item);
+			InventoryItem* item = obj->createPickedUpItem(wield_item);
 
 			if (item) {
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (ilist != NULL) {
-					actionstream<<player->getName()<<" picked up "
-							<<item->getName()<<std::endl;
+					actionstream << player->getName() << " picked up "
+							<< item->getName() << std::endl;
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Skip if inventory has no free space
 						if (ilist->roomForItem(item) == false) {
 							infostream<<"Player inventory has no free space"<<std::endl;
 							return;
@@ -2335,11 +2336,11 @@
 						&& obj->getType() == ACTIVEOBJECT_TYPE_MOB
 					) {
 						InventoryList *mlist = player->inventory.getList("main");
 						if (mlist != NULL) {
 							for (u32 i=0; i<(8*4); i++) {
-								InventoryItem *item = mlist->getItem(i);
+								InventoryItem* const item = mlist->getItem(i);
 								if (item && item->getContent() == CONTENT_TOOLITEM_MOB_SPAWNER && item->getData() == 0) {
 									MobSAO *mob = (MobSAO*)obj;
 									item->setData(mob->getContent());
 									obj->m_removed = true;
 									if (config_get_bool("world.player.tool.wear")) {
@@ -2360,14 +2361,14 @@
 
 				u16 wear = obj->punch(wield_item, dir, player->getName());
 				item = obj->createPickedUpItem(wield_item);
 				/* killing something might have caused a drop */
 				if (item) {
-					InventoryList *ilist = player->inventory.getList("main");
+					InventoryList* const ilist = player->inventory.getList("main");
 					if (ilist != NULL) {
 						actionstream<<player->getName()<<" picked up "
-								<<item->getName()<<std::endl;
+								<< item->getName() << std::endl;
 						if (!config_get_bool("world.player.inventory.creative")) {
 							// Skip if inventory has no free space
 							if (ilist->roomForItem(item) == false) {
 								infostream<<"Player inventory has no free space"<<std::endl;
 								return;
@@ -2471,14 +2472,12 @@
 				if (pp.getDistanceFrom(spf) <= sg)
 					return;
 			}
 		}
 
-		InventoryItem *wielditem = (InventoryItem*)player->getWieldItem();
-		content_t wieldcontent = CONTENT_IGNORE;
-		if (wielditem)
-			wieldcontent = wielditem->getContent();
+		InventoryItem* const wielditem = (InventoryItem*) player->getWieldItem();
+		const content_t wieldcontent = wielditem ? wielditem->getContent() : CONTENT_IGNORE;
 		ToolItemFeatures wielded_tool_features = content_toolitem_features(wieldcontent);
 		CraftItemFeatures *wielded_craft_features = content_craftitem_features(wieldcontent);
 		ContentFeatures &wielded_material_features = content_features(wieldcontent);
 
 		bool selected_node_exists = false;
@@ -2554,18 +2553,18 @@
 					}
 					selected_node.setContent(c);
 					// send the node
 					sendAddNode(p_under, selected_node, 0, &far_players, 30);
 					// wear out the key - admin's key doesn't wear
-					ToolItem *titem = (ToolItem*)wielditem;
+					ToolItem* const titem = (ToolItem*)wielditem;
 					if (
 						!wielded_tool_features.has_super_unlock_effect
 						&& (getPlayerPrivs(player) & PRIV_SERVER) == 0
 						&& config_get_bool("world.player.tool.wear")
 					) {
 						bool weared_out = titem->addWear(1);
-						InventoryList *mlist = player->inventory.getList("main");
+						InventoryList* const mlist = player->inventory.getList("main");
 						if (weared_out) {
 							mlist->deleteItem(item_i);
 						}else{
 							mlist->addDiff(item_i,titem);
 						}
@@ -2612,11 +2611,11 @@
 				if (inv) {
 					InventoryList *list = inv->getList("main");
 					if (list) {
 						u16 max = list->getSize();
 						for (u16 i=0; i<max; i++) {
-							InventoryItem *itm = list->changeItem(i,NULL);
+							InventoryItem* const itm = list->changeItem(i,NULL);
 							if (!itm)
 								continue;
 							player->inventory.addItem("main", itm);
 						}
 						// Send inventory
@@ -2748,11 +2747,11 @@
 						if (client == NULL)
 							continue;
 						client->SetBlocksNotSent(modified_blocks);
 					}
 				}
-				ToolItem *titem = (ToolItem*)wielditem;
+				ToolItem* const titem = (ToolItem*)wielditem;
 				if (config_get_bool("world.player.tool.wear")) {
 					bool weared_out = titem->addWear(1);
 					InventoryList *mlist = player->inventory.getList("main");
 					if (weared_out) {
 						mlist->deleteItem(item_i);
@@ -2768,11 +2767,11 @@
 					meta = m_env.getMap().getNodeMetadata(p_under);
 					if (meta && !meta->getEnergy()) {
 						v3s16 pp = floatToInt(player->getPosition(),BS);
 						meta->energise(ENERGY_MAX,pp,pp,p_under);
 					}
-					ToolItem *titem = (ToolItem*)wielditem;
+					ToolItem* const titem = (ToolItem*) wielditem;
 					if (config_get_bool("world.player.tool.wear")) {
 						bool weared_out = titem->addWear(1);
 						InventoryList *mlist = player->inventory.getList("main");
 						if (weared_out) {
 							mlist->deleteItem(item_i);
@@ -2798,11 +2797,11 @@
 			) {
 				BarrelNodeMetadata *bmeta = (BarrelNodeMetadata*)m_env.getMap().getNodeMetadata(p_under);
 				if (!bmeta)
 					return;
 				if (wielded_tool_features.type == TT_BUCKET) {
-					content_t c = wielditem->getData();
+					const content_t c = wielditem->getData();
 					if (!c) {
 						if (bmeta->m_water_level < 4)
 							return;
 						wielditem->setData(CONTENT_WATERSOURCE);
 						InventoryList *mlist = player->inventory.getList("main");
@@ -2935,11 +2934,11 @@
 			}else if (selected_content == CONTENT_CAULDRON) {
 				CauldronNodeMetadata *cmeta = (CauldronNodeMetadata*)m_env.getMap().getNodeMetadata(p_under);
 				if (!cmeta)
 					return;
 				if (wielded_tool_features.type == TT_BUCKET) {
-					content_t c = wielditem->getData();
+					const content_t c = wielditem->getData();
 					if (!c) {
 						if (cmeta->m_water_level != 4)
 							return;
 						wielditem->setData(CONTENT_WATERSOURCE);
 						InventoryList *mlist = player->inventory.getList("main");
@@ -2977,13 +2976,13 @@
 						client->SetBlocksNotSent(modified_blocks);
 						client->SetBlockNotSent(blockpos);
 					}
 				}else if (wieldcontent == CONTENT_CRAFTITEM_IRON_BOTTLE) {
 					if (cmeta->m_water_level && cmeta->m_water_hot && wielditem->getCount() == 1) {
-						InventoryItem *itm = InventoryItem::create(CONTENT_CRAFTITEM_IRON_BOTTLE_WATER,1,0);
-						InventoryList *mlist = player->inventory.getList("main");
-						InventoryItem *old = mlist->changeItem(item_i,itm);
+						InventoryItem* const itm = InventoryItem::create(CONTENT_CRAFTITEM_IRON_BOTTLE_WATER,1,0);
+						InventoryList* const mlist = player->inventory.getList("main");
+						InventoryItem* const old = mlist->changeItem(item_i,itm);
 						if (old)
 							delete old;
 						cmeta->m_water_level--;
 						SendInventory(player->peer_id);
 						v3s16 blockpos = getNodeBlockPos(p_under);
@@ -3003,19 +3002,19 @@
 							client->SetBlockNotSent(blockpos);
 						}
 					}
 				}else if (wieldcontent == CONTENT_CRAFTITEM_GLASS_BOTTLE) {
 					if (cmeta->m_water_level && cmeta->m_water_heated && !cmeta->m_water_hot && wielditem->getCount() == 1) {
-						InventoryItem *itm = InventoryItem::create(CONTENT_CRAFTITEM_GLASS_BOTTLE_WATER,1,0);
-						InventoryList *mlist = player->inventory.getList("main");
-						InventoryItem *old = mlist->changeItem(item_i,itm);
+						InventoryItem* const itm = InventoryItem::create(CONTENT_CRAFTITEM_GLASS_BOTTLE_WATER,1,0);
+						InventoryList* const mlist = player->inventory.getList("main");
+						InventoryItem* const old = mlist->changeItem(item_i,itm);
 						if (old)
 							delete old;
 						cmeta->m_water_level--;
 						SendInventory(player->peer_id);
 						v3s16 blockpos = getNodeBlockPos(p_under);
-						MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+						MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 						if (!block)
 							return;
 						block->setChangedFlag();
 						core::map<v3s16, MapBlock*> modified_blocks;
 						modified_blocks.insert(block->getPos(),block);
@@ -3037,11 +3036,11 @@
 				InventoryList *ilist = meta->getInventory()->getList("fuel");
 				InventoryList *plist = player->inventory.getList("main");
 				if (plist == NULL || ilist == NULL)
 					return;
 				if (((IncineratorNodeMetadata*)meta)->m_fuel_totaltime <= ((IncineratorNodeMetadata*)meta)->m_fuel_time) {
-					InventoryItem *fitem = ilist->getItem(0);
+					InventoryItem* const fitem = ilist->getItem(0);
 					if (!fitem || !fitem->getCount() || !fitem->isFuel())
 						return;
 					((IncineratorNodeMetadata*)meta)->m_should_fire = true;
 				}
 				plist->deleteItem(item_i);
@@ -3101,11 +3100,11 @@
 					// send the node
 					core::list<u16> far_players;
 					core::map<v3s16, MapBlock*> modified_blocks;
 					sendAddNode(p_under, selected_node, 0, &far_players, 30);
 					// wear out the crowbar
-					ToolItem *titem = (ToolItem*)wielditem;
+					ToolItem* const titem = (ToolItem*)wielditem;
 					if (config_get_bool("world.player.tool.wear")) {
 						bool weared_out = titem->addWear(1);
 						InventoryList *mlist = player->inventory.getList("main");
 						if (weared_out) {
 							mlist->deleteItem(item_i);
@@ -3148,11 +3147,11 @@
 				core::map<v3s16, MapBlock*> modified_blocks;
 				sendAddNode(p_under, selected_node, 0, &far_players, 30);
 				/*
 					Handle inventory
 				*/
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (!config_get_bool("world.player.inventory.creative") && ilist) {
 					// Remove from inventory and send inventory
 					if (wielditem->getCount() == 1) {
 						ilist->deleteItem(item_i);
 					}else{
@@ -3169,11 +3168,11 @@
 
 					std::string p_name = std::string(player->getName());
 					m_env.getMap().addNodeAndUpdate(p_under, selected_node, modified_blocks, p_name);
 				}
 				v3s16 blockpos = getNodeBlockPos(p_under);
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 				if (block)
 					block->setChangedFlag();
 
 				for(core::map<u16, RemoteClient*>::Iterator
 					i = m_clients.getIterator();
@@ -3455,13 +3454,13 @@
 				/*
 					Wear out tool
 				*/
 				InventoryList *mlist = player->inventory.getList("main");
 				if (mlist != NULL && config_get_bool("world.player.tool.wear")) {
-					InventoryItem *item = mlist->getItem(item_i);
+					InventoryItem* const item = mlist->getItem(item_i);
 					if (item && (item->getContent()&CONTENT_TOOLITEM_MASK) == CONTENT_TOOLITEM_MASK) {
-						ToolItem *titem = (ToolItem*)item;
+						ToolItem* const titem = (ToolItem*) item;
 						// Get digging properties for material and tool
 						tooluse_t usage;
 						if (get_tool_use(&usage,selected_content,mineral,titem->getContent(),titem->getData())) {
 							infostream<<"Server: WARNING: Player digged"
 								<<" with impossible material + tool"
@@ -3495,11 +3494,11 @@
 						Inventory *inv = meta->getInventory();
 						if (inv) {
 							InventoryList *l = inv->getList("0");
 							if (l) {
 								for (u32 i=0; i<32; i++) {
-									InventoryItem *itm = l->changeItem(i,NULL);
+									InventoryItem* const itm = l->changeItem(i,NULL);
 									if (!itm)
 										continue;
 									player->inventory.addItem("main", itm);
 								}
 								// Send inventory
@@ -3531,14 +3530,16 @@
 							SendInventory(player->peer_id);
 						}
 					}
 				}else if (selected_node_features.liquid_type == LIQUID_NONE) {
 					std::string &dug_s = selected_node_features.dug_item;
-					if (wielded_tool_features.type != TT_NONE && enchantment_have(wielditem->getData(),ENCHANTMENT_DONTBREAK)) {
+					if (wielded_tool_features.type != TT_NONE
+							&& enchantment_have(wielditem->getData(),ENCHANTMENT_DONTBREAK)) {
 						u16 data = 0;
-						if (selected_node_features.param_type == CPT_MINERAL || selected_node_features.param_type == CPT_BLOCKDATA)
-							data = selected_node.param1;
+						if (selected_node_features.param_type == CPT_MINERAL
+								|| selected_node_features.param_type == CPT_BLOCKDATA)
+						    data = selected_node.param1;
 						item = InventoryItem::create(selected_content,1,0,data);
 					}else if (
 						wielded_tool_features.type != TT_NONE
 						&& enchantment_have(wielditem->getData(),ENCHANTMENT_FLAME)
 						&& selected_node_features.cook_result != ""
@@ -3562,16 +3563,16 @@
 							}
 							if (extra == CONTENT_IGNORE) {
 								if ((selected_node.param1&0x20) == 0x20)
 									mineral = MINERAL_SALT;
 							}else if (myrand_range(0,5) == 0) {
-								InventoryItem *eitem = InventoryItem::create(extra,1,0);
+								InventoryItem* const eitem = InventoryItem::create(extra,1,0);
 								player->inventory.addItem("main", eitem);
 							}
 						}
 						if (item && selected_node_features.item_param_type == CPT_METADATA) {
-							NodeMetadata *meta = m_env.getMap().getNodeMetadata(p_under);
+							NodeMetadata* const meta = m_env.getMap().getNodeMetadata(p_under);
 							if (meta) {
 								uint16_t v = meta->getData();
 								item->setData(v);
 							}
 						}
@@ -3584,13 +3585,11 @@
 								if (selected_node_features.plantgrowth_small_dug_node != CONTENT_IGNORE) {
 									u16 count = 1;
 									if (p2 > 3)
 										count = 2;
 									item = InventoryItem::create(
-										selected_node_features.plantgrowth_small_dug_node,
-										count
-									);
+										selected_node_features.plantgrowth_small_dug_node,count);
 								}
 							}else{
 								if (selected_node_features.plantgrowth_large_gives_small) {
 									item = InventoryItem::create(
 										selected_node_features.plantgrowth_small_dug_node,
@@ -3607,13 +3606,11 @@
 									}
 								}
 								if (!count)
 									count = 1;
 								item = InventoryItem::create(
-									selected_node_features.plantgrowth_large_dug_node,
-									count
-								);
+									selected_node_features.plantgrowth_large_dug_node,count);
 							}
 						}else if (selected_node_features.draw_type == CDT_MELONLIKE) {
 							if (p2) {
 								if (p2 > 4) {
 									u16 count = 1;
@@ -3625,25 +3622,20 @@
 									item = InventoryItem::create(CONTENT_CRAFTITEM_MUSH,count,0);
 									player->inventory.addItem("main", item);
 								}
 								if (selected_node_features.plantgrowth_small_dug_node != CONTENT_IGNORE)
 									item = InventoryItem::create(
-										selected_node_features.plantgrowth_small_dug_node,
-										1
-									);
+										selected_node_features.plantgrowth_small_dug_node,1);
 							}else{
 								if (selected_node_features.plantgrowth_large_gives_small) {
 									item = InventoryItem::create(
-										selected_node_features.plantgrowth_small_dug_node,
-										1
-									);
+										selected_node_features.plantgrowth_small_dug_node,1);
 									player->inventory.addItem("main", item);
 								}
 								item = InventoryItem::create(
 									selected_node_features.plantgrowth_large_dug_node,
-									selected_node_features.plantgrowth_large_count
-								);
+									selected_node_features.plantgrowth_large_count);
 							}
 						}
 					}
 				}
 
@@ -3715,16 +3707,16 @@
 			1: place block
 		*/
 		else if(action == 1)
 		{
 			v3s16 p_dir = p_under - p_over;
-			InventoryList *ilist = player->inventory.getList("main");
+			InventoryList* const ilist = player->inventory.getList("main");
 			if (ilist == NULL)
 				return;
 
 			// Get item
-			InventoryItem *item = ilist->getItem(item_i);
+			InventoryItem* const item = ilist->getItem(item_i);
 
 			// If there is no item, it is not possible to add it anywhere
 			if (item == NULL)
 				return;
 
@@ -3988,14 +3980,14 @@
 				uint16_t idata = item->getData();
 
 				/*
 					Handle inventory
 				*/
-				InventoryList *ilist = player->inventory.getList("main");
+				InventoryList* const ilist = player->inventory.getList("main");
 				if (!config_get_bool("world.player.inventory.creative") && ilist) {
 					if ((wieldcontent&CONTENT_TOOLITEM_MASK) == CONTENT_TOOLITEM_MASK) {
-						ToolItem *titem = (ToolItem*)wielditem;
+						ToolItem* const titem = (ToolItem*)wielditem;
 						if (titem->addWear(1)) {
 							ilist->deleteItem(item_i);
 						}else{
 							wielditem->setData(0);
 							ilist->addDiff(item_i,wielditem);
@@ -4085,16 +4077,13 @@
 				}
 
 				if (!config_get_bool("world.player.inventory.creative")) {
 					if (wielded_tool_features.onplace_replace_item != CONTENT_IGNORE) {
 						u16 wear = ((ToolItem*)wielditem)->getWear();
-						InventoryItem *item = InventoryItem::create(
-							wielded_tool_features.onplace_replace_item,
-							1,
-							wear
-						);
-						InventoryItem *citem = ilist->changeItem(item_i,item);
+						InventoryItem* const item = InventoryItem::create(
+							wielded_tool_features.onplace_replace_item,1,wear);
+						InventoryItem* const citem = ilist->changeItem(item_i,item);
 						if (citem)
 							delete citem;
 					}else{
 						ilist->deleteItem(item_i);
 					}
@@ -4139,19 +4128,19 @@
 					infostream<<"Not allowing player to drop item: "
 							"no build privs"<<std::endl;
 					return;
 				}
 				MapNode n = m_env.getMap().getNodeNoEx(p_over);
-				if (n.getContent() != CONTENT_AIR)
+				if (n.getContent() != CONTENT_AIR || !item)
 					return;
 				n.setContent(content_craftitem_features(item->getContent())->drop_item);
 				core::list<u16> far_players;
 				sendAddNode(p_over, n, 0, &far_players, 30);
 				if (!config_get_bool("world.player.inventory.creative")) {
 					// Delete the right amount of items from the slot
 					u16 dropcount = item->getDropCount();
-					InventoryList *ilist = player->inventory.getList("main");
+					InventoryList* const ilist = player->inventory.getList("main");
 					// Delete item if all gone
 					if (item->getCount() <= dropcount) {
 						if (item->getCount() < dropcount)
 							infostream<<"WARNING: Server: dropped more items"
 								<<" than the slot contains"<<std::endl;
@@ -4202,19 +4191,19 @@
 
 				/*
 					Check that the block is loaded so that the item
 					can properly be added to the static list too
 				*/
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 				if (block==NULL) {
 					infostream<<"Error while placing object: "
 							"block not found"<<std::endl;
 					return;
 				}
 
 				if (!config_get_bool("world.player.inventory.droppable")) {
-					InventoryList *mlist = player->inventory.getList("main");
+					InventoryList* const mlist = player->inventory.getList("main");
 					mlist->deleteItem(item_i);
 				}else if ((getPlayerPrivs(player) & PRIV_BUILD) == 0) {
 					infostream<<"Not allowing player to drop item: no build privs"<<std::endl;
 					return;
 				}
@@ -4228,17 +4217,17 @@
 				pos.Z += BS*0.2*(float)myrand_range(-1000,1000)/1000.0;
 
 				/*
 					Create the object
 				*/
-				ServerActiveObject *obj = wielditem->createSAO(&m_env, 0, pos);
+				ServerActiveObject* const obj = wielditem->createSAO(&m_env, 0, pos);
 
 				if (obj == NULL) {
 					InventoryItem *nitem;
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Delete the right amount of items from the slot
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 						nitem = ilist->changeItem(item_i,NULL);
 						// Send inventory
 						UpdateCrafting(peer_id);
 						SendInventory(peer_id);
 					}else{
@@ -4254,11 +4243,11 @@
 
 					infostream<<"Placed object"<<std::endl;
 
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Delete the right amount of items from the slot
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 
 						wielditem->setData(0);
 						ilist->addDiff(item_i,wielditem);
 
 						// Send inventory
@@ -4278,11 +4267,11 @@
 					return;
 				}
 				if (!config_get_bool("world.player.inventory.creative")) {
 					// Delete the right amount of items from the slot
 					u16 dropcount = item->getDropCount();
-					InventoryList *ilist = player->inventory.getList("main");
+					InventoryList* const ilist = player->inventory.getList("main");
 
 					// Delete item if all gone
 					if (item->getCount() <= dropcount) {
 						if (item->getCount() < dropcount)
 							infostream<<"WARNING: Server: dropped more items"
@@ -4314,11 +4303,11 @@
 
 				/*
 					Check that the block is loaded so that the item
 					can properly be added to the static list too
 				*/
-				MapBlock *block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
+				MapBlock* const block = m_env.getMap().getBlockNoCreateNoEx(blockpos);
 				if (block==NULL) {
 					infostream<<"Error while placing object: "
 							"block not found"<<std::endl;
 					return;
 				}
@@ -4342,34 +4331,40 @@
 				/*
 					Create the object
 				*/
 				ServerActiveObject *obj = NULL;
 				/* createSAO will drop all craft items, we may not want that */
-				if (
-					wielded_craft_features->content == wieldcontent
-					&& wielded_craft_features->drop_item == CONTENT_IGNORE
-				) {
-					InventoryItem *ditem = InventoryItem::create(wieldcontent,item->getDropCount());
-					obj = ditem->createSAO(&m_env, 0, pos);
-					delete ditem;
+				if (wielded_craft_features->content == wieldcontent
+						&& wielded_craft_features->drop_item == CONTENT_IGNORE) {
+				    InventoryItem* const ditem = InventoryItem::create(wieldcontent,item->getDropCount());
+				    obj = ditem->createSAO(&m_env, 0, pos);
+				    delete ditem;
 				}else{
-					obj = item->createSAO(&m_env, 0, pos);
+				    InventoryItem* const ditem = ilist->getItem(item_i);
+
+				    if(ditem)
+					obj = ditem->createSAO(&m_env, 0, pos);
 				}
 
 				if (obj == NULL) {
-					InventoryItem *nitem;
+					InventoryItem* nitem = NULL;
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Delete the right amount of items from the slot
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 						nitem = ilist->changeItem(item_i,NULL);
 						// Send inventory
 						UpdateCrafting(peer_id);
 						SendInventory(peer_id);
 					}else{
+					/* BUG PB : Get again, it can have disapperead. */
+					    InventoryItem* const wielditem = (InventoryItem*) player->getWieldItem();
+
+					    if(wielditem)
 						nitem = wielditem->clone();
 					}
-					m_env.dropToParcel(p_over,nitem);
+					if(nitem)
+					    m_env.dropToParcel(p_over,nitem);
 				}else{
 					actionstream<<player->getName()<<" places "<<item->getName()
 							<<" at "<<PP(p_over)<<std::endl;
 
 					// Add the object to the environment
@@ -4378,11 +4373,11 @@
 					infostream<<"Placed object"<<std::endl;
 
 					if (!config_get_bool("world.player.inventory.creative")) {
 						// Delete the right amount of items from the slot
 						u16 dropcount = item->getDropCount();
-						InventoryList *ilist = player->inventory.getList("main");
+						InventoryList* const ilist = player->inventory.getList("main");
 
 						// Delete item if all gone
 						if (item->getCount() <= dropcount) {
 							if(item->getCount() < dropcount)
 								infostream<<"WARNING: Server: dropped more items"
@@ -4409,12 +4404,11 @@
 
 		/*
 			Catch invalid actions
 		*/
 		else{
-			infostream<<"WARNING: Server: Invalid action "
-					<<action<<std::endl;
+			infostream<<"WARNING: Server: Invalid action " << action << std::endl;
 		}
 	}
 	break;
 	case TOSERVER_PLAYERDAMAGE:
 	{
@@ -4661,12 +4655,12 @@
 					if (
 						ma->to_inv == "current_player"
 						&& ma->from_inv == "current_player"
 						&& ma->to_list == "discard"
 					) {
-						InventoryList *list = player->inventory.getList("discard");
-						InventoryItem *item = list->getItem(0);
+						InventoryList* const list = player->inventory.getList("discard");
+						InventoryItem* item = list->getItem(0);
 						if (item) {
 							if (config_get_bool("world.player.inventory.droppable")) {
 								v3f pos = player->getPosition();
 								pos.Y += BS;
 								v3f dir = v3f(0,0,BS);
@@ -5164,10 +5158,13 @@
 
 void Server::SendPlayerInfo(float dtime)
 {
 	DSTACK(__FUNCTION_NAME);
 
+	JMutexAutoLock lock1(m_env_mutex);
+	JMutexAutoLock lock2(m_con_mutex);
+
 	std::ostringstream os(std::ios_base::binary);
 	u8 buf[12];
 
 	// Write command
 	writeU16(buf, TOCLIENT_PLAYERINFO);
@@ -5321,22 +5318,22 @@
 		player = (Player*)array_get_ptr(players,i);
 		if (!player)
 			continue;
 
 		writeU16(os, player->peer_id);
-		InventoryItem *item = (InventoryItem*)player->getWieldItem();
+		InventoryItem* const item = (InventoryItem*)player->getWieldItem();
 		if (item == NULL) {
 			writeU16(os,CONTENT_IGNORE);
 		}else{
 			writeU16(os,item->getContent());
 		}
 		const char* list[7] = {"hat","shirt","pants","boots","decorative","jacket","belt"};
 		for (int j=0; j<7; j++) {
-			InventoryList *l = player->inventory.getList(list[j]);
+			InventoryList* const l = player->inventory.getList(list[j]);
 			if (l == NULL)
 				continue;
-			InventoryItem *itm = l->getItem(0);
+			InventoryItem* const itm = l->getItem(0);
 			if (itm == NULL) {
 				writeU16(os,CONTENT_IGNORE);
 				continue;
 			}
 			writeU16(os,itm->getContent());
@@ -5360,22 +5357,22 @@
 
 	writeU16(os, TOCLIENT_PLAYERITEMS);
 	writeU16(os, 1);
 	writeU16(os, 8);
 	writeU16(os, player->peer_id);
-	InventoryItem *item = (InventoryItem*)player->getWieldItem();
+	InventoryItem* const item = (InventoryItem*)player->getWieldItem();
 	if (item == NULL) {
 		writeU16(os,CONTENT_IGNORE);
 	}else{
 		writeU16(os,item->getContent());
 	}
 	const char* list[7] = {"hat","shirt","pants","boots","decorative","jacket","belt"};
 	for (int j=0; j<7; j++) {
-		InventoryList *l = player->inventory.getList(list[j]);
+		InventoryList* const l = player->inventory.getList(list[j]);
 		if (l == NULL)
 			continue;
-		InventoryItem *itm = l->getItem(0);
+		InventoryItem* const itm = l->getItem(0);
 		if (itm == NULL) {
 			writeU16(os,CONTENT_IGNORE);
 			continue;
 		}
 		writeU16(os,itm->getContent());
@@ -5950,11 +5947,11 @@
 			name = narrow_to_wide(player->getName());
 		// Add name to information string
 		os<<name<<L",";
 	}
 	os<<L"}";
-	char* motd = config_get("world.game.motd");
+	const char* motd = config_get("world.game.motd");
 	if (motd && motd[0])
 		os<<std::endl<<L"# Server: "<<narrow_to_wide(motd);
 	return os.str();
 }
 
@@ -6048,13 +6045,11 @@
 	/*
 		Create a new player
 	*/
 	{
 		uint64_t privs = 0;
-		char* priv;
-
-		priv = config_get("world.server.client.default.privs");
+		const char* priv = config_get("world.server.client.default.privs");
 
 		if (priv && priv[0])
 			privs = auth_str2privs(priv);
 
 		player = new ServerRemotePlayer();
@@ -6238,17 +6233,16 @@
 	auth_save();
 }
 
 uint64_t Server::getPlayerPrivs(Player *player)
 {
-	const char* playername;
-	char* admin_name;
+
 	if (!player)
 		return 0;
 
-	playername = player->getName();
-	admin_name = config_get("world.server.admin");
+	const char* playername = player->getName();
+	const char* admin_name = config_get("world.server.admin");
 
 	if (admin_name && !strcmp(admin_name,playername))
 		return PRIV_ALL;
 
 	return getPlayerAuthPrivs(playername);
diff -rU5 voxelands-v1709.00old/src/server.h voxelands-v1709.00good/src/server.h
--- voxelands-v1709.00old/src/server.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/server.h	2024-06-12 21:51:59.522624526 +0200
@@ -57,11 +57,11 @@
 	This is a thread-safe class.
 */
 class BlockEmergeQueue
 {
 public:
-	BlockEmergeQueue()
+	BlockEmergeQueue() : m_queue(),m_mutex()
 	{
 		m_mutex.Init();
 	}
 
 	~BlockEmergeQueue()
diff -rU5 voxelands-v1709.00old/src/servermain.cpp voxelands-v1709.00good/src/servermain.cpp
--- voxelands-v1709.00old/src/servermain.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/servermain.cpp	2024-06-12 21:34:27.756584233 +0200
@@ -47,11 +47,11 @@
 #endif
 
 #include <iostream>
 #include <fstream>
 #include <time.h>
-#include <jmutexautolock.h>
+#include "jmutexautolock.h"
 #include <locale.h>
 #include "common_irrlicht.h"
 #include "debug.h"
 #include "map.h"
 #include "player.h"
@@ -135,14 +135,13 @@
 int main(int argc, char *argv[])
 {
 	/*
 		Initialization
 	*/
-
+	log_mutex.Init();
 	log_add_output_maxlev(&main_stderr_log_out, LMT_ACTION);
 	log_add_output_all_levs(&main_dstream_no_stderr_log_out);
-
 	log_register_thread("main");
 
 	// Set locale. This is for forcing '.' as the decimal point.
 	std::locale::global(std::locale("C"));
 	// This enables printing all characters in bitmap font
diff -rU5 voxelands-v1709.00old/src/sound.c voxelands-v1709.00good/src/sound.c
--- voxelands-v1709.00old/src/sound.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/sound.c	2024-06-09 13:17:14.663160131 +0200
@@ -466,11 +466,11 @@
 	free(e->token);
 	free(e);
 }
 
 /* play sound effect */
-uint32_t sound_play_effect(char* token, float volume, uint8_t loop, v3_t *pos)
+uint32_t sound_play_effect(const char* token, float volume, uint8_t loop, v3_t *pos)
 {
 	sound_instance_t *i;
 	sound_t *e = sound_data.effects.sounds;
 	if (!sound_data.init || !e)
 		return 0;
@@ -522,11 +522,11 @@
 
 	return i->id;
 }
 
 /* play music */
-uint32_t sound_play_music(char* token, float volume, uint8_t loop)
+uint32_t sound_play_music(const char* token, float volume, uint8_t loop)
 {
 	sound_t *e = sound_data.music.sounds;
 	if (!sound_data.init || !e)
 		return 0;
 
@@ -635,33 +635,33 @@
 	sound_stop_music(fade);
 	sound_stop_effects(fade);
 }
 
 /* command setter for sound effects volume */
-int sound_effects_setter(char* value)
+int sound_effects_setter(const char* value)
 {
 	float vf;
 	int v = strtol(value,NULL,10);
 	vf = (float)v/100.0;
 	sound_volume_effects(vf);
 
 	return 0;
 }
 
 /* command setter for music volume */
-int sound_music_setter(char* value)
+int sound_music_setter(const char* value)
 {
 	float vf;
 	int v = strtol(value,NULL,10);
 	vf = (float)v/100.0;
 	sound_volume_music(vf);
 
 	return 0;
 }
 
 /* command setter for master volume */
-int sound_master_setter(char* value)
+int sound_master_setter(const char* value)
 {
 	int v = strtol(value,NULL,10);
 	if (v < 0)
 		v = 0;
 	if (v > 100)
diff -rU5 voxelands-v1709.00old/src/sound.h voxelands-v1709.00good/src/sound.h
--- voxelands-v1709.00old/src/sound.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/sound.h	2024-06-09 13:17:14.663160131 +0200
@@ -38,20 +38,20 @@
 void sound_step(float dtime, v3_t *pos, v3_t *at, v3_t *up);
 int sound_load_effect(char* file, char* token);
 int sound_load_music(char* file, char* token);
 void sound_free_effect(char* token);
 void sound_free_music(char* token);
-uint32_t sound_play_effect(char* token, float volume, uint8_t loop, v3_t *pos);
-uint32_t sound_play_music(char* token, float volume, uint8_t loop);
+uint32_t sound_play_effect(const char* token, float volume, uint8_t loop, v3_t *pos);
+uint32_t sound_play_music(const char* token, float volume, uint8_t loop);
 void sound_stop_effects(int fade);
 void sound_stop_music(int fade);
 void sound_stop_single(uint32_t id);
 int sound_exists(uint32_t id);
 void sound_stop(int fade);
-int sound_master_setter(char* value);
-int sound_effects_setter(char* value);
-int sound_music_setter(char* value);
+int sound_master_setter(const char* value);
+int sound_effects_setter(const char* value);
+int sound_music_setter(const char* value);
 
 #ifdef _VL_SOUND_EXPOSE_INTERNAL
 /* defined in sound.c */
 void sound_process(float dtime);
 float sound_volume_master(float v);
diff -rU5 voxelands-v1709.00old/src/string.c voxelands-v1709.00good/src/string.c
--- voxelands-v1709.00old/src/string.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/string.c	2024-06-18 14:55:24.113327062 +0200
@@ -81,11 +81,11 @@
 
 	return l;
 }
 
 /* makes a string safe for use as a file or directory name */
-int str_sanitise(char* dest, int size, char* str)
+int str_sanitise(char* dest, int size,const char* str)
 {
 	int o = 0;
 	int i = 0;
 	int lws = 0;
 
@@ -105,11 +105,11 @@
 
 	return -1;
 }
 
 /* parse a string into a bool true/false 1/0 */
-int parse_bool(char* str)
+int parse_bool(const char* str)
 {
 	if (str) {
 		if (!strcmp(str,"true"))
 			return 1;
 		if (!strcmp(str,"yes"))
@@ -126,22 +126,22 @@
 
 	return 0;
 }
 
 /* parse a string to a v3_t */
-int str_tov3t(char* str, v3_t *v)
+int str_tov3t(const char* str, v3_t *v)
 {
-	char buff[256];
+	char buff[257];
 	char* b;
 	char* s1;
 	char* s2;
 	char *e;
 
 	if (!str)
 		return 1;
 
-	strncpy(buff,str,256);
+	strncpy(buff,str,256);buff[256] = '\0';
 
 	b = strchr(buff,'(');
 	if (!b)
 		return 1;
 	b++;
diff -rU5 voxelands-v1709.00old/src/tile.cpp voxelands-v1709.00good/src/tile.cpp
--- voxelands-v1709.00old/src/tile.cpp	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/tile.cpp	2024-06-09 13:17:14.664160423 +0200
@@ -549,11 +549,11 @@
 				driver->createImage(video::ECF_A8R8G8B8, dim);
 		img->copyTo(img2);
 		img->drop();*/
 
 		// Generate image by name
-		video::IImage *img2 = generate_image_from_scratch(name, m_device);
+		video::IImage* const img2 = generate_image_from_scratch(name, m_device);
 		if(img2 == NULL)
 		{
 			infostream<<"TextureSource::buildMainAtlas(): Couldn't generate texture atlas: Couldn't generate image \""<<name<<"\""<<std::endl;
 			continue;
 		}
@@ -1157,11 +1157,10 @@
 
 				float dst[4] = {0.,0.,1.,1.};
 				float src[4] = {0.,(s*progression),1.,(s*progression)+s};
 
 				alpha_blit(device,baseimg,img_crack,dst,src,part_of_name);
-
 				img_crack->drop();
 			}
 		}
 		/*
 			[combine:WxH:X,Y=filename:X,Y=filename2
@@ -1184,17 +1183,17 @@
 				infostream<<"Adding \""<<filename
 						<<"\" to combined ("<<x<<","<<y<<")"
 						<<std::endl;
 
 				if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
-					video::IImage *img = driver->createImageFromFile(buff);
+					video::IImage* const img = driver->createImageFromFile(buff);
 					if (img) {
 						core::dimension2d<u32> dim = img->getDimension();
 						infostream<<"Size "<<dim.Width
 								<<"x"<<dim.Height<<std::endl;
 						core::position2d<s32> pos_base(x, y);
-						video::IImage *img2 =
+						video::IImage* const img2 =
 								driver->createImage(video::ECF_A8R8G8B8, dim);
 						img->copyTo(img2);
 						img->drop();
 						img2->copyToWithAlpha(baseimg, pos_base,
 								core::rect<s32>(v2s32(0,0), dim),
@@ -1246,11 +1245,11 @@
 			if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
 
 				infostream<<"generate_image(): Loading path \""<<buff
 						<<"\""<<std::endl;
 
-				video::IImage *image = driver->createImageFromFile(buff);
+				video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (image == NULL) {
 					infostream<<"generate_image(): Loading path \""
 							<<buff<<"\" failed"<<std::endl;
 				}else{
@@ -1265,11 +1264,10 @@
 						c.setAlpha(255);
 						image->setPixel(x,y,c);
 					}
 					// Blit
 					image->copyTo(baseimg);
-
 					image->drop();
 				}
 			}
 		}
 		/*
@@ -1294,22 +1292,21 @@
 
 			if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
 
 				infostream<<"generate_image(): Loading path \""<<buff<<"\""<<std::endl;
 
-				video::IImage *image = driver->createImageFromFile(buff);
+				video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (image == NULL) {
 					infostream<<"generate_image(): Loading path \""
 							<<buff<<"\" failed"<<std::endl;
 				}else{
 					core::dimension2d<u32> dim = image->getDimension();
 					baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 					// Blit
 					image->copyTo(baseimg);
-
 					image->drop();
 
 					for(u32 y=0; y<dim.Height; y++)
 					for(u32 x=0; x<dim.Width; x++)
 					{
@@ -1350,22 +1347,21 @@
 
 			if (path_get((char*)"texture",const_cast<char*>(filename.c_str()),1,buff,1024)) {
 
 				infostream<<"generate_image(): Loading path \""<<buff<<"\""<<std::endl;
 
-				video::IImage *image = driver->createImageFromFile(buff);
+				video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (image == NULL) {
 					infostream<<"generate_image(): Loading path \""
 							<<buff<<"\" failed"<<std::endl;
 				}else{
 					core::dimension2d<u32> dim = image->getDimension();
 					baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 					// Blit
 					image->copyTo(baseimg);
-
 					image->drop();
 
 					for(u32 y=0; y<dim.Height; y++)
 					for(u32 x=0; x<dim.Width; x++)
 					{
@@ -1413,11 +1409,11 @@
 			}
 
 			u32 transform = parseImageTransform(part_of_name.substr(10));
 			core::dimension2d<u32> dim = imageTransformDimension(
 					transform, baseimg->getDimension());
-			video::IImage *image = driver->createImage(
+			video::IImage* const image = driver->createImage(
 					baseimg->getColorFormat(), dim);
 			assert(image);
 			imageTransform(transform, baseimg, image);
 			baseimg->drop();
 			baseimg = image;
@@ -1522,11 +1518,11 @@
 						imagename_top, device);
 				return true;
 			}
 
 			// Create image of render target
-			video::IImage *image = driver->createImage(rtt, v2s32(0,0), dim);
+			video::IImage* const image = driver->createImage(rtt, v2s32(0,0), dim);
 			assert(image);
 
 			baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 			if(image)
@@ -1642,11 +1638,11 @@
 						imagename_top, device);
 				return true;
 			}
 
 			// Create image of render target
-			video::IImage *image = driver->createImage(rtt, v2s32(0,0), dim);
+			video::IImage* const image = driver->createImage(rtt, v2s32(0,0), dim);
 			assert(image);
 
 			baseimg = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 			if(image)
@@ -1675,11 +1671,11 @@
 			video::SColor color;
 			if (!parseColorString(color_str, color, false))
 				return false;
 
 			core::dimension2d<u32> dim = baseimg->getDimension();
-			video::IImage *img = driver->createImage(video::ECF_A8R8G8B8, dim);
+			video::IImage* const img = driver->createImage(video::ECF_A8R8G8B8, dim);
 
 			if (!img) {
 				errorstream << "generateImagePart(): Could not create image "
 						<< "for part_of_name=\"" << part_of_name
 						<< "\", cancelling." << std::endl;
@@ -1711,11 +1707,11 @@
 			}
 
 			v2u32 frame_size = baseimg->getDimension();
 			frame_size.Y /= frame_count;
 
-			video::IImage *img = driver->createImage(video::ECF_A8R8G8B8,
+			video::IImage* const img = driver->createImage(video::ECF_A8R8G8B8,
 					frame_size);
 			if (!img) {
 				errorstream <<"generate_image(): Could not create image "
 						<< "for part_of_name=\"" << part_of_name
 						<< "\", cancelling." << std::endl;
@@ -1846,14 +1842,15 @@
 			driver->setRenderTarget(0, false, true, 0);
 
 			skin->setFont(std_font);
 
 			// Create image of render target
-			video::IImage *image = driver->createImage(rtt, v2s32(0,0), rtt_dim);
+			video::IImage* const image = driver->createImage(rtt, v2s32(0,0), rtt_dim);
 			assert(image);
 
-			video::IImage *new_baseimg = driver->createImage(video::ECF_A8R8G8B8, rtt_dim);
+			video::IImage* const new_baseimg =
+			    driver->createImage(video::ECF_A8R8G8B8, rtt_dim);
 			if (new_baseimg) {
 				baseimg->copyToScaling(new_baseimg);
 				baseimg->drop();
 				baseimg = new_baseimg;
 			}
@@ -1876,11 +1873,11 @@
 			float y = mystof(sf.next(","));
 			float X = mystof(sf.next(","));
 			float Y = mystof(sf.next(","));
 			std::string path = sf.end();
 			if (path_get((char*)"texture",const_cast<char*>(path.c_str()),1,buff,1024)) {
-				video::IImage *image = driver->createImageFromFile(buff);
+			    video::IImage* const image = driver->createImageFromFile(buff);
 
 				if (baseimg == NULL) {
 					errorstream << "generateImagePart(): baseimg == NULL "
 							<< "for part_of_name=\"" << part_of_name
 							<< "\", cancelling." << std::endl;
diff -rU5 voxelands-v1709.00old/src/utility.h voxelands-v1709.00good/src/utility.h
--- voxelands-v1709.00old/src/utility.h	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/utility.h	2024-06-12 21:53:37.178312473 +0200
@@ -41,10 +41,59 @@
 #include "debug.h"
 #include "strfnd.h"
 #include "exceptions.h"
 #include "porting.h"
 
+#if defined(__GNUC__) || defined(__clang__)
+#  define XINLINE inline
+#  define XFINLINE inline __attribute__ ((always_inline))
+#elif defined(__BORLANDC__) || defined(_MSC_VER) || defined(__LCC__)
+#  define XINLINE __inline
+#  define XFINLINE __forceinline
+#elif defined(__DMC__) || defined(__POCC__) || defined(__WATCOMC__) || \
+	defined(__SUNPRO_C)
+#  define XINLINE inline
+#  define XFINLINE inline
+#else
+#  define XINLINE inline
+#  define XFINLINE inline
+#endif
+
+#ifndef __I_IREFERENCE_COUNTED_H_INCLUDED__
+# ifdef __GNUC__
+    XFINLINE static int X1SyncGet(volatile int* const pval)
+    {
+	    return __sync_add_and_fetch(pval,0);
+    }
+
+    XFINLINE static int X1SyncInc(volatile int* const pval)
+    {
+	    return __sync_fetch_and_add(pval,1);
+    }
+
+    XFINLINE static int X1SyncDec(volatile int* const pval)
+    {
+	    return __sync_fetch_and_sub(pval,1);
+    }
+# else
+    XFINLINE static int X1SyncGet(volatile int* const pval)
+    {
+	    return *pval;
+    }
+
+    XFINLINE static int X1SyncInc(volatile int* const pval)
+    {
+	    return (*pval)++;
+    }
+
+    XFINLINE static int X1SyncDec(volatile int* const pval)
+    {
+	    return (*pval)--;
+    }
+# endif
+#endif
+
 using namespace jthread;
 
 extern const v3s16 g_6dirs[6];
 
 extern const v3s16 g_26dirs[26];
@@ -316,13 +365,13 @@
 		ptr = t;
 	}
 	SharedPtr(SharedPtr<T> &t)
 	{
 		//*this = t;
-		drop();
+		//drop();
 		refcount = t.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 		ptr = t.ptr;
 	}
 	~SharedPtr()
 	{
 		drop();
@@ -335,13 +384,15 @@
 		ptr = t;
 		return *this;
 	}
 	SharedPtr<T> & operator=(SharedPtr<T> &t)
 	{
+		if(this == &t)
+		    return *this;
 		drop();
 		refcount = t.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 		ptr = t.ptr;
 		return *this;
 	}
 	T* operator->()
 	{
@@ -364,21 +415,22 @@
 		return ptr[i];
 	}
 private:
 	void drop()
 	{
-		assert((*refcount) > 0);
-		(*refcount)--;
-		if(*refcount == 0)
+		assert(refcount && X1SyncGet(refcount) > 0);
+		
+		if (X1SyncDec(refcount) == 1)
 		{
-			delete refcount;
-			if(ptr != NULL)
-				delete ptr;
+		    delete refcount;refcount = NULL;
+		    if(ptr != NULL)
+			delete ptr;
+		    ptr = NULL;
 		}
 	}
 	T *ptr;
-	int *refcount;
+	volatile int *refcount;
 };
 
 template <typename T>
 class Buffer
 {
@@ -452,92 +504,93 @@
 private:
 	void drop()
 	{
 		if(data)
 			delete[] data;
+		data = NULL;m_size = 0;
 	}
 	T *data;
 	unsigned int m_size;
 };
 
 template <typename T>
 class SharedBuffer
 {
 public:
-	SharedBuffer()
+	SharedBuffer() :
+			data(NULL),m_size(0),refcount(0)
 	{
-		m_size = 0;
-		data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
+		refcount = new int;*refcount = 1;
 	}
-	SharedBuffer(unsigned int size)
+	SharedBuffer(unsigned int size) :
+			data(NULL),m_size(size),refcount(0)
 	{
-		m_size = size;
-		if(m_size != 0)
-			data = new T[m_size];
-		else
-			data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
+		if(m_size)
+		    data = new T[m_size];
+		refcount = new int;*refcount = 1;
 	}
-	SharedBuffer(const SharedBuffer &buffer)
+	SharedBuffer(const SharedBuffer& buffer) :
+			data(buffer.data),m_size(buffer.m_size),
+			refcount(buffer.refcount)
 	{
 		//std::cout<<"SharedBuffer(const SharedBuffer &buffer)"<<std::endl;
-		m_size = buffer.m_size;
-		data = buffer.data;
-		refcount = buffer.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 	}
-	SharedBuffer & operator=(const SharedBuffer & buffer)
+	
+	SharedBuffer& operator=(const SharedBuffer& buffer)
 	{
 		//std::cout<<"SharedBuffer & operator=(const SharedBuffer & buffer)"<<std::endl;
 		if(this == &buffer)
-			return *this;
+		    return *this;
+		
 		drop();
-		m_size = buffer.m_size;
 		data = buffer.data;
+		m_size = buffer.m_size;
 		refcount = buffer.refcount;
-		(*refcount)++;
+		X1SyncInc(refcount);
 		return *this;
 	}
 	/*
 		Copies whole buffer
 	*/
-	SharedBuffer(T *t, unsigned int size)
+	SharedBuffer(T* const t,const unsigned int size)
 	{
-		m_size = size;
-		if(m_size != 0)
+		
+		if(size)
 		{
-			data = new T[m_size];
-			memcpy(data, t, m_size);
+		    data = new T[size];
+		    memcpy(data,t,size);
 		}
 		else
-			data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
+		    data = NULL;
+		
+		m_size = size;
+		refcount = new int;
+		*refcount = 1;
 	}
 	/*
 		Copies whole buffer
 	*/
 	SharedBuffer(const Buffer<T> &buffer)
 	{
 		m_size = buffer.getSize();
-		if(m_size != 0)
+		if(m_size)
 		{
-			data = new T[m_size];
-			memcpy(data, *buffer, buffer.getSize());
+		    data = new T[m_size];
+		    memcpy(data, *buffer, buffer.getSize());
 		}
 		else
-			data = NULL;
-		refcount = new unsigned int;
-		(*refcount) = 1;
+		    data = NULL;
+
+		refcount = new int;
+		*refcount = 1;
 	}
 	~SharedBuffer()
 	{
 		drop();
 	}
+	
 	T & operator[](unsigned int i) const
 	{
 		//assert(i < m_size)
 		return data[i];
 	}
@@ -554,22 +607,24 @@
 		return Buffer<T>(data, m_size);
 	}
 private:
 	void drop()
 	{
-		assert((*refcount) > 0);
-		(*refcount)--;
-		if(*refcount == 0)
+		assert(refcount && X1SyncGet(refcount) > 0);
+
+		if (X1SyncDec(refcount) == 1)
 		{
-			if(data)
-				delete[] data;
-			delete refcount;
+		    delete refcount;refcount = NULL;
+		    if(data)
+			delete[] data;
+		    data = NULL;m_size = 0;
 		}
 	}
-	T *data;
+	
+	T* data;
 	unsigned int m_size;
-	unsigned int *refcount;
+	volatile int* refcount;
 };
 
 inline SharedBuffer<u8> SharedBufferFromString(const char *string)
 {
 	SharedBuffer<u8> b((u8*)string, strlen(string)+1);
@@ -579,11 +634,11 @@
 template<typename T>
 class MutexedVariable
 {
 public:
 	MutexedVariable(T value):
-		m_value(value)
+			m_value(value),m_mutex()
 	{
 		m_mutex.Init();
 	}
 
 	T get()
@@ -1043,11 +1098,11 @@
 
 template<typename T>
 class MutexedQueue
 {
 public:
-	MutexedQueue()
+	MutexedQueue() : m_mutex(),m_list()
 	{
 		m_mutex.Init();
 	}
 	u32 size()
 	{
diff -rU5 voxelands-v1709.00old/src/world.c voxelands-v1709.00good/src/world.c
--- voxelands-v1709.00old/src/world.c	2017-09-24 06:59:00.000000000 +0200
+++ voxelands-v1709.00good/src/world.c	2024-06-15 19:18:25.886313507 +0200
@@ -21,11 +21,11 @@
 #include "path.h"
 #include "list.h"
 
 #include <string.h>
 
-static int world_exists(char* name)
+static int world_exists(const char* name)
 {
 	char buff[2048];
 	char nbuff[256];
 
 	if (!name)
@@ -38,15 +38,15 @@
 		return 0;
 
 	return 1;
 }
 
-int world_create(char* name)
+int world_create(const char* name)
 {
 	char buff[2048];
 	char nbuff[256];
-	char nbuff1[256];
+	char nbuff1[512];
 	int i;
 
 	if (!name || !name[0])
 		name = "New World";
 
@@ -63,11 +63,11 @@
 
 		return path_create("world","players");
 	}
 
 	for (i=1; i<100; i++) {
-		snprintf(nbuff1,256,"%s_%d",nbuff,i);
+		snprintf(nbuff1,512,"%s_%d",nbuff,i);
 		if (!path_get("worlds",nbuff1,1,buff,2048)) {
 			if (!path_get("worlds",nbuff1,0,buff,2048))
 				return 1;
 
 			config_set("world.path",nbuff1);
@@ -80,16 +80,16 @@
 	}
 
 	return 1;
 }
 
-int world_load(char* name)
+int world_load(const char* name)
 {
 	char buff[2048];
 	char buff1[2048];
 	char nbuff[256];
-	char* v;
+	const char* v;
 
 	config_clear("world");
 
 	if (!name) {
 #ifdef SERVER
@@ -130,11 +130,11 @@
 {
 	char buff[2048];
 	char pbuff[2048];
 	char newp[256];
 	char id[256];
-	char* v;
+	const char* v;
 
 	if (!path_exists(path))
 		return 1;
 
 	if (snprintf(buff,2048,"%s",path) >= 2048)
@@ -142,16 +142,14 @@
 
 	v = strrchr(buff,'/');
 	if (!v)
 		return 1;
 
-	*v = 0;
-
 	config_set("world.path",buff);
 	config_load("world","world.cfg");
-
 	v = config_get("world.path");
+	
 	if (!v || !strcmp(v,buff) || !config_get("world.name")) {
 		config_clear("world");
 		return 1;
 	}
 
@@ -187,13 +185,13 @@
 	config_save("world","world","world.cfg");
 	config_clear("world");
 }
 
 /* initialise and/or create a world */
-int world_init(char* name)
+int world_init(const char* name)
 {
-	char *v;
+	const char *v;
 
 	if (!name) {
 #ifdef SERVER
 		name = config_get("server.world");
 #else
@@ -244,13 +242,13 @@
 {
 	dirlist_t *d;
 	dirlist_t *e;
 	worldlist_t *l = NULL;
 	worldlist_t *w;
-	char* n;
-	char* v;
-	char* m;
+	const char* n;
+	const char* v;
+	const char* m;
 
 	d = path_dirlist("worlds",NULL);
 
 	if (!d)
 		return NULL;
